<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-08-06T22:17:30.072Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
    - File path as an attribute
    - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
    original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
    between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
    the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.aidigestignore
.gitignore
.npmrc
.repopackignore
apps/backend/.eslintrc.js
apps/backend/.prettierrc
apps/backend/drizzle.config.ts
apps/backend/nest-cli.json
apps/backend/package.json
apps/backend/README.md
apps/backend/src/app.controller.spec.ts
apps/backend/src/app.controller.ts
apps/backend/src/app.module.ts
apps/backend/src/app.service.ts
apps/backend/src/auth/auth.controller.ts
apps/backend/src/auth/auth.module.ts
apps/backend/src/auth/auth.service.ts
apps/backend/src/auth/strategies/jwt.tstrategy.ts
apps/backend/src/auth/strategies/SessionSerializer.ts
apps/backend/src/auth/strategies/telegram.strategy.ts
apps/backend/src/auth/utils/authenticated.guard.ts
apps/backend/src/auth/utils/telegram.guard.ts
apps/backend/src/blockchain/solana/sniper/solanaAutoSellSniper.service.ts
apps/backend/src/blockchain/solana/sniper/solanaSniper.module.ts
apps/backend/src/blockchain/solana/solana.controller.ts
apps/backend/src/blockchain/solana/solana.module.ts
apps/backend/src/blockchain/solana/solana.service.ts
apps/backend/src/blockchain/solana/token/solanaToken.controller.ts
apps/backend/src/blockchain/solana/token/solanaToken.module.ts
apps/backend/src/blockchain/solana/token/solanaToken.service.spec.ts
apps/backend/src/blockchain/solana/token/solanaToken.service.ts
apps/backend/src/common/helpers/convertDexscreenerData.ts
apps/backend/src/common/helpers/getSignature.ts
apps/backend/src/common/helpers/sleep.ts
apps/backend/src/common/helpers/transactionSender.ts
apps/backend/src/common/interfaces/blockchain.interface.ts
apps/backend/src/common/interfaces/dexscreenerData.interface.ts
apps/backend/src/common/interfaces/user.interface.ts
apps/backend/src/drizzle/drizzle.module.ts
apps/backend/src/drizzle/drizzle.provider.ts
apps/backend/src/drizzle/schema.ts
apps/backend/src/encryption/encryption.module.ts
apps/backend/src/encryption/encryption.service.ts
apps/backend/src/main.ts
apps/backend/src/user/dto/BuyToken.dto.ts
apps/backend/src/user/dto/SellToken.dto.ts
apps/backend/src/user/user.controller.ts
apps/backend/src/user/user.module.ts
apps/backend/src/user/user.service.ts
apps/backend/test/app.e2e-spec.ts
apps/backend/test/jest-e2e.json
apps/backend/transactions.json
apps/backend/tsconfig.build.json
apps/backend/tsconfig.json
apps/frontend/.gitignore
apps/frontend/.prettierignore
apps/frontend/.prettierrc
apps/frontend/eslint.config.js
apps/frontend/package.json
apps/frontend/playwright.config.ts
apps/frontend/postcss.config.js
apps/frontend/README.md
apps/frontend/src/app.css
apps/frontend/src/app.d.ts
apps/frontend/src/app.html
apps/frontend/src/components/common/BottomNavigation.svelte
apps/frontend/src/components/common/CopyToClipboard.svelte
apps/frontend/src/components/common/Navbar.svelte
apps/frontend/src/components/TelegramLoginWidget.svelte
apps/frontend/src/components/trade/BuyTradeForm.svelte
apps/frontend/src/components/trade/TokenInformationModal.svelte
apps/frontend/src/components/trade/TradeForm.svelte
apps/frontend/src/components/trade/VolatileMarketProjections.svelte
apps/frontend/src/hooks.server.ts
apps/frontend/src/index.test.ts
apps/frontend/src/lib/api.ts
apps/frontend/src/lib/index.ts
apps/frontend/src/lib/VolatileMarketStrategy.ts
apps/frontend/src/routes/+layout.svelte
apps/frontend/src/routes/+page.svelte
apps/frontend/src/routes/dashboard/+layout.server.ts
apps/frontend/src/routes/dashboard/+layout.svelte
apps/frontend/src/routes/dashboard/+page.svelte
apps/frontend/src/routes/dashboard/trade/+page.svelte
apps/frontend/src/routes/login/+page.svelte
apps/frontend/src/services/priceUpdateService.ts
apps/frontend/src/services/tokenService.ts
apps/frontend/src/stores/auth.ts
apps/frontend/src/stores/priceStore.ts
apps/frontend/src/stores/tokenStore.ts
apps/frontend/src/stores/userStore.ts
apps/frontend/src/types/global.d.ts
apps/frontend/src/utils/copyToClipboard.ts
apps/frontend/src/utils/formatters.ts
apps/frontend/svelte.config.js
apps/frontend/tailwind.config.js
apps/frontend/tests/test.ts
apps/frontend/tsconfig.json
apps/frontend/vite.config.ts
codebase.md
package.json
packages/shared-types/package.json
packages/shared-types/src/autoSell.interface.ts
packages/shared-types/src/drizzle.types.ts
packages/shared-types/src/dto/BuyToken.dto.ts
packages/shared-types/src/dto/SellToken.dto.ts
packages/shared-types/src/JupiterPriceResponse.interface.ts
packages/shared-types/src/TelegramAuthData.interface.ts
packages/shared-types/src/tokenInfo.interface.ts
packages/shared-types/src/userInfo.interface.ts
packages/shared-types/tsconfig.json
README.md
tsconfig.json
</repository_structure>

<repository_files>

<file path=".aidigestignore">
.svelte-kit
dist
migrations
solana_listener
example_data
static
node_modules
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Nest.JS build output
dist/

# Drizzle migrations output
migrations/
</file>

<file path=".npmrc">
engine-strict=true
</file>

<file path=".repopackignore">
.svelte-kit
dist
migrations
solana_listener
example_data
static
node_modules
</file>

<file path="codebase.md">
# tsconfig.json

```json
{
   "compilerOptions": {
      "baseUrl": ".",
      "paths": {
         "shared-types": ["packages/shared-types/src"]
      }
   },
   "include": ["apps/**/*", "packages/**/*"]
}

```

# README.md

```md
# solana_trading_bot

```

# package.json

```json
{
   "name": "solana-trading-bot-workspace",
   "private": true,
   "scripts": {
      "build:shared-types": "tsc --project packages/shared-types",
      "prestart": "npm run build:shared-types",
      "start": "npm run start --workspace=backend",
      "predev": "npm run build:shared-types",
      "dev": "concurrently \"npm run dev --workspace=backend\" \"npm run dev --workspace=frontend\""
   },
   "workspaces": [
      "apps/*",
      "packages/*"
   ],
   "packageManager": "pnpm@8.15.1+sha512.831cf4c5f8b8374af71521d4d153db49d7086de615c2af7cb5e9d7eb8ba630ddac46fea495d643e552ef2e68a3aa99a3e5e9fbee8696702967504df5c59cb273"
}

```

# .npmrc

```
engine-strict=true

```

# .gitignore

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Nest.JS build output
dist/

# Drizzle migrations output
migrations/

```

# .aidigestignore

```
.svelte-kit
dist
migrations
solana_listener
example_data
static
node_modules
```

# packages\shared-types\tsconfig.json

```json
{
   "compilerOptions": {
      "declaration": true,
      "emitDeclarationOnly": true,
      "outDir": "dist",
      "rootDir": "src",
      "strict": true
   },
   "include": ["src"]
}

```

# packages\shared-types\package.json

```json
{
   "name": "shared-types",
   "version": "1.0.0",
   "main": "index.js",
   "scripts": {
      "build": "tsc"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "description": "",
   "dependencies": {
      "backend": "^0.0.1",
      "typescript": "^5.5.4"
   }
}

```

# apps\frontend\vite.config.ts

```ts
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vitest/config';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	},
	server: {
		host: 'example.com',
		port: 80
	}
});

```

# apps\frontend\tsconfig.json

```json
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	// except $lib which is handled by https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

```

# apps\frontend\tailwind.config.js

```js
import flowbitePlugin from 'flowbite/plugin';

/** @type {import('tailwindcss').Config} */
export default {
	content: [
		'./src/**/*.{html,js,svelte,ts}',
		'../../node_modules/flowbite-svelte/**/*.{html,js,svelte,ts}'
	],
	darkMode: 'selector',
	theme: {
		extend: {
			colors: {
				// flowbite-svelte
				primary: {
					50: '#FFF5F2',
					100: '#FFF1EE',
					200: '#FFE4DE',
					300: '#FFD5CC',
					400: '#FFBCAD',
					500: '#FE795D',
					600: '#EF562F',
					700: '#EB4F27',
					800: '#CC4522',
					900: '#A5371B'
				}
			}
		}
	},

	plugins: [flowbitePlugin]
};

```

# apps\frontend\svelte.config.js

```js
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://kit.svelte.dev/docs/integrations#preprocessors
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://kit.svelte.dev/docs/adapters for more information about adapters.
		adapter: adapter(),
		alias: {
			$services: './src/services',
			$components: './src/components'
		}
	}
};

export default config;

```

# apps\frontend\README.md

```md
# create-svelte

Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

\`\`\`bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
\`\`\`

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

\`\`\`bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
\`\`\`

## Building

To create a production version of your app:

\`\`\`bash
npm run build
\`\`\`

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.

```

# apps\frontend\postcss.config.js

```js
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```

# apps\frontend\playwright.config.ts

```ts
import type { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'tests',
	testMatch: /(.+\.)?(test|spec)\.[jt]s/
};

export default config;

```

# apps\frontend\package.json

```json
{
	"name": "frontend",
	"version": "0.0.1",
	"private": true,
	"scripts": {
		"dev": "cross-env HOST=custom.domain vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"test": "npm run test:integration && npm run test:unit",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"lint": "prettier --check . && eslint .",
		"format": "prettier --write .",
		"test:integration": "playwright test",
		"test:unit": "vitest"
	},
	"devDependencies": {
		"@playwright/test": "^1.28.1",
		"@sveltejs/adapter-auto": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^3.0.0",
		"@types/eslint": "^9.6.0",
		"@types/node": "^22.1.0",
		"autoprefixer": "^10.4.19",
		"cross-env": "^7.0.3",
		"eslint": "^9.0.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.36.0",
		"flowbite-svelte-icons": "^1.6.1",
		"globals": "^15.0.0",
		"postcss": "^8.4.40",
		"prettier": "^3.1.1",
		"prettier-plugin-svelte": "^3.1.2",
		"svelte": "^4.2.7",
		"svelte-check": "^3.6.0",
		"tailwindcss": "^3.4.7",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.0.0",
		"vite": "^5.0.3",
		"vitest": "^2.0.0"
	},
	"type": "module",
	"dependencies": {
		"axios": "^1.7.2",
		"flowbite": "^2.4.1",
		"flowbite-svelte": "^0.46.15",
		"lucide-svelte": "^0.424.0",
		"shared-types": "^1.0.0",
		"svelte-french-toast": "^1.2.0"
	}
}

```

# apps\frontend\eslint.config.js

```js
import js from '@eslint/js';
import ts from 'typescript-eslint';
import svelte from 'eslint-plugin-svelte';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

/** @type {import('eslint').Linter.Config[]} */
export default [
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
];

```

# apps\frontend\.prettierrc

```
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 120,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}

```

# apps\frontend\.prettierignore

```
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock

```

# apps\frontend\.gitignore

```
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

```

# apps\backend\tsconfig.json

```json
{
   // "extends": "../../tsconfig.json",
   "compilerOptions": {
      "module": "commonjs",
      "declaration": true,
      "removeComments": true,
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "allowSyntheticDefaultImports": true,
      "target": "ES2021",
      "sourceMap": true,
      "outDir": "./dist",
      "baseUrl": "./",
      "incremental": true,
      "skipLibCheck": true,
      "strictNullChecks": false,
      "noImplicitAny": false,
      "strictBindCallApply": false,
      "forceConsistentCasingInFileNames": false,
      "noFallthroughCasesInSwitch": false
   }
}

```

# apps\backend\tsconfig.build.json

```json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

```

# apps\backend\transactions.json

```json
[]
```

# apps\backend\README.md

```md
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

\`\`\`bash
$ npm install
\`\`\`

## Running the app

\`\`\`bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
\`\`\`

## Test

\`\`\`bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
\`\`\`

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).

```

# apps\backend\package.json

```json
{
   "name": "backend",
   "version": "0.0.1",
   "description": "",
   "author": "",
   "private": true,
   "license": "UNLICENSED",
   "scripts": {
      "build": "nest build",
      "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
      "start": "nest start",
      "start:dev": "nest start --watch",
      "start:debug": "nest start --debug --watch",
      "start:prod": "node dist/main",
      "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
      "test": "jest",
      "test:watch": "jest --watch",
      "test:cov": "jest --coverage",
      "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
      "test:e2e": "jest --config ./test/jest-e2e.json",
      "migrate": "npx drizzle-kit generate && npx drizzle-kit migrate"
   },
   "dependencies": {
      "@metaplex-foundation/mpl-token-metadata": "^3.2.1",
      "@metaplex-foundation/umi": "^0.9.2",
      "@metaplex-foundation/umi-bundle-defaults": "^0.9.2",
      "@nestjs/common": "^10.0.0",
      "@nestjs/core": "^10.0.0",
      "@nestjs/jwt": "^10.2.0",
      "@nestjs/mapped-types": "*",
      "@nestjs/passport": "^10.0.3",
      "@nestjs/platform-express": "^10.3.10",
      "@nestjs/schedule": "^4.1.0",
      "@solana/spl-token": "^0.4.8",
      "@solana/web3.js": "^1.95.0",
      "@supabase/supabase-js": "^2.44.3",
      "axios": "^1.7.3",
      "bcrypt": "^5.1.1",
      "bs58": "^4.0.1",
      "class-transformer": "^0.5.1",
      "class-validator": "^0.14.1",
      "dotenv": "^16.4.5",
      "drizzle-orm": "^0.32.0",
      "express-session": "^1.18.0",
      "moment": "^2.30.1",
      "passport": "^0.7.0",
      "passport-custom": "^1.1.1",
      "passport-jwt": "^4.0.1",
      "passport-local": "^1.0.0",
      "postgres": "^3.4.4",
      "promise-retry": "^2.0.1",
      "reflect-metadata": "^0.2.0",
      "rxjs": "^7.8.1",
      "shared-types": "^1.0.0"
   },
   "devDependencies": {
      "@nestjs/cli": "^10.0.0",
      "@nestjs/schematics": "^10.0.0",
      "@nestjs/testing": "^10.0.0",
      "@types/express": "^4.17.17",
      "@types/express-session": "^1.18.0",
      "@types/jest": "^29.5.2",
      "@types/node": "^20.3.1",
      "@types/supertest": "^6.0.0",
      "@typescript-eslint/eslint-plugin": "^7.0.0",
      "@typescript-eslint/parser": "^7.0.0",
      "drizzle-kit": "^0.23.0",
      "eslint": "^8.42.0",
      "eslint-config-prettier": "^9.0.0",
      "eslint-plugin-prettier": "^5.0.0",
      "jest": "^29.5.0",
      "prettier": "^3.0.0",
      "source-map-support": "^0.5.21",
      "supertest": "^7.0.0",
      "ts-jest": "^29.1.0",
      "ts-loader": "^9.4.3",
      "ts-node": "^10.9.1",
      "tsconfig-paths": "^4.2.0",
      "typescript": "^5.1.3"
   },
   "jest": {
      "moduleFileExtensions": [
         "js",
         "json",
         "ts"
      ],
      "rootDir": "src",
      "testRegex": ".*\\.spec\\.ts$",
      "transform": {
         "^.+\\.(t|j)s$": "ts-jest"
      },
      "collectCoverageFrom": [
         "**/*.(t|j)s"
      ],
      "coverageDirectory": "../coverage",
      "testEnvironment": "node"
   }
}

```

# apps\backend\nest-cli.json

```json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

```

# apps\backend\drizzle.config.ts

```ts
import { config } from 'dotenv'
import { defineConfig } from 'drizzle-kit'

config({ path: '.env' })

export default defineConfig({
   schema: './src/drizzle/schema.ts',
   out: './src/drizzle/migrations',
   dialect: 'postgresql',
   dbCredentials: {
      url: process.env.DATABASE_URL!,
   },
})

```

# apps\backend\.prettierrc

```
{
  "tabWidth": 3,
  "semi": false,
  "singleQuote": true,
  "printWidth": 150
}

```

# apps\backend\.eslintrc.js

```js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prettier/prettier': ['error', { endOfLine: 'auto' }],
  },
};

```

# packages\shared-types\src\TelegramAuthData.interface.ts

```ts
export interface TelegramAuthData {
   auth_date: number;
   first_name: string;
   hash: string;
   id: number;
   last_name: string;
}

```

# packages\shared-types\src\drizzle.types.ts

```ts
import {
   usersTable,
   authProvidersTable,
   userWalletsTable,
   autoSellTable,
   tokenPairInfo,
   tokenPairTransactionsTable,
   dexTransactionsTable,
   dexTransactionsErrorsTable,
} from "backend/src/drizzle/schema";

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert;
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect;

export type InsertUserWallet = typeof userWalletsTable.$inferInsert;
export type SelectUserWallet = typeof userWalletsTable.$inferSelect;

export type InsertAutoSell = typeof autoSellTable.$inferInsert;
export type SelectAutoSell = typeof autoSellTable.$inferSelect;

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert;
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect;

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert;
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect;

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert;
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect;

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert;
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect;

```

# apps\frontend\src\index.test.ts

```ts
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});

```

# apps\frontend\src\hooks.server.ts

```ts
import { PUBLIC_BACKEND_URL } from '$env/static/public';
import type { Handle } from '@sveltejs/kit';

export const handle: Handle = async ({ event, resolve }) => {
	if (event.cookies.get('connect.sid')) {
		const res = await fetch(PUBLIC_BACKEND_URL + '/user/status', {
			credentials: 'include',
			headers: {
				Cookie: 'connect.sid=' + event.cookies.get('connect.sid')
			}
		});
		const data = await res.json();
		if (res.ok) {
			event.locals.user = data;
		}
	}
	const response = await resolve(event);
	return response;
};

```

# apps\frontend\src\app.html

```html
<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Audiowide&family=Manrope:wght@200..800&family=Quicksand:wght@300..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

```

# apps\frontend\src\app.d.ts

```ts
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		interface Locals {
			user: {
				id: number;
				createdAt: string;
			};
		}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

```

# apps\frontend\src\app.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	input[type='number']::-webkit-inner-spin-button,
	input[type='number']::-webkit-outer-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}
	input[type='number'] {
		appearance: textfield;
	}
}

.manrope {
	font-family: 'Manrope', sans-serif;
}

.audiowide {
	font-family: 'Audiowide', sans-serif;
}

.quicksand {
	font-family: 'Quicksand', sans-serif;
}

body {
	background-color: #121528;
	min-height: 100vh;
}

```

# apps\frontend\tests\test.ts

```ts
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});

```

# apps\backend\test\jest-e2e.json

```json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}

```

# apps\backend\test\app.e2e-spec.ts

```ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});

```

# apps\backend\src\main.ts

```ts
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import 'dotenv/config'
import * as session from 'express-session'
import * as passport from 'passport'

async function bootstrap() {
   const app = await NestFactory.create(AppModule)
   app.use(
      session({
         secret: 'my-secret',
         resave: false,
         saveUninitialized: false,
         cookie: {
            httpOnly: true,
            maxAge: 3600000,
            secure: false, // Set to true if you are using HTTPS
            sameSite: 'lax',
         },
      }),
   )
   app.use(passport.initialize())
   app.use(passport.session())

   app.enableCors({
      origin: 'http://example.com', // Adjust the origin according to where your front-end is hosted
      methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
      allowedHeaders: 'Content-Type, Accept',
      credentials: true,
   })
   await app.listen(3000)
}
bootstrap()

```

# apps\backend\src\app.service.ts

```ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}

```

# apps\backend\src\app.module.ts

```ts
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { DrizzleModule } from './drizzle/drizzle.module'
import { UserModule } from './user/user.module'
import { SolanaModule } from './blockchain/solana/solana.module'
import { AuthModule } from './auth/auth.module'
import { PassportModule } from '@nestjs/passport'

@Module({
   imports: [
      PassportModule.register({
         session: true,
      }),
      DrizzleModule,
      UserModule,
      SolanaModule,
      AuthModule,
   ],
   controllers: [AppController],
   providers: [AppService],
})
export class AppModule {}

```

# apps\backend\src\app.controller.ts

```ts
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

```

# apps\backend\src\app.controller.spec.ts

```ts
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});

```

# packages\shared-types\src\dto\SellToken.dto.ts

```ts
export interface SellTokenDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
}

```

# packages\shared-types\src\dto\BuyToken.dto.ts

```ts
import { InsertAutoSell } from "../drizzle.types";

export interface BuyTokenDto {
   walletAddress: string;
   tokenAddress: string;
   solAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
   autoSell?: Omit<InsertAutoSell, "tokenAmountToSell">; // Use 'any' or a more specific type if available
}

```

# apps\frontend\src\types\global.d.ts

```ts
// src/types/global.d.ts
import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';

declare global {
	interface Window {
		onTelegramAuth: (user: TelegramAuthData) => void;
	}
}

export {};

```

# apps\frontend\src\routes\+page.svelte

```svelte
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { Card } from 'flowbite-svelte';
	async function getStatus() {
		const res = await fetch(PUBLIC_BACKEND_URL + '/user', {
			credentials: 'include'
		});
		const data = await res.json();
		console.log(data);
	}
</script>

<h1 class="text-3xl font-bold underline">Hello world!</h1>

<TelegramLoginWidget />

<button on:click={getStatus}> GET STATUS</button>

<Card href="/cards">
	<h5 class="mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
		Noteworthy technology acquisitions 2021
	</h5>
	<p class="font-normal text-gray-700 dark:text-gray-400 leading-tight">
		Here are the biggest enterprise technology acquisitions of 2021 so far, in reverse chronological
		order.
	</p>
</Card>

<style lang="postcss">
	:global(html) {
		background-color: theme(colors.gray.100);
	}
</style>

```

# apps\frontend\src\routes\+layout.svelte

```svelte
<script lang="ts">
	import '../app.css';
	export let data;

	$: console.log(data);
</script>

<slot />

```

# apps\frontend\src\routes\+layout.server.ts

```ts
export async function load({ locals }) {
	return {
		user: locals.user
	};
}

```

# apps\frontend\src\stores\auth.ts

```ts
import { writable } from 'svelte/store';

export const token = writable(localStorage.getItem('token') || '');

token.subscribe((value) => {
	if (value) {
		localStorage.setItem('token', value);
	} else {
		localStorage.removeItem('token');
	}
});

```

# apps\frontend\src\lib\index.ts

```ts
// place files you want to import through the `$lib` alias in this folder.

```

# apps\frontend\src\lib\api.ts

```ts
import axios from 'axios';
import { token } from '../stores/auth';

let jwtToken = '';
token.subscribe((value: string) => {
	jwtToken = value;
});

const api = axios.create({
	baseURL: 'http://localhost:3000'
});

api.interceptors.request.use((config) => {
	if (jwtToken) {
		config.headers.Authorization = `Bearer ${jwtToken}`;
	}
	return config;
});

export default api;

```

# apps\frontend\src\services\DataService.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import toast from 'svelte-french-toast';

class APIWrapper {
	private static port = 8080;
	private static baseUrl = `http://localhost:${this.port}`;

	private static async wrappedFetch(path: string, options?: RequestInit) {
		const response = await fetch(this.baseUrl + path, options);
		if (!response.ok) {
			toast.error('Something failed. Please try again', {
				style: 'border-radius:4px; border: 2px solid red;'
			});
			throw new Error(response.statusText);
		}
		try {
			const data = await response.json();
			return data;
		} catch (e) {
			return response;
		}
	}

	static async get(path: string, ...query: string[]) {
		query = query.filter((q) => q !== null);
		const fullPathString = query.length > 0 ? `${path}?${query.join('&')}` : path;
		return await this.wrappedFetch(fullPathString);
	}

	static async post(path: string, body: unknown) {
		return await this.wrappedFetch(path, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json'
			},
			body: typeof body === 'string' ? body : JSON.stringify(body)
		});
	}
}

export class DataService {
	private static page = 0;
	private static size = 6;
	private static sortBy: 'createdAt' | 'price' = 'createdAt';
	private static order: 'desc' | 'asc' = 'desc';
	private static categories: string[] = [];

	public static async setPage(page: number) {
		this.page = page;
	}

	public static async setSortBy(sortBy: 'createdAt' | 'price') {
		this.sortBy = sortBy;
	}

	public static async setOrder(order: 'desc' | 'asc') {
		this.order = order;
	}

	public static async addCategory(category: string) {
		this.categories.push(category);
	}

	public static async removeCategory(category: string) {
		this.categories = this.categories.filter((cat) => cat !== category);
	}

	public static async clearCategories() {
		this.categories = [];
	}
}

```

# apps\frontend\src\components\TelegramLoginWidget.svelte

```svelte
<script lang="ts">
	import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { goto } from '$app/navigation';

	async function onTelegramAuth(user: TelegramAuthData) {
		console.log(JSON.stringify(user));
		const res = await fetch(PUBLIC_BACKEND_URL + '/auth/loginWithTelegram', {
			method: 'POST',
			body: JSON.stringify(user),
			credentials: 'include',
			headers: {
				'Content-Type': 'application/json'
			}
		});
		if (res.ok) {
			const data = await res.json();
			goto('/dashboard');
		} else {
			console.error('Failed to login with Telegram');
		}
	}

	// Svelte action to load the Telegram widget
	function loadTelegramWidget(node: HTMLElement) {
		if (typeof window !== 'undefined') {
			window.onTelegramAuth = onTelegramAuth;

			const script = document.createElement('script');
			script.src = 'https://telegram.org/js/telegram-widget.js?7';
			script.async = true;
			script.setAttribute('data-telegram-login', 'SolanaCryptoTradingTestBot');
			script.setAttribute('data-size', 'large');
			script.setAttribute('data-radius', '10');
			script.setAttribute('data-onauth', 'onTelegramAuth(user)');
			script.setAttribute('data-userpic', 'false');
			node.appendChild(script);
		}
	}
</script>

<div class="telegram-login" use:loadTelegramWidget></div>

<style>
	div {
		width: 100%;
		display: flex;
		justify-content: center;
	}
</style>

```

# apps\backend\src\user\user.service.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Inject, Injectable } from '@nestjs/common'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { eq, and } from 'drizzle-orm'
import { EncryptionService } from 'src/encryption/encryption.service'
import { SolanaService } from 'src/blockchain/solana/solana.service'
import { InsertAutoSell } from 'shared-types/src/drizzle.types'
import { SolanaAutoSellSniperService } from 'src/blockchain/solana/sniper/solanaAutoSellSniper.service'

@Injectable()
export class UserService {
   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private encryptionService: EncryptionService,
      private solanaService: SolanaService,
      private solanaAutoSellSniperService: SolanaAutoSellSniperService,
   ) {}

   async findById(id: number): Promise<schema.SelectUser | undefined> {
      const user = await this.db.select().from(schema.usersTable).where(eq(schema.usersTable.id, id)).limit(1)
      return user[0]
   }

   async findByTelegramId(telegramId: number): Promise<schema.SelectUser | undefined> {
      const subQuery = this.db
         .select()
         .from(schema.authProvidersTable)
         .where(eq(schema.authProvidersTable.providerId, telegramId.toString()))
         .limit(1)
         .as('sq')
      const user = await this.db.select().from(schema.usersTable).leftJoin(subQuery, eq(schema.usersTable.id, subQuery.userId)).limit(1)
      return user[0] === undefined ? undefined : user[0].users_table
   }

   async create(user: schema.InsertUser, authProvider: Omit<schema.InsertAuthProvider, 'userId'>): Promise<schema.SelectUser> {
      const newUser = await this.db.transaction(async (tx) => {
         const newUser = await tx.insert(schema.usersTable).values(user).returning()
         await tx.insert(schema.authProvidersTable).values({
            providerId: authProvider.providerId,
            provider: authProvider.provider,
            userId: newUser[0].id,
         })
         const newKeyPair = this.solanaService.createNewWallet()
         const encryptedPrivateKey = this.encryptionService.encrypt(
            this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
            newUser[0].createdAt.toISOString(),
         )
         await tx.insert(schema.userWalletsTable).values({
            userId: newUser[0].id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
         })
         return newUser
      })
      return newUser[0]
   }

   async createWallet(user: schema.SelectUser): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.createNewWallet()
      const encryptedPrivateKey = this.encryptionService.encrypt(
         this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
         user.createdAt.toISOString(),
      )
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
         })
         .returning()
      return wallet[0]
   }

   async importWalletFromPk(user: schema.SelectUser, privateKey: string): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.base58ToKeypair(privateKey)
      const encryptedPrivateKey = this.encryptionService.encrypt(privateKey, user.createdAt.toISOString())
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
         })
         .returning()
      return wallet[0]
   }

   async getWallets(user: schema.SelectUser): Promise<schema.SelectUserWallet[]> {
      return await this.db.select().from(schema.userWalletsTable).where(eq(schema.userWalletsTable.userId, user.id))
   }

   async getWalletByAddress(user: schema.SelectUser, walletAddress: string): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, user.id), eq(schema.userWalletsTable.walletAddress, walletAddress)))
         .limit(1)
      return wallet[0]
   }

   async getWalletById(userId: number, walletId: number): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, userId), eq(schema.userWalletsTable.id, walletId)))
         .limit(1)
      return wallet[0]
   }

   async buyToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      solAmountIn: string,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto',
      autoSell?: Omit<InsertAutoSell, 'tokenAmountToSell'>,
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)

      const tokenAmountOut = await this.solanaService.makeJupiterSwapTransaction(
         this.solanaService.knownAddresses.WSOL,
         tokenAddress,
         parseFloat(solAmountIn),
         slippageInPercentage * 100,
         this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
         prioritizationFeeLamports,
      )

      if (autoSell) {
         await this.solanaAutoSellSniperService.addAutoSellEntry({
            ...autoSell,
            tokenAmountToSell: tokenAmountOut,
            userId: user.id,
            walletId: wallet.id,
         })
      }
   }

   async sellToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      tokenAmountIn: string,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto' = 'auto',
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)

      await this.solanaService.makeJupiterSwapTransaction(
         tokenAddress,
         this.solanaService.knownAddresses.WSOL,
         parseFloat(tokenAmountIn),
         slippageInPercentage * 100,
         this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
         prioritizationFeeLamports,
      )
   }
}

```

# apps\backend\src\user\user.module.ts

```ts
import { forwardRef, Module } from '@nestjs/common'
import { UserService } from './user.service'
import { UserController } from './user.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { EncryptionModule } from 'src/encryption/encryption.module'
import { SolanaModule } from 'src/blockchain/solana/solana.module'
import { SolanaSniperModule } from 'src/blockchain/solana/sniper/solanaSniper.module'

@Module({
   imports: [EncryptionModule, SolanaModule, forwardRef(() => SolanaSniperModule)],
   controllers: [UserController],
   providers: [UserService, ...drizzleProvider],
   exports: [UserService],
})
export class UserModule {}

```

# apps\backend\src\user\user.controller.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Controller, Get, Post, Body, Param, Delete, Session, UseGuards, Request } from '@nestjs/common'
import { UserService } from './user.service'
import { AuthenticatedGuard } from 'src/auth/utils/authenticated.guard'
import { BuyTokenDto } from './dto/BuyToken.dto'
import { SellTokenDto } from './dto/SellToken.dto'

@Controller('user')
export class UserController {
   constructor(private readonly userService: UserService) {}

   @Get('status')
   @UseGuards(AuthenticatedGuard)
   status(@Request() req) {
      console.log('Here', req.user)
      return req.user
   }

   @Post('buy-token')
   @UseGuards(AuthenticatedGuard)
   async buyToken(@Body() buyTokenDto: BuyTokenDto, @Request() req): Promise<void> {
      const { walletAddress, tokenAddress, solAmountIn, slippageInPercentage, prioritizationFeeLamports, autoSell } = buyTokenDto
      await this.userService.buyToken(req.user, walletAddress, tokenAddress, solAmountIn, slippageInPercentage, prioritizationFeeLamports, autoSell)
   }

   @Post('sell-token')
   @UseGuards(AuthenticatedGuard)
   async sellToken(@Body() sellTokenDto: SellTokenDto, @Request() req): Promise<void> {
      const { walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports } = sellTokenDto
      await this.userService.sellToken(req.user, walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports)
   }
}

```

# apps\backend\src\drizzle\schema.ts

```ts
import { pgTable, pgEnum } from 'drizzle-orm/pg-core'
import { serial, varchar, text, integer, numeric, boolean, timestamp, unique } from 'drizzle-orm/pg-core'

// Enum for TokenTransactions time
export const timeEnum = pgEnum('time', ['5m', '1h', '6h', '12h', '24h'])
export const dexTransactionTypeEnum = pgEnum('dex_transaction_type', ['buy', 'sell', 'add_liquidity', 'remove_liquidity', 'init_lp'])
export const primaryTokenNameEnum = pgEnum('primary_token_name', ['WSOL', 'USDC'])
export const dexNameEnum = pgEnum('dex_name', ['Raydium'])
export const authProviderEnum = pgEnum('auth_provider', ['telegram', 'discord', 'google', 'twitter'])

export const usersTable = pgTable('users_table', {
   id: serial('id').primaryKey(),
   createdAt: timestamp('created_at').notNull().defaultNow(),
})

export const authProvidersTable = pgTable(
   'auth_providers',
   {
      id: serial('id').primaryKey(),
      provider: authProviderEnum('provider').notNull(),
      providerId: text('provider_id').notNull(),
      userId: integer('user_id')
         .notNull()
         .references(() => usersTable.id),
   },
   (t) => ({
      unq: unique().on(t.provider, t.providerId),
   }),
)

export const userWalletsTable = pgTable('user_wallets', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletAddress: varchar('wallet_address', { length: 44 }).notNull(),
   walletPk: varchar('wallet_pk', { length: 225 }).notNull(),
   name: varchar('name', { length: 50 }),
})

export const autoSellTable = pgTable('auto_sell', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletId: integer('wallet_id')
      .notNull()
      .references(() => userWalletsTable.id),
   tokenAddressToSell: varchar('token_address_to_sell', { length: 44 }).notNull(),
   tokenAmountToSell: varchar('token_amount_to_sell', { length: 40 }).notNull(),
   solAmountProfitTrigger: numeric('sol_amount_profit_trigger').notNull(),
   solAmountLossTrigger: numeric('sol_amount_loss_trigger').notNull(),
   slippage: numeric('slippage').notNull(),
})

// TokenInfo Table
export const tokenPairInfo = pgTable('token_pair_info', {
   id: serial('id').primaryKey(),
   primaryTokenName: primaryTokenNameEnum('primary_token_name').notNull(),
   initialPrimaryTokenAmountInLP: numeric('initial_primary_token_in_lp').notNull(),
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(),
   initialSecondaryTokenAmountInLP: numeric('initial_secondary_token_in_lp').notNull(),
   tokenPairCreator: varchar('token_pair_creator', { length: 44 }),
   timestamp: timestamp('timestamp').notNull(),
   creationTransaction: varchar('creation_transaction', { length: 90 }).notNull(),
   verifiedDexScreener: boolean('verified_dex_screener'),
   verifiedBirdEye: boolean('verified_bird_eye'),
   dexName: dexNameEnum('dex_name').notNull(),
})

// TokenTransactions Table
export const tokenPairTransactionsTable = pgTable('token_pair_transactions', {
   id: serial('id').primaryKey(),
   tokenPairId: integer('token_pair_id').notNull(),
   time: timeEnum('time'),
   txCount: integer('tx_count'),
   volume: numeric('volume'),
   volumeInUSD: numeric('volume_in_usd'),
   uniqueWallets: integer('unique_wallets'),
   buys: integer('buys'),
   sells: integer('sells'),
   buyVolumeInUSD: numeric('buy_volume_in_usd'),
   sellVolumeInUSD: numeric('sell_volume_in_usd'),
   buyers: integer('buyers'),
   sellers: integer('sellers'),
})

export const dexTransactionsTable = pgTable('dex_transactions', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 90 }).notNull(),
   timestamp: timestamp('timestamp').notNull(),
   blockNumber: integer('block_number').notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   primaryTokenName: primaryTokenNameEnum('primary_token_address').notNull(), // WSOL or USDC
   primaryTokenAmount: numeric('primary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of WSOL or USDC
   primaryTokenPrice: numeric('primary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of WSOL or USDC
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(), // Random token
   secondaryTokenAmount: numeric('secondary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of the random token
   secondaryTokenPrice: numeric('secondary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of the random token
   transactionType: dexTransactionTypeEnum('transaction_type').notNull(), // Buy, Sell, AddLiquidity, RemoveLiquidity
   transactionValueInUsd: numeric('transaction_value_in_usd', { precision: 20, scale: 8 }).notNull(), // Value of the transaction in USD
   dexName: dexNameEnum('dex_name').notNull(), // Name of the DEX
   isUsingJupiter: boolean('is_using_jupiter').notNull(), // Whether Jupiter is used
})

export const dexTransactionsErrorsTable = pgTable('dex_transactions_errors', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 87 }).notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   error: text('error').notNull(),
   dexName: dexNameEnum('dex_name').notNull(),
})

// Relations
// export const tokenInfoRelations = relations(tokenPairInfo, ({ one, many }) => ({
//    transactions: many(tokenTransactionsTable),
// }))

// export const tokenTransactionsRelations = relations(tokenTransactionsTable, ({ one }) => ({
//    token: one(tokenPairInfo, {
//       fields: [tokenTransactionsTable.tokenAddress],
//       references: [tokenPairInfo.address],
//    }),
// }))

export type InsertUser = typeof usersTable.$inferInsert
export type SelectUser = typeof usersTable.$inferSelect

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect

export type InsertUserWallet = typeof userWalletsTable.$inferInsert
export type SelectUserWallet = typeof userWalletsTable.$inferSelect

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect

```

# apps\backend\src\drizzle\drizzle.provider.ts

```ts
import { drizzle } from 'drizzle-orm/postgres-js'
import * as postgres from 'postgres'
import * as schema from './schema'

export const DrizzleAsyncProvider = 'drizzleProvider'

export const drizzleProvider = [
   {
      provide: DrizzleAsyncProvider,
      useFactory: async () => {
         const client = postgres(process.env.DATABASE_URL)
         const db = drizzle(client, { schema })
         return db
      },
      exports: [DrizzleAsyncProvider],
   },
]

```

# apps\backend\src\drizzle\drizzle.module.ts

```ts
import { Module } from '@nestjs/common';
import { drizzleProvider } from './drizzle.provider';

@Module({
  providers: [...drizzleProvider],
})
export class DrizzleModule {}

```

# apps\backend\src\encryption\encryption.service.ts

```ts
import { Injectable } from '@nestjs/common'
import * as crypto from 'crypto'

@Injectable()
export class EncryptionService {
   private masterKey: Buffer // This should be securely loaded

   constructor() {
      const masterKeyHex = process.env.MASTER_KEY
      this.masterKey = Buffer.from(masterKeyHex, 'hex')
   }

   deriveKey(userSpecificData: string) {
      const salt = crypto.createHash('sha256').update(userSpecificData).digest()
      return crypto.pbkdf2Sync(this.masterKey, salt, 10000, 32, 'sha256')
   }

   encrypt(text: string, userSpecificData: string): string {
      const key = this.deriveKey(userSpecificData)
      const iv = crypto.randomBytes(16)
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv)
      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return iv.toString('hex') + ':' + encrypted
   }

   decrypt(encryptedText: string, userSpecificData: string): string {
      const textParts = encryptedText.split(':')
      const iv = Buffer.from(textParts[0], 'hex')
      const encrypted = textParts[1]
      const key = this.deriveKey(userSpecificData)
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)
      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}

```

# apps\backend\src\encryption\encryption.module.ts

```ts
import { Module } from '@nestjs/common'
import { EncryptionService } from './encryption.service'

@Module({
   providers: [EncryptionService],
   exports: [EncryptionService], // Export so it can be imported by other modules
})
export class EncryptionModule {}

```

# apps\backend\src\auth\auth.service.ts

```ts
import { Injectable } from '@nestjs/common'
import { UserService } from 'src/user/user.service'
import * as crypto from 'crypto'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { InsertUser, SelectUser } from 'src/drizzle/schema'

@Injectable()
export class AuthService {
   constructor(private userService: UserService) {}

   async validateTelegramUser(telegramAuthData: TelegramAuthData): Promise<SelectUser> {
      let user = await this.userService.findByTelegramId(telegramAuthData.id)
      if (!user) {
         // Create a new user if it doesn't exist
         const insertUserData: InsertUser = {}
         user = await this.userService.create(insertUserData, {
            provider: 'telegram',
            providerId: telegramAuthData.id.toString(),
         })
      }
      return user
   }

   async encryptPrivateKey(privateKey: string): Promise<string> {
      const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let encrypted = cipher.update(privateKey, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return encrypted
   }

   async decryptPrivateKey(encryptedPrivateKey: string): Promise<string> {
      const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let decrypted = decipher.update(encryptedPrivateKey, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}

```

# apps\backend\src\auth\auth.module.ts

```ts
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { PassportModule } from '@nestjs/passport'
import { JwtModule } from '@nestjs/jwt'
import { JwtStrategy } from './strategies/jwt.tstrategy'
import { TelegramStrategy } from './strategies/telegram.strategy'
import { UserModule } from 'src/user/user.module'
import { SessionSerializer } from './strategies/SessionSerializer'

@Module({
   imports: [
      PassportModule,
      JwtModule.register({
         secret: process.env.JWT_SECRET,
         signOptions: { expiresIn: '1d' },
      }),
      UserModule,
   ],
   providers: [AuthService, JwtStrategy, TelegramStrategy, SessionSerializer],
   controllers: [AuthController],
})
export class AuthModule {}

```

# apps\backend\src\auth\auth.controller.ts

```ts
import { Controller, UseGuards, Request, Post } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthGuard } from '@nestjs/passport'
import { JwtService } from '@nestjs/jwt'
import { UserService } from 'src/user/user.service'
import { TelegramGuard } from './utils/telegram.guard'

@Controller('auth')
export class AuthController {
   constructor(
      private authService: AuthService,
      private jwtService: JwtService,
      private userService: UserService,
   ) {}

   @UseGuards(TelegramGuard)
   @Post('loginWithTelegram')
   async loginWithTelegram(@Request() req) {
      return req.user
   }

   @UseGuards(AuthGuard('local'))
   @Post('login')
   async login(@Request() req) {
      const user = req.user
      const payload = { username: user.username, sub: user.userId }
      return {
         access_token: this.jwtService.sign(payload),
      }
   }

   // @Post('store-key')
   // async storePrivateKey(@Body() body: any, @Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.authService.encryptPrivateKey(body.privateKey)
   //    await this.userService.storeEncryptedPrivateKey(userId, encryptedPrivateKey)
   //    return { message: 'Private key stored successfully' }
   // }

   // @Get('retrieve-key')
   // async retrievePrivateKey(@Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.userService.getEncryptedPrivateKey(userId)
   //    if (!encryptedPrivateKey) {
   //       return { message: 'Private key not found' }
   //    }
   //    const privateKey = await this.authService.decryptPrivateKey(encryptedPrivateKey)
   //    return { privateKey }
   // }
}

```

# apps\frontend\src\routes\login\+page.svelte

```svelte
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
</script>

<div class="w-screen h-screen flex">
	<div class="hidden w-full h-full bg-[#005952] md:block"></div>
	<div class="h-screen w-full bg-black relative">
		<div class="h-screen w-full overflow-hidden absolute">
			<img src="login/dark_pattern.jpg" alt="dark_pattern" class="w-full h-screen object-cover" />
		</div>
		<div class="absolute w-full text-center top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
			<h1 class="text-4xl text-white font-bold manrope">Sniperoo</h1>
			<h2 class="text-2xl text-green-600 mt-4 font-bold manrope">Welcome to Sniperoo</h2>
			<p class="text-base mt-4 text-white manrope">The Automated Trading Platform</p>
			<div class="mt-12"><TelegramLoginWidget /></div>
			<div class="mt-6 flex items-center justify-center">
				<img src="login/login_with_google.png" alt="login_with_google" class="w-50" />
			</div>
			<p class="text-white text-xs mt-8 manrope">
				By proceeding, you agree to these <br />
				<a href="/terms_and_conditions" class="underline font-bold">Terms and Conditions.</a>
			</p>
		</div>
	</div>
</div>

```

# apps\frontend\src\routes\dashboard\+page.svelte

```svelte
<script lang="ts">
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import axios from 'axios';
	import type { BuyTokenDto } from 'shared-types/src/dto/BuyToken.dto';
	import type { SellTokenDto } from 'shared-types/src/dto/SellToken.dto';

	async function buyTokens() {
		const buyTokenDto: BuyTokenDto = {
			solAmountIn: '20000000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump',
			autoSell: {
				userId: 6,
				walletId: 1,
				solAmountProfitTrigger: '23000000',
				solAmountLossTrigger: '17000000',
				slippage: '15',
				tokenAddressToSell: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
			}
		};
		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/buy-token', buyTokenDto, {
			withCredentials: true
		});
	}

	async function sellTokens() {
		const sellTokenDto: SellTokenDto = {
			tokenAmountIn: '3574930000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
		};

		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/sell-token', sellTokenDto, {
			withCredentials: true
		});
	}
</script>

<h1>WELCOME TO THE DASHBOARD</h1>

<button on:click={buyTokens}>Buy Tokens!!!</button>

<button on:click={sellTokens}>Sell Tokens!!!</button>

```

# apps\frontend\src\routes\dashboard\+layout.svelte

```svelte
<script lang="ts">
	import BottomNavigation from '$components/common/BottomNavigation.svelte';
	import Navbar from '$components/common/Navbar.svelte';
	import '../../app.css';
	export let data;

	$: console.log(data);
</script>

<main class="px-4 pb-40">
	<Navbar />
	<slot />
</main>
<BottomNavigation />

```

# apps\frontend\src\routes\dashboard\+layout.server.ts

```ts
export async function load({ locals }) {
	return {
		user: locals.user
	};
}

```

# apps\frontend\src\components\trade\TradeForm.svelte

```svelte
<script>
	import BuyTradeForm from '$components/trade/BuyTradeForm.svelte';
	import { Tabs, TabItem } from 'flowbite-svelte';
	import { Input, Label, Button } from 'flowbite-svelte';
	import { SearchOutline, FileCopyOutline } from 'flowbite-svelte-icons';
	import { AccordionItem, Accordion, Modal } from 'flowbite-svelte';
	import { Checkbox } from 'flowbite-svelte';
	import {
		Table,
		TableBody,
		TableBodyCell,
		TableBodyRow,
		TableHead,
		TableHeadCell,
		TableSearch
	} from 'flowbite-svelte';
	import { Toast } from 'flowbite-svelte';

	const wallets = [
		{
			name: 'Main',
			address: '9brqEvGE8Rn5tDMzuJD76AteLx8sYppxAKxK6MXeNvob',
			solBalance: 1.3,
			checked: true,
			tokenHoldings: [
				{
					name: 'WIF',
					address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm',
					balance: '2131235.5'
				},
				{
					name: 'USDC',
					address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
					balance: 1.3
				}
			],
			modalOpen: false,
			searchTerm: ''
		},
		{
			name: 'Secondary',
			address: '7qGfM5cTJn2a9pDNhtLNoWnXF3hJ2aSb317esSoLLtM4',
			solBalance: 0.5,
			checked: false,
			tokenHoldings: [
				{
					name: 'WIF',
					address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm',
					balance: 0.5
				},
				{
					name: 'USDC',
					address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
					balance: 2.1
				}
			],
			modalOpen: false,
			searchTerm: ''
		},
		{
			name: 'Ape',
			address: '7EoEruhTPr6dVa4NHby5moPAyp8hNaXoV8KVddN5gWMa',
			solBalance: 0,
			checked: false,
			tokenHoldings: [
				{
					name: 'WIF',
					address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm',
					balance: 0
				},
				{
					name: 'USDC',
					address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
					balance: 0
				}
			],
			modalOpen: false,
			searchTerm: ''
		}
	];

	let slippageModal = false;
	let slippage = 5;

	$: filteredTokenHoldings = (/** @type {{ tokenHoldings: any[]; searchTerm: string; }} */ wallet) => {
		return wallet.tokenHoldings.filter((token) => token.name.toLowerCase().includes(wallet.searchTerm.toLowerCase()));
	};

	let showToast = false;
	let toastMessage = '';

	/**
	 * @param {string} text
	 */
	async function copyToClipboard(text) {
		if (navigator.clipboard) {
			try {
				await navigator.clipboard.writeText(text);
				toastMessage = 'Copied to clipboard';
				showToast = true;
				setTimeout(() => {
					showToast = false;
				}, 3000);
				console.log('Text copied to clipboard using Clipboard API');
			} catch (err) {
				console.error('Failed to copy text using Clipboard API: ', err);
			}
		} else {
			// Fallback for older browsers
			fallbackCopyTextToClipboard(text);
		}
	}

	// Fallback function using execCommand
	/**
	 * @param {string} text
	 */
	function fallbackCopyTextToClipboard(text) {
		const textArea = document.createElement('textarea');
		textArea.value = text;
		document.body.appendChild(textArea);
		textArea.focus();
		textArea.select();
		try {
			document.execCommand('copy');
			toastMessage = 'Copied to clipboard';
			showToast = true;
			setTimeout(() => {
				showToast = false;
			}, 3000);
			console.log('Text copied to clipboard using execCommand');
		} catch (err) {
			console.error('Failed to copy text using execCommand: ', err);
		}
		document.body.removeChild(textArea);
	}
</script>

<section class="bg-gray-800 quicksand rounded-lg p-4">
	<div class="flex justify-between items-center mb-4">
		<h2 class="text-2xl pl-5 text-white font-bold text-center">Trade</h2>
		<button class="bg-gray-600 text-white text-sm px-2 rounded-lg font-semibold" on:click={() => (slippageModal = true)}
			>Slippage: {slippage}%</button
		>
	</div>

	<Accordion>
		<AccordionItem paddingDefault="p-0" class="h-12 rounded-lg px-5">
			<span slot="header" class="text-white font-bold">Wallets</span>
			{#each wallets as wallet}
				<div class="flex p-2 justify-between w-full">
					<Checkbox name="wallets" bind:checked={wallet.checked} class="p-1 text-[#35d0de] focus:ring-0" />
					<div class="flex w-full items-center justify-between">
						<div class="flex items-center">
							<p class="text-white font-bold">
								{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}..` : wallet.name}
							</p>

							<p class="ml-1 flex items-center">
								(<button on:click={() => copyToClipboard(wallet.address)} class="">
									<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
								</button>{wallet.address.length > 4 ? `${wallet.address.substring(0, 4)}..` : wallet.address})
							</p>

							<p class="text-white font-bold text-sm ml-2">{parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
						</div>
					</div>
					<button
						class=" px-2 py-1 bg-[#35d0de] text-sm rounded-lg text-black font-bold"
						on:click={() => (wallet.modalOpen = true)}>View</button
					>
				</div>
				<Modal title="Token Holdings" bind:open={wallet.modalOpen} autoclose outsideclose={true}>
					<div class="flex items-center justify-center">
						<p>Wallet:</p>
						<p class="text-white ml-2 font-bold">
							{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}...` : wallet.name}
						</p>
						<p class="ml-1 flex items-center text-gray-400">
							(<button on:click={() => copyToClipboard(wallet.address)} class="">
								<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
							</button>{wallet.address.length > 5 ? `${wallet.address.substring(0, 5)}...` : wallet.address})
						</p>
						<p class="text-white font-bold ml-2">- {parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
					</div>
					<TableSearch placeholder="Search by token name" hoverable={true} bind:inputValue={wallet.searchTerm}>
						<TableHead>
							<TableHeadCell>Token</TableHeadCell>
							<TableHeadCell>Balance</TableHeadCell>
						</TableHead>
						<TableBody tableBodyClass="divide-y">
							{#each filteredTokenHoldings(wallet) as token}
								<TableBodyRow>
									<TableBodyCell class="pr-0">
										<div class="text-white flex items-center">
											<p class="font-bold">{token.name}</p>
											<span class="flex ml-1 text-gray-400 items-center">
												(<button on:click={() => copyToClipboard(wallet.address)} class="">
													<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
												</button>{token.address.length > 5 ? `${token.address.substring(0, 5)}...` : token.address})
											</span>
										</div>
									</TableBodyCell>
									<TableBodyCell>{token.balance}</TableBodyCell>
								</TableBodyRow>
							{/each}
						</TableBody>
					</TableSearch>
				</Modal>
			{/each}
		</AccordionItem>
	</Accordion>
	<form class="mb-6 mt-4">
		<Input id="search" class="!bg-gray-700" placeholder="Paste token address" size="lg">
			<SearchOutline slot="left" class="w-6 h-6 text-gray-500  dark:text-gray-400" />
		</Input>
	</form>
	<Tabs tabStyle="full" contentClass="rounded-lg mt-4 bg-gray-800" defaultClass="flex bg-gray-700 rounded-lg quicksand">
		<TabItem
			activeClasses="bg-[#008F00]"
			inactiveClasses="bg-gray-700"
			defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
			class="w-full"
			open
		>
			<span slot="title">Buy</span>
			<BuyTradeForm />
		</TabItem>
		<TabItem
			activeClasses="bg-[#B30000]"
			inactiveClasses="bg-gray-700"
			defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
			class="w-full"
		>
			<span slot="title">Sell</span>
			<p class="text-sm text-gray-500 dark:text-gray-400">
				<b>Dashboard:</b>
				Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna
				aliqua.
			</p>
		</TabItem>
	</Tabs>
</section>

{#if showToast}
	<Toast class="!bg-white" position="top-left" on:close={() => (showToast = false)}>
		<p class="!text-black !font-bold quicksand !text-xl">{toastMessage}</p>
	</Toast>
{/if}

<Modal title="Swap Slippage Tolerance" bind:open={slippageModal} autoclose>
	<div class="flex items-center justify-between">
		<div class="w-3/4">
			<p>Custom slippage</p>
		</div>
		<div class="w-1/4">
			<Input type="number" id="slppage" size="sm" class="text-right pe-6" required bind:value={slippage}>
				<p slot="right">%</p>
			</Input>
		</div>
	</div>
	<Button class="w-full !bg-[#35d0de] text-black font-bold">Save</Button>
</Modal>

```

# apps\frontend\src\components\trade\BuyTradeForm.svelte

```svelte
<script lang="ts">
	import { Label, Input, InputAddon, ButtonGroup, Toggle, TabItem, Tabs } from 'flowbite-svelte';
	import {
		Table,
		TableBody,
		TableBodyCell,
		TableBodyRow,
		TableHead,
		TableHeadCell,
		TableSearch
	} from 'flowbite-svelte';
	import { ArrowUpDown } from 'lucide-svelte';
	import { Button, Modal } from 'flowbite-svelte';
	let autoSellChecked = false;
	let simpleSell = {
		profitPercentage: 30,
		lossPercentage: 30
	};
	let gradualSell = {
		lossPercentage: 5,
		profitTargets: [
			{ multiplier: 1.1, sellPercentage: 20 },
			{ multiplier: 1.3, sellPercentage: 30 },
			{ multiplier: 1.5, sellPercentage: 50 }
		]
	};
	let inputSolana = 0;
	let oneSolPriceInUsd = 142.38;
	let oneSecondaryTokenInSol = 0.01112;
	$: outputSecondaryToken = inputSolana / oneSecondaryTokenInSol;

	let solInputPresets = [0.1, 0.5, 1, 10];

	/**
	 * @param {number} value
	 * @param {string} placeholder
	 */
	function formatValue(value: number, placeholder: string) {
		return value === 0 ? undefined : value;
	}

	function addProfitTarget() {
		gradualSell.profitTargets = [...gradualSell.profitTargets, { multiplier: 0, sellPercentage: 0 }];
	}

	/**
	 * @param {number} index
	 */
	function removeProfitTarget(index: number) {
		gradualSell.profitTargets = gradualSell.profitTargets.filter((_, i) => i !== index);
	}

	/**
	 * @param {number} initialInvestment
	 * @param {number} initialTokens
	 * @param {any[]} targets
	 * @param {number} stopLossPercentage
	 */
	function calculateProjectedNetPLForTargets(
		initialInvestment: number,
		initialTokens: number,
		targets: any[],
		stopLossPercentage: number
	) {
		if (initialInvestment === 0) return [];
		// Calculate the initial price per token
		const initialPrice = initialInvestment / initialTokens;

		console.log('initialPrice', initialPrice);
		console.log('initialInvestment', initialInvestment);

		// Initialize remaining investment to the initial investment
		let remainingInvestment = initialTokens;
		console.log('remainingInvestment', remainingInvestment);

		// Array to store the projected net P/L for each target
		/**
		 * @type {{ targetPrice: string; sellPercentage: any; projectedNetPL: string; }[]}
		 */
		const projectedNetPLs: {
			targetPrice: string;
			sellPercentage: any;
			projectedNetPL: string;
		}[] = [];

		let accumulativeProceedsFromSale = 0;

		// Iterate over each target
		targets.forEach((target: { multiplier: any; sellPercentage: any }, index) => {
			const { multiplier, sellPercentage } = target;

			// Calculate the target price
			const targetPrice = initialPrice * multiplier;

			// Calculate the amount to be sold at this target price
			const amountSold = initialTokens * (sellPercentage / 100);

			// Calculate the proceeds from the sale at the target price
			const proceedsFromSale = amountSold * targetPrice;

			accumulativeProceedsFromSale += proceedsFromSale;

			// Update the remaining investment
			remainingInvestment -= amountSold;

			// Calculate the stop-loss price
			const stopLoss = initialPrice * (1 - stopLossPercentage / 100);

			// Calculate the value of the remaining investment if sold at the stop-loss price
			const proceedsFromStopLoss = remainingInvestment * stopLoss;

			// Calculate the total proceeds
			const totalProceeds = accumulativeProceedsFromSale + proceedsFromStopLoss;

			// Calculate the projected net profit/loss
			const projectedNetPL = totalProceeds - initialInvestment;

			//log everything
			console.log('----------------------');
			console.log('----------------------');
			console.log('targetPrice', targetPrice);
			console.log('sellPercentage', sellPercentage);
			console.log('projectedNetPL', projectedNetPL);
			console.log('amountSold', amountSold);
			console.log('proceedsFromSale', proceedsFromSale);
			console.log('remainingInvestment', remainingInvestment);
			console.log('stopLoss', stopLoss);
			console.log('proceedsFromStopLoss', proceedsFromStopLoss);
			console.log('totalProceeds', totalProceeds);
			console.log('----------------------');
			console.log('----------------------');
			console.log();
			console.log();

			// Store the projected net P/L for this target
			projectedNetPLs.push({
				targetPrice: targetPrice.toFixed(2),
				sellPercentage,
				projectedNetPL: projectedNetPL.toFixed(2)
			});
		});

		return projectedNetPLs;
	}

	/**
	 * @type {any[]}
	 */
	let results = calculateProjectedNetPLForTargets(
		inputSolana,
		outputSecondaryToken,
		gradualSell.profitTargets,
		gradualSell.lossPercentage
	);

	/**
	 * @param {any} investment
	 * @param {any[]} targets
	 */
	// function calculateMaxProfit(investment, targets) {
	// 	return targets.reduce(
	// 		(/** @type {any} */ total, /** @type {{ multiplier: any; sellPercentage: any; }} */ target) => {
	// 			return total + calculateProjectedNetPL(investment, target.multiplier, target.sellPercentage);
	// 		},
	// 		0
	// 	);
	// }
	function onInputSolanaChange(e: Event) {
		const target = e.target as HTMLTextAreaElement;
		inputSolana = parseFloat(target.value) || 0;
		console.log(inputSolana);
		results = calculateProjectedNetPLForTargets(
			inputSolana,
			inputSolana / oneSecondaryTokenInSol,
			gradualSell.profitTargets,
			gradualSell.lossPercentage
		);
	}
</script>

<div class="w-full">
	<div>
		<div class="flex justify-between items-center mb-2">
			<Label for="input-addon" class="font-bold">You're Paying</Label>
		</div>

		<ButtonGroup class="w-full">
			<InputAddon>
				<div class="w-6 h-6">
					<img src="/solana-logo.png" class="rounded-full object-cover" alt="Solana" />
				</div>
			</InputAddon>
			<InputAddon class="pl-0 quicksand !text-white !font-bold">SOL</InputAddon>
			<div class="bg-gray-700">
				<Input
					id="input-addon"
					type="number"
					class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
					placeholder="0.00"
					value={formatValue(inputSolana, '0.00')}
					on:input={onInputSolanaChange}
				/>
				<p class="text-gray-400 pr-2.5 -mt-2 mb-1 text-xs font-semibold text-right">
					≈ <span class="">${parseFloat((inputSolana * oneSolPriceInUsd).toFixed(2))}</span>
				</p>
			</div>

			<Button class="!bg-[#35d0de] !text-black font-bold">MAX</Button>
		</ButtonGroup>
		<div class="flex justify-between mt-3">
			{#each solInputPresets as preset}
				<button
					class="!bg-gray-700 w-full mr-2 last-of-type:mr-0 py-1 rounded-lg text-base !text-white !font-bold"
					on:click={() => (inputSolana = preset)}>{preset} SOL</button
				>
			{/each}
		</div>
	</div>
	<ArrowUpDown class="w-6 h-6 mx-auto mt-4 -mb-2 text-white" />
	<div>
		<Label for="input-addon" class="mb-2 font-bold">To Receive</Label>
		<ButtonGroup class="w-full">
			<InputAddon>
				<div class="w-6 h-6">
					<img src="/dogwifhat.jpg" class="rounded-full object-cover" alt="Dogo" />
				</div>
			</InputAddon>
			<InputAddon class="pl-0 quicksand !text-white !font-bold">$WIF</InputAddon>
			<Input
				id="input-addon"
				type="number"
				class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
				placeholder=""
				value={formatValue(outputSecondaryToken, '')}
				readonly
			/>
		</ButtonGroup>
		<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
			1 $WIF ≈ {parseFloat(oneSecondaryTokenInSol.toFixed(5))} SOL
		</p>
	</div>
	<hr class="my-4 border-gray-600" />
	<div class="flex justify-between mt-4 bg-gray-700 p-2 rounded-lg">
		<p class="text-white font-bold">Enable Auto Sell</p>
		<Toggle
			classDiv="peer-focus:ring-0 {autoSellChecked ? '!bg-[#35d0de]' : '!bg-gray-500'}"
			bind:checked={autoSellChecked}
		/>
	</div>
	{#if autoSellChecked}
		<Tabs contentClass="mt-4" defaultClass="flex" tabStyle="underline">
			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				open
				title="Simple Auto Sell"
			>
				<div class="flex">
					<div class="mr-2">
						<Label for="first_name" class="mb-2">Profit Percentage</Label>
						<Input
							type="number"
							id="slppage"
							size="sm"
							class="text-right"
							required
							bind:value={simpleSell.profitPercentage}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
							Profit: <span class="text-white">{(inputSolana * simpleSell.profitPercentage) / 100} SOL</span>
						</p>
					</div>
					<div class="ml-2">
						<Label for="last_name" class="mb-2">Loss Percentage</Label>
						<Input
							type="number"
							id="slppage"
							size="sm"
							class="text-right"
							required
							bind:value={simpleSell.lossPercentage}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
							Loss: <span class="text-white">{(inputSolana * simpleSell.lossPercentage) / 100} SOL</span>
						</p>
					</div>
				</div>
			</TabItem>
			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				title="Gradual Auto Sell"
			>
				<div class="mb-2">
					<Label for="loss_percentage" class="mb-2">Loss Percentage</Label>
					<Input
						type="number"
						id="loss_percentage"
						size="sm"
						class="text-right"
						required
						bind:value={gradualSell.lossPercentage}
					>
						<p slot="right">%</p>
					</Input>
					<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
						Loss: <span class="text-white">{(inputSolana * gradualSell.lossPercentage) / 100} SOL</span>
					</p>
				</div>

				<p class="mb-2 text-center font-bold text-white">Profit Targets</p>

				<Table>
					<TableHead>
						<TableHeadCell class="px-0 w-1/3 text-center">Multiplier</TableHeadCell>
						<TableHeadCell class="px-0 w-1/3 text-center">Sell %</TableHeadCell>
						<TableHeadCell class="px-0 w-1/3 text-center">Projected Net P/L</TableHeadCell>
						<TableHeadCell class="p-0 text-center"></TableHeadCell>
					</TableHead>
					<TableBody tableBodyClass="divide-y">
						{#each gradualSell.profitTargets as target, index}
							<TableBodyRow>
								<TableBodyCell class="px-2">
									<Input type="number" size="sm" class="text-right pe-5" required bind:value={target.multiplier}>
										<p slot="right">x</p>
									</Input>
								</TableBodyCell>
								<TableBodyCell class="px-2">
									<Input type="number" size="sm" class="text-right pe-7" required bind:value={target.sellPercentage}>
										<p slot="right">%</p>
									</Input>
								</TableBodyCell>

								<TableBodyCell class="px-2">
									<p class="text-white font-bold text-center">
										{parseFloat(results[index].projectedNetPL).toFixed(4)} SOL
									</p>
								</TableBodyCell>
								<TableBodyCell class="px-2">
									<Button color="red" class="px-2" size="sm" on:click={() => removeProfitTarget(index)}>
										<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
											<path
												fill-rule="evenodd"
												d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
												clip-rule="evenodd"
											></path>
										</svg>
									</Button>
								</TableBodyCell>
							</TableBodyRow>
						{/each}
					</TableBody>
				</Table>
				<div class="mt-2 flex justify-center">
					<Button class="!bg-[#008F00] text-3xl !px-3.5 !py-1" on:click={addProfitTarget}>+</Button>
				</div>
			</TabItem>
		</Tabs>
	{/if}
	<Button class="w-full !bg-[#35d0de] text-black text-lg mt-6 font-bold">Place Order</Button>
</div>

```

# apps\frontend\src\components\common\Navbar.svelte

```svelte
<script>
	import {
		Navbar,
		NavBrand,
		NavLi,
		NavUl,
		NavHamburger,
		Avatar,
		Dropdown,
		DropdownItem,
		DropdownHeader,
		DropdownDivider
	} from 'flowbite-svelte';
	import { page } from '$app/stores';
	$: activeUrl = $page.url.pathname;
</script>

<Navbar color="none" class="quicksand px-8 py-4 md:p-4">
	<NavBrand href="/">
		<span class="self-center logo whitespace-nowrap text-xl font-semibold audiowide dark:text-white">Sniperoo</span>
	</NavBrand>
	<div class="flex items-center md:order-2">
		<Avatar
			class="md:!w-12 md:!h-12 !bg-[#36394C] p-1 border border-[#e0e0e0] hover:cursor-pointer hover:brightness-75"
			id="avatar-menu"
			src="/dashboard/userIcon.png"
		/>
		<!-- <NavHamburger class1="w-full md:flex md:w-auto md:order-1" /> -->
	</div>
	<Dropdown placement="bottom" triggeredBy="#avatar-menu">
		<DropdownHeader>
			<span class="block text-sm">@britishculottes</span>
		</DropdownHeader>
		<DropdownItem>Referral Dashboard</DropdownItem>
		<DropdownItem>Transactions</DropdownItem>
		<DropdownItem>Settings</DropdownItem>
		<DropdownDivider />
		<DropdownItem>Sign out</DropdownItem>
	</Dropdown>
	<NavUl {activeUrl} activeClass="active">
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/trade">Trade</NavLi>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/sniper"
			>Sniper</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/copy-trade"
			>Copy Trade</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/wallets"
			>Wallets</NavLi
		>
		<!-- <NavLi class="font-bold navLi text-lg !px-4 !py-2 hover:!bg-slate-700" href="/contact">Contact</NavLi> -->
	</NavUl>
</Navbar>

<style>
	.logo {
		font-family: 'Audiowide', cursive;
		text-align: center;
		color: #00ffff;
		letter-spacing: 4px;
		text-shadow:
			0 0 5px #00ffff,
			0 0 10px #00ffff;
		animation: subtle-pulse 4s ease-in-out infinite;
		text-transform: uppercase;
	}

	:global(.navLi) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	:global(.active) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	@keyframes subtle-pulse {
		0%,
		100% {
			text-shadow:
				0 0 5px #00ffff,
				0 0 10px #00ffff;
		}
		50% {
			text-shadow:
				0 0 10px #00ffff,
				0 0 20px #00ffff;
		}
	}
</style>

```

# apps\frontend\src\components\common\BottomNavigation.svelte

```svelte
<script>
	import { Wallet, CopyPlus, Crosshair, ArrowLeftRight } from 'lucide-svelte';
	import { page } from '$app/stores';
</script>

<nav class="md:hidden text-gray-400 fixed quicksand w-screen bottom-0 bg-gray-800 flex">
	<div
		class="w-full h-full flex flex-col py-4 items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/trade'}
	>
		<ArrowLeftRight size={20} />
		<a href="/dashboard/trade">Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/sniper'}
	>
		<Crosshair size={20} />
		<a href="/dashboard/sniper">Sniper</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/copy-trade'}
	>
		<CopyPlus size={20} />
		<a href="/dashboard/copy-trade">Copy Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/wallets'}
	>
		<Wallet size={20} />
		<a href="/dashboard/wallets">Wallets</a>
	</div>
</nav>

```

# apps\backend\src\user\dto\SellToken.dto.ts

```ts
import { SellTokenDto as BaseSellTokenDto } from 'shared-types/src/dto/SellToken.dto' // Adjust the path as necessary
import { IsNotEmpty, IsNumber, IsString } from 'class-validator'

export class SellTokenDto implements BaseSellTokenDto {
   @IsNotEmpty()
   @IsString()
   walletAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAmountIn: string

   @IsNotEmpty()
   @IsNumber()
   slippageInPercentage: number

   @IsNotEmpty()
   @IsNumber()
   prioritizationFeeLamports: number | 'auto'
}

```

# apps\backend\src\user\dto\BuyToken.dto.ts

```ts
import { BuyTokenDto as BaseBuyTokenDto } from 'shared-types/src/dto/BuyToken.dto' // Adjust the path as necessary
import { InsertAutoSell } from 'shared-types/src/drizzle.types' // Adjust the path as necessary
import { IsNotEmpty, IsNumber, IsOptional, IsString, ValidateNested } from 'class-validator'

export class BuyTokenDto implements BaseBuyTokenDto {
   @IsNotEmpty()
   @IsString()
   walletAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAddress: string

   @IsNotEmpty()
   @IsString()
   solAmountIn: string

   @IsNotEmpty()
   @IsNumber()
   slippageInPercentage: number

   @IsNotEmpty()
   @IsNumber()
   prioritizationFeeLamports: number | 'auto'

   @IsOptional()
   @ValidateNested()
   autoSell?: Omit<InsertAutoSell, 'tokenAmountToSell'>
}

```

# apps\backend\src\blockchain\solana\solana.service.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { BlockchainInterface } from 'src/common/interfaces/blockchain.interface'
import {
   Connection,
   PublicKey,
   Keypair,
   TransactionInstruction,
   AddressLookupTableAccount,
   TransactionMessage,
   VersionedTransaction,
   SystemProgram,
   TokenBalance,
} from '@solana/web3.js'
import { createUmi } from '@metaplex-foundation/umi-bundle-defaults'
import { Umi } from '@metaplex-foundation/umi'
import * as bs58 from 'bs58'
import axios from 'axios'
import { transactionSenderAndConfirmationWaiter } from 'src/common/helpers/transactionSender'
import { getSignature } from 'src/common/helpers/getSignature'
import * as fs from 'fs'

export class SolanaService implements BlockchainInterface {
   public quickNodeConnection: Connection = new Connection(
      'https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/',
   )
   public defaultSolanaConnection: Connection = new Connection('https://api.mainnet-beta.solana.com/')
   public umi: Umi = createUmi('https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/')
   public juputerSwapURL: string = 'https://quote-api.jup.ag/v6'
   public jupiterPriceURL: string = 'https:///price.jup.ag/v6'

   public feeReceiverData = { feePercentage: process.env.FEE_PERCENTAGE, feeReceiver: new PublicKey(process.env.FEE_ACCOUNT_ADDRESS) }

   public knownAddresses = {
      WSOL: 'So11111111111111111111111111111111111111112',
   }

   connect() {
      // Implementation details
   }

   createNewWallet() {
      return Keypair.generate()
   }

   base58ToKeypair(base58PrivateKey: string): Keypair {
      try {
         const privateKeyBuffer = bs58.decode(base58PrivateKey)
         return Keypair.fromSecretKey(privateKeyBuffer)
      } catch (error) {
         throw new Error('Invalid base58 private key.')
      }
   }

   privateKeyToBase58(privateKey: Uint8Array): string {
      return bs58.encode(privateKey)
   }

   async getBalance(address: string): Promise<number> {
      const publicKey = new PublicKey(address)
      return this.quickNodeConnection.getBalance(publicKey)
   }

   async sendTransaction(transactionDetails: any): Promise<any> {
      // Implementation details
   }

   async makeJupiterSwapTransaction(
      inputMint: string,
      outputMint: string,
      inputAmount: number,
      slippageBps: number,
      wallet: Keypair,
      prioritizationFeeLamports: number | 'auto',
   ): Promise<any> {
      console.time('fetchJupiterData')
      const quoteResponse = await axios.get(`${this.juputerSwapURL}/quote`, {
         params: {
            inputMint,
            outputMint,
            amount: inputAmount,
            slippageBps,
         },
      })

      console.log('Quote response: ', quoteResponse.data)

      const instructions = await axios.post(
         `${this.juputerSwapURL}/swap-instructions`,
         {
            userPublicKey: wallet.publicKey.toBase58(),
            quoteResponse: quoteResponse.data,
            dynamicComputeUnitLimit: true,
            prioritizationFeeLamports: prioritizationFeeLamports,
         },
         {
            headers: {
               'Content-Type': 'application/json',
            },
         },
      )
      console.timeEnd('fetchJupiterData')

      const {
         tokenLedgerInstruction, // If you are using `useTokenLedger = true`.
         computeBudgetInstructions, // The necessary instructions to setup the compute budget.
         setupInstructions, // Setup missing ATA for the users.
         swapInstruction: swapInstructionPayload, // The actual swap instruction.
         cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.
         addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
      } = instructions.data

      const deserializeInstruction = (instruction) => {
         return new TransactionInstruction({
            programId: new PublicKey(instruction.programId),
            keys: instruction.accounts.map((key) => ({
               pubkey: new PublicKey(key.pubkey),
               isSigner: key.isSigner,
               isWritable: key.isWritable,
            })),
            data: Buffer.from(instruction.data, 'base64'),
         })
      }

      const getAddressLookupTableAccounts = async (keys: string[]): Promise<AddressLookupTableAccount[]> => {
         const addressLookupTableAccountInfos = await this.quickNodeConnection.getMultipleAccountsInfo(keys.map((key) => new PublicKey(key)))

         return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
            const addressLookupTableAddress = keys[index]
            if (accountInfo) {
               const addressLookupTableAccount = new AddressLookupTableAccount({
                  key: new PublicKey(addressLookupTableAddress),
                  state: AddressLookupTableAccount.deserialize(accountInfo.data),
               })
               acc.push(addressLookupTableAccount)
            }

            return acc
         }, new Array<AddressLookupTableAccount>())
      }

      const addressLookupTableAccounts: AddressLookupTableAccount[] = []
      addressLookupTableAccounts.push(...(await getAddressLookupTableAccounts(addressLookupTableAddresses)))

      const blockhash = await this.quickNodeConnection.getLatestBlockhash()

      const allInstructions = [
         ...computeBudgetInstructions.map(deserializeInstruction),
         ...setupInstructions.map(deserializeInstruction),
         deserializeInstruction(swapInstructionPayload),
         deserializeInstruction(cleanupInstruction),
      ]

      let feeAmountLamports

      if (inputMint === this.knownAddresses.WSOL) {
         // Calculate 0.8% of the input amount
         feeAmountLamports = Math.floor(inputAmount * 0.008)
      } else if (outputMint === this.knownAddresses.WSOL) {
         // Extract output amount from quoteResponse data (assuming it is available)
         const outputAmount = quoteResponse.data.outAmount // Adjust this based on actual data structure
         feeAmountLamports = Math.floor(outputAmount * 0.008)
      }

      const feeTransferInstruction = SystemProgram.transfer({
         fromPubkey: wallet.publicKey,
         toPubkey: this.feeReceiverData.feeReceiver,
         lamports: feeAmountLamports,
      })
      allInstructions.push(feeTransferInstruction)

      const messageV0 = new TransactionMessage({
         payerKey: wallet.publicKey,
         recentBlockhash: blockhash.blockhash,
         instructions: allInstructions,
      }).compileToV0Message(addressLookupTableAccounts)

      const transaction = new VersionedTransaction(messageV0)
      transaction.sign([wallet])

      const signature = getSignature(transaction)

      // console.time('simulateTransaction')
      // const { value: simulatedTransactionResponse } = await this.quickNodeConnection.simulateTransaction(transaction, {
      //    replaceRecentBlockhash: true,
      //    commitment: 'processed',
      // })
      // const { err, logs } = simulatedTransactionResponse

      // if (err) {
      //    // Simulation error, we can check the logs for more details
      //    // If you are getting an invalid account error, make sure that you have the input mint account to actually swap from.
      //    console.error('Simulation Error:')
      //    console.error({ err, logs })
      //    return
      // }
      // console.timeEnd('simulateTransaction')

      console.log('Current time: ', new Date().toLocaleTimeString())

      const transactionResponse = await transactionSenderAndConfirmationWaiter({
         connection: this.quickNodeConnection,
         serializedTransaction: Buffer.from(transaction.serialize()),
         blockhashWithExpiryBlockHeight: blockhash,
      })

      if (!transactionResponse) {
         console.error('Transaction not confirmed')
         return
      }

      if (transactionResponse.meta?.err) {
         console.error(transactionResponse.meta?.err)
      }

      const findTokenBalance = (balances: Array<TokenBalance>, mint: string, owner: string): number => {
         const balance = balances.find((balance) => balance.mint === mint && balance.owner === owner)
         return balance ? balance.uiTokenAmount.uiAmount : 0
      }

      const postBalance = findTokenBalance(transactionResponse.meta.postTokenBalances, outputMint, wallet.publicKey.toBase58())
      const preBalance = findTokenBalance(transactionResponse.meta.preTokenBalances, outputMint, wallet.publicKey.toBase58())
      const outputAmount = postBalance - preBalance

      console.log(`https://solscan.io/tx/${signature}`)
      console.log(`Output amount: ${outputAmount}`)

      return outputAmount
   }

   async getPriceForMultipleTokens(tokensToCheck: string[]): Promise<any> {
      const tokenPrices = await axios.get(`${this.jupiterPriceURL}/price`, {
         params: {
            ids: tokensToCheck.join(','),
            vsToken: this.knownAddresses.WSOL,
         },
      })

      return tokenPrices.data
   }
}

```

# apps\backend\src\blockchain\solana\solana.module.ts

```ts
import { Module } from '@nestjs/common'
import { SolanaService } from './solana.service'
import { SolanaTokenModule } from './token/solanaToken.module'

@Module({
   imports: [SolanaTokenModule],
   providers: [SolanaService],
   exports: [SolanaService],
})
export class SolanaModule {}

```

# apps\backend\src\common\helpers\transactionSender.ts

```ts
import { BlockhashWithExpiryBlockHeight, Connection, TransactionExpiredBlockheightExceededError, VersionedTransactionResponse } from '@solana/web3.js'
import * as promiseRetry from 'promise-retry'
import { sleep } from './sleep'

type TransactionSenderAndConfirmationWaiterArgs = {
   connection: Connection
   serializedTransaction: Buffer
   blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight
}

export async function transactionSenderAndConfirmationWaiter({
   connection,
   serializedTransaction,
   blockhashWithExpiryBlockHeight,
}: TransactionSenderAndConfirmationWaiterArgs): Promise<VersionedTransactionResponse | null> {
   const txid = await connection.sendRawTransaction(serializedTransaction, {
      skipPreflight: true,
   })

   const controller = new AbortController()
   const abortSignal = controller.signal

   const abortableResender = async () => {
      while (true) {
         await sleep(2_000)
         if (abortSignal.aborted) return
         try {
            await connection.sendRawTransaction(serializedTransaction)
         } catch (e) {
            console.warn(`Failed to resend transaction: ${e}`)
         }
      }
   }

   try {
      abortableResender()
      const lastValidBlockHeight = blockhashWithExpiryBlockHeight.lastValidBlockHeight - 150

      // this would throw TransactionExpiredBlockheightExceededError
      await Promise.race([
         connection.confirmTransaction(
            {
               ...blockhashWithExpiryBlockHeight,
               lastValidBlockHeight,
               signature: txid,
               abortSignal,
            },
            'confirmed',
         ),
         new Promise(async (resolve) => {
            // in case ws socket died
            while (!abortSignal.aborted) {
               await sleep(2_000)
               const tx = await connection.getSignatureStatus(txid, {
                  searchTransactionHistory: false,
               })
               if (tx?.value?.confirmationStatus === 'confirmed') {
                  resolve(tx)
               }
            }
         }),
      ])
   } catch (e) {
      if (e instanceof TransactionExpiredBlockheightExceededError) {
         // we consume this error and getTransaction would return null
         return null
      } else {
         // invalid state from web3.js
         throw e
      }
   } finally {
      controller.abort()
   }

   // in case rpc is not synced yet, we add some retries
   const response = promiseRetry(
      async (retry) => {
         const response = await connection.getTransaction(txid, {
            commitment: 'confirmed',
            maxSupportedTransactionVersion: 0,
         })
         if (!response) {
            retry(response)
         }
         return response
      },
      {
         retries: 5,
         minTimeout: 1e3,
      },
   )

   return response
}

```

# apps\backend\src\common\helpers\sleep.ts

```ts
export async function sleep(ms: number): Promise<void> {
   return new Promise((resolve) => setTimeout(resolve, ms))
}

```

# apps\backend\src\common\helpers\getSignature.ts

```ts
import * as bs58 from 'bs58'
import { Transaction, VersionedTransaction } from '@solana/web3.js'

export function getSignature(transaction: Transaction | VersionedTransaction): string {
   const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0]
   if (!signature) {
      throw new Error('Missing transaction signature, the transaction was not signed by the fee payer')
   }
   return bs58.encode(signature)
}

```

# apps\backend\src\common\helpers\convertDexscreenerData.ts

```ts
import { Pair } from '../interfaces/dexscreenerData.interface'
import { TokenTransactions } from '../interfaces/tokenInfo.interface'

export function convertPairToTokenTransactions(pair: Pair): TokenTransactions[] {
   const transactions: TokenTransactions[] = [
      {
         time: '5m',
         txCount: `${pair.txns.m5.buys + pair.txns.m5.sells}`,
         volume: pair.volume.m5,
         volumeInUSD: pair.volume.m5 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder, real calculation requires additional data
         buys: pair.txns.m5.buys,
         sells: pair.txns.m5.sells,
         buyVolumeInUSD: pair.txns.m5.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.m5.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '1h',
         txCount: `${pair.txns.h1.buys + pair.txns.h1.sells}`,
         volume: pair.volume.h1,
         volumeInUSD: pair.volume.h1 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h1.buys,
         sells: pair.txns.h1.sells,
         buyVolumeInUSD: pair.txns.h1.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h1.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '6h',
         txCount: `${pair.txns.h6.buys + pair.txns.h6.sells}`,
         volume: pair.volume.h6,
         volumeInUSD: pair.volume.h6 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h6.buys,
         sells: pair.txns.h6.sells,
         buyVolumeInUSD: pair.txns.h6.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h6.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '24h',
         txCount: `${pair.txns.h24.buys + pair.txns.h24.sells}`,
         volume: pair.volume.h24,
         volumeInUSD: pair.volume.h24 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h24.buys,
         sells: pair.txns.h24.sells,
         buyVolumeInUSD: pair.txns.h24.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h24.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
   ]

   return transactions
}

export function getPairWithMostLiquidity(pairs: Pair[]): Pair | undefined {
   if (pairs.length === 0) return undefined

   // Find the first pair with defined liquidity to start the comparison.
   let maxLiquidityPair: Pair | undefined = pairs.find((pair) => pair.liquidity !== undefined)

   // If no pair has liquidity data, return undefined or the first pair.
   if (!maxLiquidityPair) {
      return pairs[0] // Or return pairs[0] if you prefer to return the first pair by default.
   }

   // Start the loop from the pair after the initial max liquidity pair found
   const startIndex = pairs.indexOf(maxLiquidityPair) + 1

   for (let i = startIndex; i < pairs.length; i++) {
      if (pairs[i].liquidity && pairs[i].liquidity.usd > maxLiquidityPair.liquidity.usd) {
         maxLiquidityPair = pairs[i]
      }
   }

   return maxLiquidityPair
}

export function calculateTotalLiquidityInUsd(pairs: Pair[]): number {
   return pairs.reduce((total, pair) => total + pair.liquidity.usd, 0)
}

export function getAllUniqueDexIds(pairs: Pair[]): string[] {
   return [...new Set(pairs.map((pair) => pair.dexId))]
}

```

# apps\backend\src\common\interfaces\user.interface.ts

```ts

```

# apps\backend\src\common\interfaces\tokenInfo.interface.ts

```ts
export interface TokenInfo {
   name: string
   symbol: string
   address: string
   decimals: number
   totalSupply: number
   totalSupplyPriceInUSD: number
   oneTokenPriceInUSD: number
   transactions: TokenTransactions[]
   mintAuthority: string | null
   freezeAuthority: string | null
   metadataChangeAuthority: string | null
   uniqueHolders: number
   topHolders: TokenHolderInfo[]
   totalLiquidtyInUSD: number
   topHoldersTokenSupplyDistribution: TopHoldersTokenSupplyDistribution
   verifiedDexScreener: boolean
   verifiedBirdEye: boolean
   dexesBeingTradedOn: string[]
   socialMediaLinks: URLInfo[]
   tokenPairsInLP?: TokenPairsInLP[]
}

export interface TokenPairsInLP {
   primaryTokenName: 'WSOL' | 'USDC'
   primaryTokenAmountInLP: number
   primaryTokenAmountInLPUSD: number
   secondaryTokenAmountInLP: number
   secondaryTokenAmountInLPUSD: number
   initialPrimaryTokenInLP: number
   initialSecondaryTokenInLP: number
   percentageOfTotalSupplyLockedInLP: number
   percentageOfTotalSupplyLockedInLPUSD: number
   createdOnPumpFun: boolean
   timestamp: Date
   tokenPairCreator: string
   areTokensLockedInLP: boolean
   dexName: 'Raydium'
}

export interface TokenHolderInfo {
   address: string
   balance: number
   worthInUSD: number
   percentageOfTotalSupply: number
}

export interface TokenTransactions {
   time: '5m' | '1h' | '6h' | '12h' | '24h'
   txCount: string
   volume: number
   volumeInUSD: number
   uniqueWallets: number
   buys: number
   sells: number
   buyVolumeInUSD: number
   sellVolumeInUSD: number
   buyers: number
   sellers: number
}

export interface TopTradersHoldingPercentageOfWholeSupply {
   topTradersLimit: '5' | '10' | '15' | '20'
   percentageSummed: number
}

export interface TopHoldersTokenSupplyDistribution {
   top5: number
   top10: number
   top15: number
   top20: number
}

export type URLInfo = {
   url: string
   platform?: string
}

```

# apps\backend\src\common\interfaces\dexscreenerData.interface.ts

```ts
export interface DexScreenerResponse {
   schemaVersion: string
   pairs: Pair[]
}

export interface Pair {
   chainId: string
   dexId: string
   url: string
   pairAddress: string
   labels?: string[]
   baseToken: Token
   quoteToken: Token
   priceNative: string
   priceUsd: string
   txns: Transactions
   volume: Volume
   priceChange: PriceChange
   liquidity: Liquidity
   fdv: number
   pairCreatedAt: number
   info?: Info
}

interface Token {
   address: string
   name: string
   symbol: string
}

interface Transactions {
   m5: TransactionDetail
   h1: TransactionDetail
   h6: TransactionDetail
   h24: TransactionDetail
}

interface TransactionDetail {
   buys: number
   sells: number
}

interface Volume {
   h24: number
   h6: number
   h1: number
   m5: number
}

interface PriceChange {
   m5: number
   h1: number
   h6: number
   h24: number
}

interface Liquidity {
   usd: number
   base: number
   quote: number
}

interface Info {
   imageUrl: string
   websites: Website[]
   socials: Social[]
}

interface Website {
   label: string
   url: string
}

interface Social {
   url: string
   type: string
}

```

# apps\backend\src\common\interfaces\blockchain.interface.ts

```ts
export interface BlockchainInterface {
   connect(): any
   getBalance(address: string): Promise<number>
   sendTransaction(transactionDetails: any): Promise<any>
}

```

# apps\backend\src\auth\utils\telegram.guard.ts

```ts
import { ExecutionContext, Injectable } from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'

@Injectable()
export class TelegramGuard extends AuthGuard('telegram') {
   constructor() {
      super()
   }

   async canActivate(context: ExecutionContext): Promise<boolean> {
      const result: boolean = (await super.canActivate(context)) as boolean
      await super.logIn(context.switchToHttp().getRequest())
      return result
   }
}

```

# apps\backend\src\auth\utils\authenticated.guard.ts

```ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'

@Injectable()
export class AuthenticatedGuard implements CanActivate {
   canActivate(context: ExecutionContext) {
      const request = context.switchToHttp().getRequest()
      return request.isAuthenticated()
   }
}

```

# apps\backend\src\auth\strategies\telegram.strategy.ts

```ts
import { PassportStrategy } from '@nestjs/passport'
import { Strategy } from 'passport-custom'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import * as crypto from 'crypto'
import { AuthService } from '../auth.service'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { SelectUser } from 'src/drizzle/schema'
import { Request } from 'express'

@Injectable()
export class TelegramStrategy extends PassportStrategy(Strategy, 'telegram') {
   constructor(private authService: AuthService) {
      super()
   }

   async validate(request: Request): Promise<SelectUser> {
      const telegramAuthData: TelegramAuthData = request.body
      const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN

      if (!TELEGRAM_BOT_TOKEN) {
         throw new UnauthorizedException('Bot token is not set.')
      }

      const { hash, ...authDataWithoutHash } = telegramAuthData
      const dataCheckArray: string[] = []

      for (const [key, value] of Object.entries(authDataWithoutHash)) {
         dataCheckArray.push(`${key}=${value}`)
      }
      dataCheckArray.sort()

      const dataCheckString = dataCheckArray.join('\n')
      const secretKey = crypto.createHash('sha256').update(TELEGRAM_BOT_TOKEN).digest()

      const computedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex')

      if (computedHash !== hash) {
         throw new UnauthorizedException('Data is NOT from Telegram')
      }

      if (Date.now() / 1000 - authDataWithoutHash.auth_date > 86400) {
         throw new UnauthorizedException('Data is outdated')
      }

      return await this.authService.validateTelegramUser(telegramAuthData)
   }
}

```

# apps\backend\src\auth\strategies\SessionSerializer.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable } from '@nestjs/common'
import { PassportSerializer } from '@nestjs/passport'
import { SelectUser } from 'src/drizzle/schema'
import { UserService } from 'src/user/user.service'

@Injectable()
export class SessionSerializer extends PassportSerializer {
   constructor(private userService: UserService) {
      super()
   }
   serializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      console.log('serializeUser', user)
      done(null, user)
   }

   async deserializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      const userDB = await this.userService.findById(user.id)
      console.log('deserializeUser', userDB)
      return userDB ? done(null, userDB) : done(null, null)
   }
}

```

# apps\backend\src\auth\strategies\jwt.tstrategy.ts

```ts
import { Injectable } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { Strategy, ExtractJwt } from 'passport-jwt'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
   constructor() {
      super({
         jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
         ignoreExpiration: false,
         secretOrKey: 'your_jwt_secret', // Store this in an environment variable
      })
   }

   async validate(payload: any) {
      return { userId: payload.sub, username: payload.username }
   }
}

```

# apps\frontend\src\routes\dashboard\trade\+page.svelte

```svelte
<script>
	import TradeForm from '$components/trade/TradeForm.svelte';
</script>

<TradeForm />

```

# apps\backend\src\blockchain\solana\token\solanaToken.service.ts

```ts
/* eslint-disable @typescript-eslint/no-unused-vars */
// src/blockchain/solana/token/token.service.ts
import { Inject, Injectable } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { getMint, getAccount, AccountLayout } from '@solana/spl-token'
import { PublicKey as SolanaPublicKey } from '@solana/web3.js'
import { PublicKey as UmiPublicKey } from '@metaplex-foundation/umi-public-keys'
import { fetchMetadata, findMetadataPda } from '@metaplex-foundation/mpl-token-metadata'
import { TokenHolderInfo, TokenInfo, TokenTransactions, URLInfo } from 'src/common/interfaces/tokenInfo.interface'
import axios from 'axios'
import { DexScreenerResponse } from 'src/common/interfaces/dexscreenerData.interface'
import {
   getPairWithMostLiquidity,
   convertPairToTokenTransactions,
   calculateTotalLiquidityInUsd,
   getAllUniqueDexIds,
} from 'src/common/helpers/convertDexscreenerData'
import { sleep } from 'src/common/helpers/sleep'
import { SelectDexTransactionLogs } from 'src/drizzle/schema'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { gte, and, eq } from 'drizzle-orm'
import moment from 'moment'
import * as fs from 'fs'

@Injectable()
export class SolanaTokenService {
   constructor(
      private solanaService: SolanaService,
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
   ) {}

   async getTokenInfo(tokenAddress: string): Promise<TokenInfo> {
      this.fetchTransactionsFromDatabase(tokenAddress)
      const mint = await getMint(this.solanaService.quickNodeConnection, new SolanaPublicKey(tokenAddress))

      const tokenMetadata = await fetchMetadata(
         this.solanaService.umi,
         findMetadataPda(this.solanaService.umi, {
            mint: tokenAddress as UmiPublicKey,
         }),
      )

      // console.log(tokenMetadata)

      const dexScreenerData: DexScreenerResponse = await this.fetchFromDexScreener(tokenAddress)
      const pairWithMostLiquidity = getPairWithMostLiquidity(dexScreenerData.pairs)
      const topHolders = await this.fetchTopHolders(
         tokenAddress,
         Number(mint.supply) / 10 ** mint.decimals,
         parseFloat(pairWithMostLiquidity.priceUsd),
      )

      const oneTokenPriceInUSD = await this.fetchTokenPrice(tokenAddress)

      // Initialize and populate the TokenInfo object
      const tokenInfo: TokenInfo = {
         name: tokenMetadata.name, // Replace with actual fetched data
         symbol: tokenMetadata.symbol, // Replace with actual fetched data
         address: tokenAddress,
         decimals: mint.decimals,
         totalSupply: Number(mint.supply),
         totalSupplyPriceInUSD: (Number(mint.supply) / 10 ** mint.decimals) * oneTokenPriceInUSD,
         oneTokenPriceInUSD: oneTokenPriceInUSD,
         transactions: convertPairToTokenTransactions(pairWithMostLiquidity),
         mintAuthority: mint.mintAuthority ? mint.mintAuthority.toBase58() : null,
         freezeAuthority: mint.freezeAuthority ? mint.freezeAuthority.toBase58() : null,
         metadataChangeAuthority: tokenMetadata.updateAuthority,
         uniqueHolders: 0,
         totalLiquidtyInUSD: calculateTotalLiquidityInUsd(dexScreenerData.pairs),
         topHolders: topHolders,
         topHoldersTokenSupplyDistribution: this.getTopRanksExcludingOwners(topHolders),
         verifiedDexScreener: await this.checkVerifiedDexScreener(tokenAddress),
         dexesBeingTradedOn: getAllUniqueDexIds(dexScreenerData.pairs),
         verifiedBirdEye: await this.checkVerifiedBirdEye(tokenAddress),
         socialMediaLinks: await this.fetchSocialMediaLinks(tokenMetadata.uri),
      }

      return tokenInfo
   }

   private getTopRanksExcludingOwners(elements: TokenHolderInfo[]) {
      // 5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1 = Raydium
      const excludedOwners = ['5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1']

      const filteredElements = elements.filter((element) => !excludedOwners.includes(element.address))

      return {
         top5: filteredElements.slice(0, 5).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top10: filteredElements.slice(0, 10).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top15: filteredElements.slice(0, 15).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top20: filteredElements.slice(0, 20).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
      }
   }

   private async fetchFromDexScreener(tokenAddress: string): Promise<DexScreenerResponse> {
      try {
         const response = await axios.get(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`)
         return response.data as DexScreenerResponse
      } catch (error) {
         console.error('Error fetching data from DexScreener:', error)
         throw error
      }
   }

   // private async fetchTokenPairInfo(tokenAddress: string): Promise<TokenPairsInLP[]> {}

   private async fetchTransactionsFromDatabase(tokenAddress: string) {
      const yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000)

      const transactions: SelectDexTransactionLogs[] = await this.db
         .select()
         .from(schema.dexTransactionsTable)
         .where(and(gte(schema.dexTransactionsTable.timestamp, yesterday), eq(schema.dexTransactionsTable.secondaryTokenAddress, tokenAddress)))

      fs.writeFileSync('transactions.json', JSON.stringify(transactions, null, 2))

      // function splitAndAggregateTransactions(transactions, timeFrame) {
      //    const timeFrames = {
      //       '5m': 5,
      //       '1h': 60,
      //       '6h': 360,
      //       '12h': 720,
      //       '24h': 1440,
      //    }
      //    const minutesPerFrame = timeFrames[timeFrame]

      //    // Organize transactions into buckets based on time intervals
      //    const buckets = {}

      //    transactions.forEach((tx) => {
      //       // Calculate the bucket key as the start of the interval
      //       const intervalStart = moment(tx.timestamp)
      //          .startOf('minute')
      //          .subtract(moment(tx.timestamp).minute() % minutesPerFrame, 'minutes')
      //       const key = intervalStart.format()

      //       if (!buckets[key]) {
      //          buckets[key] = []
      //       }
      //       buckets[key].push(tx)
      //    })

      //    // Process each bucket to generate aggregated results
      //    const results = []

      //    Object.keys(buckets).forEach((key) => {
      //       const aggregatedData = aggregateTransactions(buckets[key], timeFrame)
      //       results.push(aggregatedData)
      //    })

      //    return results
      // }

      // function aggregateTransactions(transactions, timeFrame) {
      //    const aggregated = {
      //       time: timeFrame,
      //       txCount: transactions.length.toString(),
      //       volume: 0,
      //       volumeInUSD: 0,
      //       uniqueWallets: new Set(),
      //       buys: 0,
      //       sells: 0,
      //       buyVolumeInUSD: 0,
      //       sellVolumeInUSD: 0,
      //       buyers: new Set(),
      //       sellers: new Set(),
      //    }

      //    transactions.forEach((tx) => {
      //       aggregated.volume += tx.primaryTokenAmount + tx.secondaryTokenAmount
      //       aggregated.volumeInUSD += tx.transactionValueInUsd
      //       aggregated.uniqueWallets.add(tx.signer)

      //       if (tx.transactionType === 'buy') {
      //          aggregated.buys++
      //          aggregated.buyVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.buyers.add(tx.signer)
      //       } else if (tx.transactionType === 'sell') {
      //          aggregated.sells++
      //          aggregated.sellVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.sellers.add(tx.signer)
      //       }
      //    })

      //    aggregated.uniqueWallets = aggregated.uniqueWallets.size
      //    aggregated.buyers = aggregated.buyers.size
      //    aggregated.sellers = aggregated.sellers.size

      //    return aggregated
      // }

      // return results
   }

   private async fetchTopHolders(tokenAddress: string, totalSupply: number, oneTokenPriceInUSD: number): Promise<TokenHolderInfo[]> {
      const tokenLargestAccounts = await this.solanaService.quickNodeConnection.getTokenLargestAccounts(new SolanaPublicKey(tokenAddress))
      const tokenAccountInfo = await this.solanaService.defaultSolanaConnection.getMultipleAccountsInfo(
         tokenLargestAccounts.value.map((account) => account.address),
      )
      const tokenHolders: TokenHolderInfo[] = []
      for (let i = 0; i < tokenLargestAccounts.value.length; i++) {
         const account = tokenLargestAccounts.value[i]
         const tokenAccountData = AccountLayout.decode(tokenAccountInfo[i].data)
         tokenHolders.push({
            address: tokenAccountData.owner.toBase58(),
            balance: account.uiAmount,
            worthInUSD: account.uiAmount * oneTokenPriceInUSD,
            percentageOfTotalSupply: (account.uiAmount / totalSupply) * 100,
         })
      }
      return tokenHolders
   }

   private async checkTokensLockedInLP(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if tokens are locked in LP
      return false
   }

   private async fetchTokenCreator(tokenAddress: string): Promise<string> {
      // Implement the logic to fetch token creator
      return ''
   }

   private async checkVerifiedDexScreener(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on Dex Screener
      return false
   }

   private async checkVerifiedBirdEye(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on BirdEye
      return false
   }

   private async fetchSocialMediaLinks(url: string): Promise<URLInfo[]> {
      try {
         const response = await axios.get(url)
         const data = response.data
         console.log(data)

         const links: URLInfo[] = []
         const socialMediaPatterns = {
            Facebook: [/facebook\.com/, /fb\.com/],
            Twitter: [/x\.com/],
            Instagram: [/instagram\.com/, /instagr\.am/],
            LinkedIn: [/linkedin\.com/],
            YouTube: [/youtube\.com/, /youtu\.be/],
            TikTok: [/tiktok\.com/],
            Reddit: [/reddit\.com/],
            Telegram: [/t\.me/],
         }

         function checkValue(value: any): void {
            if (typeof value === 'string' && isValidURL(value)) {
               const urlInfo: URLInfo = { url: value }
               for (const [name, patterns] of Object.entries(socialMediaPatterns)) {
                  if (patterns.some((pattern) => pattern.test(value))) {
                     urlInfo.platform = name
                     break
                  } else {
                     urlInfo.platform = 'Website'
                  }
               }
               links.push(urlInfo)
            } else if (typeof value === 'object' && value !== null) {
               for (const key in value) {
                  checkValue(value[key])
               }
            }
         }

         function isValidURL(url: string): boolean {
            try {
               new URL(url)
               return true
            } catch (_) {
               return false
            }
         }

         checkValue(data)
         return links.filter((link) => link.url != data.image)
      } catch (error) {
         console.error('Error fetching data:', error)
         return []
      }
   }

   private async fetchTokenPrice(tokenAddress: string): Promise<number> {
      const response = await axios.get(`https://api-v3.raydium.io/mint/price?mints=${tokenAddress}`)
      return response.data.data[tokenAddress]
   }
}

```

# apps\backend\src\blockchain\solana\token\solanaToken.service.spec.ts

```ts
import { Test, TestingModule } from '@nestjs/testing'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaService } from '../solana.service'

describe('SolanaTokenService', () => {
   let service: SolanaTokenService

   beforeEach(async () => {
      const module: TestingModule = await Test.createTestingModule({
         providers: [SolanaTokenService, SolanaService],
      }).compile()

      service = module.get<SolanaTokenService>(SolanaTokenService)
   })

   it('should be defined', () => {
      expect(service).toBeDefined()
   })
})

```

# apps\backend\src\blockchain\solana\token\solanaToken.module.ts

```ts
// src/blockchain/solana/token/token.module.ts
import { Module } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaTokenController } from './solanaToken.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'

@Module({
   providers: [SolanaTokenService, SolanaService, ...drizzleProvider],
   controllers: [SolanaTokenController],
   exports: [SolanaTokenService],
})
export class SolanaTokenModule {}

```

# apps\backend\src\blockchain\solana\token\solanaToken.controller.ts

```ts
import { Controller, Get, Param } from '@nestjs/common'
import { SolanaTokenService } from './solanaToken.service'

@Controller('solanaToken')
export class SolanaTokenController {
   constructor(private readonly solanaTokenService: SolanaTokenService) {}

   @Get(':tokenAddress')
   findOne(@Param('tokenAddress') tokenAddress: string) {
      return this.solanaTokenService.getTokenInfo(tokenAddress)
   }
}

```

# apps\backend\src\blockchain\solana\sniper\solanaSniper.module.ts

```ts
import { forwardRef, Module } from '@nestjs/common'
import { SolanaAutoSellSniperService } from './solanaAutoSellSniper.service'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { SolanaModule } from '../solana.module'
import { UserModule } from 'src/user/user.module'
import { EncryptionModule } from 'src/encryption/encryption.module'

@Module({
   imports: [SolanaModule, forwardRef(() => UserModule), EncryptionModule],
   providers: [SolanaAutoSellSniperService, ...drizzleProvider],
   exports: [SolanaAutoSellSniperService],
})
export class SolanaSniperModule {}

```

# apps\backend\src\blockchain\solana\sniper\solanaAutoSellSniper.service.ts

```ts
import { forwardRef, Inject, Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import { SolanaService } from '../solana.service'
import * as schema from 'src/drizzle/schema'
import { InsertAutoSell } from 'shared-types/src/drizzle.types'
import { UserService } from 'src/user/user.service'
import { EncryptionService } from 'src/encryption/encryption.service'

@Injectable()
export class SolanaAutoSellSniperService implements OnModuleInit, OnModuleDestroy {
   private intervalId: NodeJS.Timeout
   private readonly INTERVAL = 500 // 250ms
   private cachedEntries: InsertAutoSell[] = []
   private cachedEntriesTokenAddresses: Set<string> = new Set()

   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private readonly solanaService: SolanaService,
      @Inject(forwardRef(() => UserService))
      private readonly userService: UserService,
      private readonly encryptionService: EncryptionService,
   ) {}

   async onModuleInit() {
      this.cachedEntries = await this.getAutoSellEntriesFromDb()
      this.cachedEntriesTokenAddresses = new Set(this.cachedEntries.map((entry) => entry.tokenAddressToSell))
      this.startInterval()
   }

   onModuleDestroy() {
      this.stopInterval()
   }

   private startInterval() {
      this.intervalId = setInterval(() => this.checkAutoSells(), this.INTERVAL)
   }

   private stopInterval() {
      if (this.intervalId) {
         clearInterval(this.intervalId)
      }
   }

   private async checkAutoSells() {
      if (this.cachedEntries.length === 0) return
      try {
         const tokenPrices = await this.solanaService.getPriceForMultipleTokens([...this.cachedEntriesTokenAddresses])
         for (const entry of this.cachedEntries) {
            const currentPrice = tokenPrices.data[entry.tokenAddressToSell].price
            const potentialSaleAmount = currentPrice * parseFloat(entry.tokenAmountToSell)
            console.log(
               'Potential sale amount:',
               potentialSaleAmount,
               'Current price:',
               currentPrice,
               'Solana Profit Trigger:',
               parseFloat(entry.solAmountProfitTrigger) / 10 ** 9,
               'Solana Loss Trigger:',
               parseFloat(entry.solAmountLossTrigger) / 10 ** 9,
            )
            if (potentialSaleAmount >= parseFloat(entry.solAmountProfitTrigger) / 10 ** 9) {
               await this.executeSell(entry, 'profit')
            } else if (potentialSaleAmount <= parseFloat(entry.solAmountLossTrigger) / 10 ** 9) {
               await this.executeSell(entry, 'loss')
            }
         }
      } catch (error) {
         console.error('Error in checkAutoSells:', error)
      }
   }

   private async getAutoSellEntriesFromDb(): Promise<InsertAutoSell[]> {
      const entries = await this.db.select().from(schema.autoSellTable).execute()
      return entries
   }

   private async executeSell(entry: InsertAutoSell, trigger) {
      try {
         this.removeAutoSellEntry(entry)
         const wallet = await this.userService.getWalletById(entry.userId, entry.walletId)
         const user = await this.userService.findById(entry.userId)
         await this.solanaService.makeJupiterSwapTransaction(
            entry.tokenAddressToSell,
            this.solanaService.knownAddresses.WSOL,
            parseFloat(entry.tokenAmountToSell) * 10 ** 6,
            parseFloat(entry.slippage) * 100,
            this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
            1039280,
         )
         await this.removeAutoSellEntry(entry)
         console.log(`Auto-sell executed for user ${entry.userId} (${trigger} trigger)`)
      } catch (error) {
         console.error(`Failed to execute auto-sell for user ${entry.userId}:`, error)
      }
   }

   public async addAutoSellEntry(entry: InsertAutoSell) {
      this.cachedEntries.push(entry)
      this.cachedEntriesTokenAddresses.add(entry.tokenAddressToSell)
      await this.db.insert(schema.autoSellTable).values(entry).execute()
   }

   public async removeAutoSellEntry(entry: InsertAutoSell) {
      const index = this.cachedEntries.findIndex((e) => e.userId === entry.userId)
      if (index !== -1) {
         this.cachedEntries.splice(index, 1)
         this.cachedEntriesTokenAddresses.delete(entry.tokenAddressToSell)
      }
      //   await this.db.delete(schema.autoSellTable).where(schema.autoSellTable.id.equals(entry.id)).execute()
   }
}

```
</file>

<file path="package.json">
{
   "name": "solana-trading-bot-workspace",
   "private": true,
   "scripts": {
      "build:shared-types": "tsc --project packages/shared-types",
      "prestart": "npm run build:shared-types",
      "start": "npm run start --workspace=backend",
      "predev": "npm run build:shared-types",
      "dev": "concurrently \"npm run dev --workspace=backend\" \"npm run dev --workspace=frontend\""
   },
   "workspaces": [
      "apps/*",
      "packages/*"
   ],
   "packageManager": "pnpm@8.15.1+sha512.831cf4c5f8b8374af71521d4d153db49d7086de615c2af7cb5e9d7eb8ba630ddac46fea495d643e552ef2e68a3aa99a3e5e9fbee8696702967504df5c59cb273"
}
</file>

<file path="README.md">
# solana_trading_bot
</file>

<file path="tsconfig.json">
{
   "compilerOptions": {
      "baseUrl": ".",
      "paths": {
         "shared-types": ["packages/shared-types/src"]
      }
   },
   "include": ["apps/**/*", "packages/**/*"]
}
</file>

<file path="apps/frontend/.gitignore">
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
</file>

<file path="apps/frontend/.prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
</file>

<file path="apps/frontend/.prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 120,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}
</file>

<file path="apps/frontend/eslint.config.js">
import js from '@eslint/js';
import ts from 'typescript-eslint';
import svelte from 'eslint-plugin-svelte';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

/** @type {import('eslint').Linter.Config[]} */
export default [
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
];
</file>

<file path="apps/frontend/package.json">
{
	"name": "frontend",
	"version": "0.0.1",
	"private": true,
	"scripts": {
		"dev": "cross-env HOST=custom.domain vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"test": "npm run test:integration && npm run test:unit",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"lint": "prettier --check . && eslint .",
		"format": "prettier --write .",
		"test:integration": "playwright test",
		"test:unit": "vitest"
	},
	"devDependencies": {
		"@playwright/test": "^1.28.1",
		"@sveltejs/adapter-auto": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^3.0.0",
		"@types/eslint": "^9.6.0",
		"@types/node": "^22.1.0",
		"autoprefixer": "^10.4.19",
		"cross-env": "^7.0.3",
		"eslint": "^9.0.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.36.0",
		"flowbite-svelte-icons": "^1.6.1",
		"globals": "^15.0.0",
		"postcss": "^8.4.40",
		"prettier": "^3.1.1",
		"prettier-plugin-svelte": "^3.1.2",
		"svelte": "^4.2.7",
		"svelte-check": "^3.6.0",
		"svelte-simples": "^1.0.3",
		"tailwindcss": "^3.4.7",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.0.0",
		"vite": "^5.0.3",
		"vitest": "^2.0.0"
	},
	"type": "module",
	"dependencies": {
		"axios": "^1.7.2",
		"flowbite": "^2.4.1",
		"flowbite-svelte": "^0.46.15",
		"lucide-svelte": "^0.424.0",
		"shared-types": "^1.0.0",
		"svelte-french-toast": "^1.2.0"
	}
}
</file>

<file path="apps/frontend/playwright.config.ts">
import type { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'tests',
	testMatch: /(.+\.)?(test|spec)\.[jt]s/
};

export default config;
</file>

<file path="apps/frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="apps/frontend/README.md">
# create-svelte

Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
</file>

<file path="apps/frontend/svelte.config.js">
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://kit.svelte.dev/docs/integrations#preprocessors
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://kit.svelte.dev/docs/adapters for more information about adapters.
		adapter: adapter(),
		alias: {
			$services: './src/services',
			$components: './src/components',
			$stores: './src/stores',
			$utils: './src/utils'
		}
	}
};

export default config;
</file>

<file path="apps/frontend/tailwind.config.js">
import flowbitePlugin from 'flowbite/plugin';

/** @type {import('tailwindcss').Config} */
export default {
	content: [
		'./src/**/*.{html,js,svelte,ts}',
		'../../node_modules/flowbite-svelte/**/*.{html,js,svelte,ts}'
	],
	darkMode: 'selector',
	theme: {
		extend: {
			colors: {
				// flowbite-svelte
				primary: {
					50: '#FFF5F2',
					100: '#FFF1EE',
					200: '#FFE4DE',
					300: '#FFD5CC',
					400: '#FFBCAD',
					500: '#FE795D',
					600: '#EF562F',
					700: '#EB4F27',
					800: '#CC4522',
					900: '#A5371B'
				}
			}
		}
	},

	plugins: [flowbitePlugin]
};
</file>

<file path="apps/frontend/tsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	// except $lib which is handled by https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}
</file>

<file path="apps/frontend/vite.config.ts">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vitest/config';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	},
	server: {
		host: 'example.com',
		port: 80
	}
});
</file>

<file path="apps/backend/.eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prettier/prettier': ['error', { endOfLine: 'auto' }],
  },
};
</file>

<file path="apps/backend/.prettierrc">
{
  "tabWidth": 3,
  "semi": false,
  "singleQuote": true,
  "printWidth": 150
}
</file>

<file path="apps/backend/drizzle.config.ts">
import { config } from 'dotenv'
import { defineConfig } from 'drizzle-kit'

config({ path: '.env' })

export default defineConfig({
   schema: './src/drizzle/schema.ts',
   out: './src/drizzle/migrations',
   dialect: 'postgresql',
   dbCredentials: {
      url: process.env.DATABASE_URL!,
   },
})
</file>

<file path="apps/backend/nest-cli.json">
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
</file>

<file path="apps/backend/package.json">
{
   "name": "backend",
   "version": "0.0.1",
   "description": "",
   "author": "",
   "private": true,
   "license": "UNLICENSED",
   "scripts": {
      "build": "nest build",
      "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
      "start": "nest start",
      "start:dev": "nest start --watch",
      "start:debug": "nest start --debug --watch",
      "start:prod": "node dist/main",
      "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
      "test": "jest",
      "test:watch": "jest --watch",
      "test:cov": "jest --coverage",
      "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
      "test:e2e": "jest --config ./test/jest-e2e.json",
      "migrate": "npx drizzle-kit generate && npx drizzle-kit migrate"
   },
   "dependencies": {
      "@metaplex-foundation/mpl-token-metadata": "^3.2.1",
      "@metaplex-foundation/umi": "^0.9.2",
      "@metaplex-foundation/umi-bundle-defaults": "^0.9.2",
      "@nestjs/common": "^10.0.0",
      "@nestjs/core": "^10.0.0",
      "@nestjs/jwt": "^10.2.0",
      "@nestjs/mapped-types": "*",
      "@nestjs/passport": "^10.0.3",
      "@nestjs/platform-express": "^10.3.10",
      "@nestjs/schedule": "^4.1.0",
      "@solana/spl-token": "^0.4.8",
      "@solana/web3.js": "^1.95.0",
      "@supabase/supabase-js": "^2.44.3",
      "axios": "^1.7.3",
      "bcrypt": "^5.1.1",
      "bignumber.js": "^9.1.2",
      "bs58": "^4.0.1",
      "class-transformer": "^0.5.1",
      "class-validator": "^0.14.1",
      "dotenv": "^16.4.5",
      "drizzle-orm": "^0.32.0",
      "express-session": "^1.18.0",
      "moment": "^2.30.1",
      "passport": "^0.7.0",
      "passport-custom": "^1.1.1",
      "passport-jwt": "^4.0.1",
      "passport-local": "^1.0.0",
      "postgres": "^3.4.4",
      "promise-retry": "^2.0.1",
      "reflect-metadata": "^0.2.0",
      "rxjs": "^7.8.1",
      "shared-types": "^1.0.0"
   },
   "devDependencies": {
      "@nestjs/cli": "^10.0.0",
      "@nestjs/schematics": "^10.0.0",
      "@nestjs/testing": "^10.0.0",
      "@types/express": "^4.17.17",
      "@types/express-session": "^1.18.0",
      "@types/jest": "^29.5.2",
      "@types/node": "^20.3.1",
      "@types/supertest": "^6.0.0",
      "@typescript-eslint/eslint-plugin": "^7.0.0",
      "@typescript-eslint/parser": "^7.0.0",
      "drizzle-kit": "^0.23.0",
      "eslint": "^8.42.0",
      "eslint-config-prettier": "^9.0.0",
      "eslint-plugin-prettier": "^5.0.0",
      "jest": "^29.5.0",
      "prettier": "^3.0.0",
      "source-map-support": "^0.5.21",
      "supertest": "^7.0.0",
      "ts-jest": "^29.1.0",
      "ts-loader": "^9.4.3",
      "ts-node": "^10.9.1",
      "tsconfig-paths": "^4.2.0",
      "typescript": "^5.1.3"
   },
   "jest": {
      "moduleFileExtensions": [
         "js",
         "json",
         "ts"
      ],
      "rootDir": "src",
      "testRegex": ".*\\.spec\\.ts$",
      "transform": {
         "^.+\\.(t|j)s$": "ts-jest"
      },
      "collectCoverageFrom": [
         "**/*.(t|j)s"
      ],
      "coverageDirectory": "../coverage",
      "testEnvironment": "node"
   }
}
</file>

<file path="apps/backend/README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).
</file>

<file path="apps/backend/transactions.json">
[]
</file>

<file path="apps/backend/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="apps/backend/tsconfig.json">
{
   // "extends": "../../tsconfig.json",
   "compilerOptions": {
      "module": "commonjs",
      "declaration": true,
      "removeComments": true,
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "allowSyntheticDefaultImports": true,
      "target": "ES2021",
      "sourceMap": true,
      "outDir": "./dist",
      "baseUrl": "./",
      "incremental": true,
      "skipLibCheck": true,
      "strictNullChecks": false,
      "noImplicitAny": false,
      "strictBindCallApply": false,
      "forceConsistentCasingInFileNames": false,
      "noFallthroughCasesInSwitch": false
   }
}
</file>

<file path="packages/shared-types/package.json">
{
   "name": "shared-types",
   "version": "1.0.0",
   "main": "index.js",
   "scripts": {
      "build": "tsc"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "description": "",
   "dependencies": {
      "backend": "^0.0.1",
      "typescript": "^5.5.4"
   }
}
</file>

<file path="packages/shared-types/tsconfig.json">
{
   "compilerOptions": {
      "declaration": true,
      "emitDeclarationOnly": true,
      "outDir": "dist",
      "rootDir": "src",
      "strict": true
   },
   "include": ["src"]
}
</file>

<file path="apps/frontend/tests/test.ts">
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});
</file>

<file path="apps/frontend/src/app.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	input[type='number']::-webkit-inner-spin-button,
	input[type='number']::-webkit-outer-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}
	input[type='number'] {
		appearance: textfield;
	}
}

.manrope {
	font-family: 'Manrope', sans-serif;
}

.audiowide {
	font-family: 'Audiowide', sans-serif;
}

.quicksand {
	font-family: 'Quicksand', sans-serif;
}

body {
	background-color: #121528;
	min-height: 100vh;
}
</file>

<file path="apps/frontend/src/app.d.ts">
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		interface Locals {
			user: {
				id: number;
				createdAt: string;
			};
		}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="apps/frontend/src/app.html">
<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Audiowide&family=Manrope:wght@200..800&family=Quicksand:wght@300..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path="apps/frontend/src/hooks.server.ts">
// import { PUBLIC_BACKEND_URL } from '$env/static/public';
// import type { Handle } from '@sveltejs/kit';

// export const handle: Handle = async ({ event, resolve }) => {
// 	if (event.cookies.get('connect.sid')) {
// 		const res = await fetch(PUBLIC_BACKEND_URL + '/user/status', {
// 			credentials: 'include',
// 			headers: {
// 				Cookie: 'connect.sid=' + event.cookies.get('connect.sid')
// 			}
// 		});
// 		const data = await res.json();
// 		if (res.ok) {
// 			event.locals.user = data;
// 		}
// 	}
// 	const response = await resolve(event);
// 	return response;
// };
</file>

<file path="apps/frontend/src/index.test.ts">
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
</file>

<file path="apps/backend/src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="apps/backend/src/app.controller.ts">
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
</file>

<file path="apps/backend/src/app.module.ts">
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { DrizzleModule } from './drizzle/drizzle.module'
import { UserModule } from './user/user.module'
import { SolanaModule } from './blockchain/solana/solana.module'
import { AuthModule } from './auth/auth.module'
import { PassportModule } from '@nestjs/passport'

@Module({
   imports: [
      PassportModule.register({
         session: true,
      }),
      DrizzleModule,
      UserModule,
      SolanaModule,
      AuthModule,
   ],
   controllers: [AppController],
   providers: [AppService],
})
export class AppModule {}
</file>

<file path="apps/backend/src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="apps/backend/src/main.ts">
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import 'dotenv/config'
import * as session from 'express-session'
import * as passport from 'passport'

async function bootstrap() {
   const app = await NestFactory.create(AppModule)
   app.use(
      session({
         secret: 'my-secret',
         resave: false,
         saveUninitialized: false,
         cookie: {
            httpOnly: true,
            maxAge: 3600000,
            secure: false, // Set to true if you are using HTTPS
            sameSite: 'lax',
         },
      }),
   )
   app.use(passport.initialize())
   app.use(passport.session())

   app.enableCors({
      origin: 'http://example.com', // Adjust the origin according to where your front-end is hosted
      methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
      allowedHeaders: 'Content-Type, Accept',
      credentials: true,
   })
   await app.listen(3000)
}
bootstrap()
</file>

<file path="apps/backend/test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="apps/backend/test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path="packages/shared-types/src/autoSell.interface.ts">
export enum AutoSellStrategy {
   SIMPLE = "simple",
   GRID = "grid",
}

export interface SimpleStrategyParams {
   profitPercentage: number;
   lossPercentage: number;
}

export interface ProfitTarget {
   multiplier: number;
   sellPercentage: number;
}

export interface GridStrategyParams {
   stopLossType: "static" | "trailing" | "breakeven";
   stopLossPercentage: number;
   profitTargets: ProfitTarget[];
}

export interface AutoSellDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountToSell: string;
   strategy: AutoSellStrategy;
   strategyParams: SimpleStrategyParams | GridStrategyParams;
   initialPrice: number;
}
</file>

<file path="packages/shared-types/src/drizzle.types.ts">
import {
   usersTable,
   authProvidersTable,
   userWalletsTable,
   autoSellTable,
   tokenPairInfo,
   tokenPairTransactionsTable,
   dexTransactionsTable,
   dexTransactionsErrorsTable,
} from "backend/src/drizzle/schema";

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert;
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect;

export type InsertUserWallet = typeof userWalletsTable.$inferInsert;
export type SelectUserWallet = typeof userWalletsTable.$inferSelect;

export type InsertAutoSell = typeof autoSellTable.$inferInsert;
export type SelectAutoSell = typeof autoSellTable.$inferSelect;

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert;
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect;

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert;
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect;

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert;
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect;

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert;
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect;
</file>

<file path="packages/shared-types/src/JupiterPriceResponse.interface.ts">
export interface JupiterPriceReponse {
   data: {
      [tokenAddress: string]: TokenPriceInfo;
   };
   timeTaken: number;
}

export interface TokenPriceInfo {
   id: string;
   mintSymbol: string;
   vsToken: string;
   vsTokenSymbol: string;
   price: number;
}
</file>

<file path="packages/shared-types/src/TelegramAuthData.interface.ts">
export interface TelegramAuthData {
   auth_date: number;
   first_name: string;
   hash: string;
   id: number;
   last_name: string;
}
</file>

<file path="packages/shared-types/src/tokenInfo.interface.ts">
export interface TokenInfo {
   name: string;
   symbol: string;
   address: string;
   decimals: number;
   image: string;
   totalSupply: number;
   totalSupplyPriceInUSD: number;
   oneTokenPriceInUSD: number;
   transactions: TokenTransactions[];
   mintAuthority: string | null;
   freezeAuthority: string | null;
   metadataChangeAuthority: string | null;
   uniqueHolders: number;
   topHolders: TokenHolderInfo[];
   totalLiquidtyInUSD: number;
   topHoldersTokenSupplyDistribution: TopHoldersTokenSupplyDistribution;
   verifiedDexScreener: boolean;
   verifiedBirdEye: boolean;
   dexesBeingTradedOn: string[];
   socialMediaLinks: URLInfo[];
   tokenPairsInLP?: TokenPairsInLP[];
}

export interface TokenPairsInLP {
   primaryTokenName: "WSOL" | "USDC";
   primaryTokenAmountInLP: number;
   primaryTokenAmountInLPUSD: number;
   secondaryTokenAmountInLP: number;
   secondaryTokenAmountInLPUSD: number;
   initialPrimaryTokenInLP: number;
   initialSecondaryTokenInLP: number;
   percentageOfTotalSupplyLockedInLP: number;
   percentageOfTotalSupplyLockedInLPUSD: number;
   createdOnPumpFun: boolean;
   timestamp: Date;
   tokenPairCreator: string;
   areTokensLockedInLP: boolean;
   dexName: "Raydium";
}

export interface TokenHolderInfo {
   address: string;
   balance: number;
   worthInUSD: number;
   percentageOfTotalSupply: number;
}

export interface TokenTransactions {
   time: "5m" | "1h" | "6h" | "12h" | "24h";
   txCount: string;
   volume: number;
   volumeInUSD: number;
   uniqueWallets: number;
   buys: number;
   sells: number;
   buyVolumeInUSD: number;
   sellVolumeInUSD: number;
   buyers: number;
   sellers: number;
}

export interface TopTradersHoldingPercentageOfWholeSupply {
   topTradersLimit: "5" | "10" | "15" | "20";
   percentageSummed: number;
}

export interface TopHoldersTokenSupplyDistribution {
   top5: number;
   top10: number;
   top15: number;
   top20: number;
}

export type URLInfo = {
   url: string;
   platform?: string;
};
</file>

<file path="packages/shared-types/src/userInfo.interface.ts">
// This file could be placed in a shared directory accessible by both frontend and backend

export interface UserWalletInfo {
   solBalance: number;
   address: string;
   name: string;
}

export interface UserInfo {
   wallets: UserWalletInfo[];
}
</file>

<file path="apps/frontend/src/components/TelegramLoginWidget.svelte">
<script lang="ts">
	import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { goto } from '$app/navigation';

	async function onTelegramAuth(user: TelegramAuthData) {
		console.log(JSON.stringify(user));
		const res = await fetch(PUBLIC_BACKEND_URL + '/auth/loginWithTelegram', {
			method: 'POST',
			body: JSON.stringify(user),
			credentials: 'include',
			headers: {
				'Content-Type': 'application/json'
			}
		});
		if (res.ok) {
			const data = await res.json();
			goto('/dashboard');
		} else {
			console.error('Failed to login with Telegram');
		}
	}

	// Svelte action to load the Telegram widget
	function loadTelegramWidget(node: HTMLElement) {
		if (typeof window !== 'undefined') {
			window.onTelegramAuth = onTelegramAuth;

			const script = document.createElement('script');
			script.src = 'https://telegram.org/js/telegram-widget.js?7';
			script.async = true;
			script.setAttribute('data-telegram-login', 'SolanaCryptoTradingTestBot');
			script.setAttribute('data-size', 'large');
			script.setAttribute('data-radius', '10');
			script.setAttribute('data-onauth', 'onTelegramAuth(user)');
			script.setAttribute('data-userpic', 'false');
			node.appendChild(script);
		}
	}
</script>

<div class="telegram-login" use:loadTelegramWidget></div>

<style>
	div {
		width: 100%;
		display: flex;
		justify-content: center;
	}
</style>
</file>

<file path="apps/frontend/src/lib/api.ts">
import axios from 'axios';
// import { token } from '../stores/auth';
import { PUBLIC_BACKEND_URL } from '$env/static/public';

// let jwtToken = '';
// token.subscribe((value: string) => {
// 	jwtToken = value;
// });

const api = axios.create({
	baseURL: PUBLIC_BACKEND_URL
});

api.interceptors.request.use((config) => {
	// if (jwtToken) {
	// 	config.headers.Authorization = `Bearer ${jwtToken}`;
	// }
	config.withCredentials = true;
	return config;
});

export default api;
</file>

<file path="apps/frontend/src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="apps/frontend/src/lib/VolatileMarketStrategy.ts">
// src/lib/VolatileMarketStrategy.ts

export interface VolatileMarketStrategy {
	initialStopLoss: number;
	quickProfitTarget: number;
	trailingStopLoss: number;
	volumeThreshold: number;
	timeBasedExit: number; // in milliseconds
}

export interface Projection {
	scenario: string;
	profitLoss: number;
	profitLossPercentage: number;
}

export class VolatileTokenTrader {
	private strategy: VolatileMarketStrategy;
	private entryPrice: number;
	private entryTime: number;
	private highestPrice: number;
	private currentStopLoss: number;

	constructor(strategy: VolatileMarketStrategy, entryPrice: number) {
		this.strategy = strategy;
		this.entryPrice = entryPrice;
		this.entryTime = Date.now();
		this.highestPrice = entryPrice;
		this.currentStopLoss = entryPrice * (1 - strategy.initialStopLoss);
	}

	updatePrice(currentPrice: number, currentVolume: number): string {
		this.highestPrice = Math.max(this.highestPrice, currentPrice);

		// Check for quick profit target
		if (currentPrice >= this.entryPrice * (1 + this.strategy.quickProfitTarget)) {
			return 'SELL_PARTIAL';
		}

		// Update trailing stop loss
		const newStopLoss = this.highestPrice * (1 - this.strategy.trailingStopLoss);
		this.currentStopLoss = Math.max(this.currentStopLoss, newStopLoss);

		// Check if stop loss is hit
		if (currentPrice <= this.currentStopLoss) {
			return 'SELL_ALL';
		}

		// Check volume-based exit
		if (currentVolume < this.strategy.volumeThreshold) {
			return 'VOLUME_ALERT';
		}

		// Check time-based exit
		if (Date.now() - this.entryTime > this.strategy.timeBasedExit) {
			return 'TIME_EXIT';
		}

		return 'HOLD';
	}

	getCurrentStopLoss(): number {
		return this.currentStopLoss;
	}
}

export function calculateProjections(strategy: VolatileMarketStrategy, initialInvestment: number): Projection[] {
	const projections: Projection[] = [];

	// Worst-case scenario: Initial stop loss hit
	projections.push({
		scenario: 'Worst Case (Stop Loss Hit)',
		profitLoss: -initialInvestment * strategy.initialStopLoss,
		profitLossPercentage: -strategy.initialStopLoss * 100
	});

	// Best-case scenario: Quick profit target hit, then trailing stop loss at 2x initial price
	projections.push({
		scenario: 'Best Case (Quick Profit + Continued Growth)',
		profitLoss: initialInvestment * (strategy.quickProfitTarget + 1),
		profitLossPercentage: (strategy.quickProfitTarget + 1) * 100
	});

	// Moderate case: Quick profit target hit, then immediate reversal
	projections.push({
		scenario: 'Moderate Case (Quick Profit Only)',
		profitLoss: initialInvestment * strategy.quickProfitTarget,
		profitLossPercentage: strategy.quickProfitTarget * 100
	});

	// Time-based exit scenario: Assuming 10% growth before time exit
	projections.push({
		scenario: 'Time-Based Exit (10% Growth)',
		profitLoss: initialInvestment * 0.1,
		profitLossPercentage: 10
	});

	// Volume-based exit scenario: Assuming 5% growth before volume drop
	projections.push({
		scenario: 'Volume-Based Exit (5% Growth)',
		profitLoss: initialInvestment * 0.05,
		profitLossPercentage: 5
	});

	return projections;
}
</file>

<file path="apps/frontend/src/routes/+layout.svelte">
<script lang="ts">
	import '../app.css';
	export let data;

	$: console.log(data);
</script>

<slot />
</file>

<file path="apps/frontend/src/routes/+page.svelte">
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { Card } from 'flowbite-svelte';
	async function getStatus() {
		const res = await fetch(PUBLIC_BACKEND_URL + '/user', {
			credentials: 'include'
		});
		const data = await res.json();
		console.log(data);
	}
</script>

<h1 class="text-3xl font-bold underline">Hello world!</h1>

<TelegramLoginWidget />

<button on:click={getStatus}> GET STATUS</button>

<Card href="/cards">
	<h5 class="mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
		Noteworthy technology acquisitions 2021
	</h5>
	<p class="font-normal text-gray-700 dark:text-gray-400 leading-tight">
		Here are the biggest enterprise technology acquisitions of 2021 so far, in reverse chronological
		order.
	</p>
</Card>

<style lang="postcss">
	:global(html) {
		background-color: theme(colors.gray.100);
	}
</style>
</file>

<file path="apps/frontend/src/stores/auth.ts">
// import { writable } from 'svelte/store';

// export const token = writable(localStorage.getItem('token') || '');

// token.subscribe((value) => {
// 	if (value) {
// 		localStorage.setItem('token', value);
// 	} else {
// 		localStorage.removeItem('token');
// 	}
// });
</file>

<file path="apps/frontend/src/stores/priceStore.ts">
import { writable, type Writable } from 'svelte/store';

interface TokenPricesInUsd {
	[tokenAddress: string]: number;
}

export const tokenPricesInUSD: Writable<TokenPricesInUsd> = writable({});
</file>

<file path="apps/frontend/src/stores/tokenStore.ts">
import { writable, type Writable } from 'svelte/store';
import { type TokenInfo } from 'shared-types/src/tokenInfo.interface';

export const defaultTokenInfo: TokenInfo = {
	name: '',
	symbol: '',
	address: '',
	decimals: 0,
	image: '',
	totalSupply: 0,
	totalSupplyPriceInUSD: 0,
	oneTokenPriceInUSD: 0,
	transactions: [],
	mintAuthority: null,
	freezeAuthority: null,
	metadataChangeAuthority: null,
	uniqueHolders: 0,
	topHolders: [],
	totalLiquidtyInUSD: 0,
	topHoldersTokenSupplyDistribution: {
		top5: 0,
		top10: 0,
		top15: 0,
		top20: 0
	},
	verifiedDexScreener: false,
	verifiedBirdEye: false,
	dexesBeingTradedOn: [],
	socialMediaLinks: [],
	tokenPairsInLP: []
};

export const tokenInfo: Writable<TokenInfo> = writable(defaultTokenInfo);
</file>

<file path="apps/frontend/src/stores/userStore.ts">
import { writable, type Writable } from 'svelte/store';
import { type UserInfo } from 'shared-types/src/userInfo.interface';

export const defaultUserInfo: UserInfo = {
	wallets: []
};

export const userInfo: Writable<UserInfo> = writable(defaultUserInfo);
</file>

<file path="apps/frontend/src/services/priceUpdateService.ts">
import api from '../lib/api';
import { tokenPricesInUSD } from '$stores/priceStore';
import { type JupiterPriceReponse } from 'shared-types/src/JupiterPriceResponse.interface';

export const priceUpdateService = {
	tokenAddressesToFetchPrice: ['So11111111111111111111111111111111111111112'],
	vsToken: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
	priceFetchingInterval: 10000,
	priceFetchingIntervalId: null as number | NodeJS.Timeout | null,

	async fetchPriceUpdate() {
		const response = await api.get<JupiterPriceReponse>(`/solana/price`, {
			params: {
				tokenAddresses: this.tokenAddressesToFetchPrice.join(','),
				vsToken: this.vsToken
			}
		});
		for (const tokenAddress in response.data.data) {
			tokenPricesInUSD.update((tokenPricesInUsd) => {
				tokenPricesInUsd[tokenAddress] = response.data.data[tokenAddress].price;
				return tokenPricesInUsd;
			});
		}
	},

	reset() {
		this.removeAllTokensExceptDefault();
		this.stopPriceUpdate();
	},

	removeAllTokensExceptDefault() {
		this.tokenAddressesToFetchPrice = ['So11111111111111111111111111111111111111112'];
	},

	addNewTokenAddressToFetchPrice(tokenAddress: string) {
		this.tokenAddressesToFetchPrice.push(tokenAddress);
	},

	async startPriceUpdate() {
		await this.fetchPriceUpdate();
		this.priceFetchingIntervalId = setInterval(() => {
			this.fetchPriceUpdate();
		}, this.priceFetchingInterval);
	},

	stopPriceUpdate() {
		if (this.priceFetchingIntervalId) {
			clearInterval(this.priceFetchingIntervalId as number);
		}
	}
};
</file>

<file path="apps/frontend/src/services/tokenService.ts">
import type { TokenInfo } from 'shared-types/src/tokenInfo.interface';
import api from '../lib/api';
import { defaultTokenInfo, tokenInfo } from '../stores/tokenStore';
import { priceUpdateService } from './priceUpdateService';

export const tokenService = {
	loading: false,
	async fetchTokenInfo(tokenAddress: string) {
		this.loading = true;
		priceUpdateService.addNewTokenAddressToFetchPrice(tokenAddress);
		await priceUpdateService.startPriceUpdate();

		const response = await api.get(`/solanaToken/${tokenAddress}`);
		tokenInfo.update(() => response.data as TokenInfo);
		this.loading = false;
	},
	reset() {
		priceUpdateService.reset();
		tokenInfo.update(() => defaultTokenInfo);
	}
};
</file>

<file path="apps/frontend/src/types/global.d.ts">
// src/types/global.d.ts
import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';

declare global {
	interface Window {
		onTelegramAuth: (user: TelegramAuthData) => void;
	}
}

export {};
</file>

<file path="apps/frontend/src/utils/copyToClipboard.ts">
export async function copyToClipboard(text: string) {
	if (navigator.clipboard) {
		try {
			await navigator.clipboard.writeText(text);
			console.log('Text copied to clipboard using Clipboard API');
		} catch (err) {
			console.error('Failed to copy text using Clipboard API: ', err);
		}
	} else {
		// Fallback for older browsers
		fallbackCopyTextToClipboard(text);
	}
}

function fallbackCopyTextToClipboard(text: string) {
	const textArea = document.createElement('textarea');
	textArea.value = text;
	document.body.appendChild(textArea);
	textArea.focus();
	textArea.select();
	try {
		document.execCommand('copy');
		console.log('Text copied to clipboard using execCommand');
	} catch (err) {
		console.error('Failed to copy text using execCommand: ', err);
	}
	document.body.removeChild(textArea);
}
</file>

<file path="apps/frontend/src/utils/formatters.ts">
// utils/formatters.ts

export function formatNumber(num: number): string {
	return new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(num);
}

export function formatUSD(num: number): string {
	return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(num);
}

export function formatPercentage(num: number): string {
	return new Intl.NumberFormat('en-US', { style: 'percent', maximumFractionDigits: 2 }).format(num / 100);
}
</file>

<file path="apps/backend/src/auth/auth.controller.ts">
import { Controller, UseGuards, Request, Post } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthGuard } from '@nestjs/passport'
import { JwtService } from '@nestjs/jwt'
import { UserService } from 'src/user/user.service'
import { TelegramGuard } from './utils/telegram.guard'

@Controller('auth')
export class AuthController {
   constructor(
      private authService: AuthService,
      private jwtService: JwtService,
      private userService: UserService,
   ) {}

   @UseGuards(TelegramGuard)
   @Post('loginWithTelegram')
   async loginWithTelegram(@Request() req) {
      return req.user
   }

   @UseGuards(AuthGuard('local'))
   @Post('login')
   async login(@Request() req) {
      const user = req.user
      const payload = { username: user.username, sub: user.userId }
      return {
         access_token: this.jwtService.sign(payload),
      }
   }

   // @Post('store-key')
   // async storePrivateKey(@Body() body: any, @Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.authService.encryptPrivateKey(body.privateKey)
   //    await this.userService.storeEncryptedPrivateKey(userId, encryptedPrivateKey)
   //    return { message: 'Private key stored successfully' }
   // }

   // @Get('retrieve-key')
   // async retrievePrivateKey(@Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.userService.getEncryptedPrivateKey(userId)
   //    if (!encryptedPrivateKey) {
   //       return { message: 'Private key not found' }
   //    }
   //    const privateKey = await this.authService.decryptPrivateKey(encryptedPrivateKey)
   //    return { privateKey }
   // }
}
</file>

<file path="apps/backend/src/auth/auth.module.ts">
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { PassportModule } from '@nestjs/passport'
import { JwtModule } from '@nestjs/jwt'
import { JwtStrategy } from './strategies/jwt.tstrategy'
import { TelegramStrategy } from './strategies/telegram.strategy'
import { UserModule } from 'src/user/user.module'
import { SessionSerializer } from './strategies/SessionSerializer'

@Module({
   imports: [
      PassportModule,
      JwtModule.register({
         secret: process.env.JWT_SECRET,
         signOptions: { expiresIn: '1d' },
      }),
      UserModule,
   ],
   providers: [AuthService, JwtStrategy, TelegramStrategy, SessionSerializer],
   controllers: [AuthController],
})
export class AuthModule {}
</file>

<file path="apps/backend/src/auth/auth.service.ts">
import { Injectable } from '@nestjs/common'
import { UserService } from 'src/user/user.service'
import * as crypto from 'crypto'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { InsertUser, SelectUser } from 'src/drizzle/schema'

@Injectable()
export class AuthService {
   constructor(private userService: UserService) {}

   async validateTelegramUser(telegramAuthData: TelegramAuthData): Promise<SelectUser> {
      let user = await this.userService.findByTelegramId(telegramAuthData.id)
      if (!user) {
         // Create a new user if it doesn't exist
         const insertUserData: InsertUser = {}
         user = await this.userService.create(insertUserData, {
            provider: 'telegram',
            providerId: telegramAuthData.id.toString(),
         })
      }
      return user
   }

   async encryptPrivateKey(privateKey: string): Promise<string> {
      const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let encrypted = cipher.update(privateKey, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return encrypted
   }

   async decryptPrivateKey(encryptedPrivateKey: string): Promise<string> {
      const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let decrypted = decipher.update(encryptedPrivateKey, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}
</file>

<file path="apps/backend/src/drizzle/drizzle.module.ts">
import { Module } from '@nestjs/common';
import { drizzleProvider } from './drizzle.provider';

@Module({
  providers: [...drizzleProvider],
})
export class DrizzleModule {}
</file>

<file path="apps/backend/src/drizzle/drizzle.provider.ts">
import { drizzle } from 'drizzle-orm/postgres-js'
import * as postgres from 'postgres'
import * as schema from './schema'

export const DrizzleAsyncProvider = 'drizzleProvider'

export const drizzleProvider = [
   {
      provide: DrizzleAsyncProvider,
      useFactory: async () => {
         const client = postgres(process.env.DATABASE_URL)
         const db = drizzle(client, { schema })
         return db
      },
      exports: [DrizzleAsyncProvider],
   },
]
</file>

<file path="apps/backend/src/drizzle/schema.ts">
import { pgTable, pgEnum } from 'drizzle-orm/pg-core'
import { serial, varchar, text, integer, numeric, boolean, timestamp, unique, jsonb } from 'drizzle-orm/pg-core'

// Enum for TokenTransactions time
export const timeEnum = pgEnum('time', ['5m', '1h', '6h', '12h', '24h'])
export const dexTransactionTypeEnum = pgEnum('dex_transaction_type', ['buy', 'sell', 'add_liquidity', 'remove_liquidity', 'init_lp'])
export const primaryTokenNameEnum = pgEnum('primary_token_name', ['WSOL', 'USDC'])
export const dexNameEnum = pgEnum('dex_name', ['Raydium'])
export const authProviderEnum = pgEnum('auth_provider', ['telegram', 'discord', 'google', 'twitter'])
export const autoSellStrategyEnum = pgEnum('auto_sell_strategy', ['simple', 'grid'])

export const usersTable = pgTable('users_table', {
   id: serial('id').primaryKey(),
   createdAt: timestamp('created_at').notNull().defaultNow(),
})

export const authProvidersTable = pgTable(
   'auth_providers',
   {
      id: serial('id').primaryKey(),
      provider: authProviderEnum('provider').notNull(),
      providerId: text('provider_id').notNull(),
      userId: integer('user_id')
         .notNull()
         .references(() => usersTable.id),
   },
   (t) => ({
      unq: unique().on(t.provider, t.providerId),
   }),
)

export const userWalletsTable = pgTable('user_wallets', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletAddress: varchar('wallet_address', { length: 44 }).notNull(),
   walletPk: varchar('wallet_pk', { length: 225 }).notNull(),
   name: varchar('name', { length: 50 }).notNull(),
})

export const autoSellTable = pgTable('auto_sell', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletId: integer('wallet_id')
      .notNull()
      .references(() => userWalletsTable.id),
   tokenAddressToSell: varchar('token_address_to_sell', { length: 44 }).notNull(),
   slippage: numeric('slippage').notNull(),
   tokenAmountToSell: varchar('token_amount_to_sell', { length: 40 }).notNull(),
   strategy: autoSellStrategyEnum('strategy').notNull(),
   strategyParams: jsonb('strategy_params').notNull(),
   initialPrice: numeric('initial_price', { precision: 20, scale: 8 }).notNull(),
   createdAt: timestamp('created_at').notNull().defaultNow(),
   updatedAt: timestamp('updated_at').notNull().defaultNow(),
})

// TokenInfo Table
export const tokenPairInfo = pgTable('token_pair_info', {
   id: serial('id').primaryKey(),
   primaryTokenName: primaryTokenNameEnum('primary_token_name').notNull(),
   initialPrimaryTokenAmountInLP: numeric('initial_primary_token_in_lp').notNull(),
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(),
   initialSecondaryTokenAmountInLP: numeric('initial_secondary_token_in_lp').notNull(),
   tokenPairCreator: varchar('token_pair_creator', { length: 44 }),
   timestamp: timestamp('timestamp').notNull(),
   creationTransaction: varchar('creation_transaction', { length: 90 }).notNull(),
   verifiedDexScreener: boolean('verified_dex_screener'),
   verifiedBirdEye: boolean('verified_bird_eye'),
   dexName: dexNameEnum('dex_name').notNull(),
})

// TokenTransactions Table
export const tokenPairTransactionsTable = pgTable('token_pair_transactions', {
   id: serial('id').primaryKey(),
   tokenPairId: integer('token_pair_id').notNull(),
   time: timeEnum('time'),
   txCount: integer('tx_count'),
   volume: numeric('volume'),
   volumeInUSD: numeric('volume_in_usd'),
   uniqueWallets: integer('unique_wallets'),
   buys: integer('buys'),
   sells: integer('sells'),
   buyVolumeInUSD: numeric('buy_volume_in_usd'),
   sellVolumeInUSD: numeric('sell_volume_in_usd'),
   buyers: integer('buyers'),
   sellers: integer('sellers'),
})

export const dexTransactionsTable = pgTable('dex_transactions', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 90 }).notNull(),
   timestamp: timestamp('timestamp').notNull(),
   blockNumber: integer('block_number').notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   primaryTokenName: primaryTokenNameEnum('primary_token_address').notNull(), // WSOL or USDC
   primaryTokenAmount: numeric('primary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of WSOL or USDC
   primaryTokenPrice: numeric('primary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of WSOL or USDC
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(), // Random token
   secondaryTokenAmount: numeric('secondary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of the random token
   secondaryTokenPrice: numeric('secondary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of the random token
   transactionType: dexTransactionTypeEnum('transaction_type').notNull(), // Buy, Sell, AddLiquidity, RemoveLiquidity
   transactionValueInUsd: numeric('transaction_value_in_usd', { precision: 20, scale: 8 }).notNull(), // Value of the transaction in USD
   dexName: dexNameEnum('dex_name').notNull(), // Name of the DEX
   isUsingJupiter: boolean('is_using_jupiter').notNull(), // Whether Jupiter is used
})

export const dexTransactionsErrorsTable = pgTable('dex_transactions_errors', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 87 }).notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   error: text('error').notNull(),
   dexName: dexNameEnum('dex_name').notNull(),
})

// Relations
// export const tokenInfoRelations = relations(tokenPairInfo, ({ one, many }) => ({
//    transactions: many(tokenTransactionsTable),
// }))

// export const tokenTransactionsRelations = relations(tokenTransactionsTable, ({ one }) => ({
//    token: one(tokenPairInfo, {
//       fields: [tokenTransactionsTable.tokenAddress],
//       references: [tokenPairInfo.address],
//    }),
// }))

export type InsertUser = typeof usersTable.$inferInsert
export type SelectUser = typeof usersTable.$inferSelect

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect

export type InsertUserWallet = typeof userWalletsTable.$inferInsert
export type SelectUserWallet = typeof userWalletsTable.$inferSelect

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect
</file>

<file path="apps/backend/src/encryption/encryption.module.ts">
import { Module } from '@nestjs/common'
import { EncryptionService } from './encryption.service'

@Module({
   providers: [EncryptionService],
   exports: [EncryptionService], // Export so it can be imported by other modules
})
export class EncryptionModule {}
</file>

<file path="apps/backend/src/encryption/encryption.service.ts">
import { Injectable } from '@nestjs/common'
import * as crypto from 'crypto'

@Injectable()
export class EncryptionService {
   private masterKey: Buffer // This should be securely loaded

   constructor() {
      const masterKeyHex = process.env.MASTER_KEY
      this.masterKey = Buffer.from(masterKeyHex, 'hex')
   }

   deriveKey(userSpecificData: string) {
      const salt = crypto.createHash('sha256').update(userSpecificData).digest()
      return crypto.pbkdf2Sync(this.masterKey, salt, 10000, 32, 'sha256')
   }

   encrypt(text: string, userSpecificData: string): string {
      const key = this.deriveKey(userSpecificData)
      const iv = crypto.randomBytes(16)
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv)
      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return iv.toString('hex') + ':' + encrypted
   }

   decrypt(encryptedText: string, userSpecificData: string): string {
      const textParts = encryptedText.split(':')
      const iv = Buffer.from(textParts[0], 'hex')
      const encrypted = textParts[1]
      const key = this.deriveKey(userSpecificData)
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)
      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}
</file>

<file path="apps/backend/src/user/user.controller.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Controller, Get, Post, Body, Param, Delete, Session, UseGuards, Request } from '@nestjs/common'
import { UserService } from './user.service'
import { AuthenticatedGuard } from 'src/auth/utils/authenticated.guard'
import { BuyTokenDto } from './dto/BuyToken.dto'
import { SellTokenDto } from './dto/SellToken.dto'
import { UserInfo } from 'shared-types/src/userInfo.interface'
import { SolanaService } from 'src/blockchain/solana/solana.service'

@Controller('user')
export class UserController {
   constructor(private readonly userService: UserService, private readonly solanaService: SolanaService) {}

   @Get('status')
   @UseGuards(AuthenticatedGuard)
   status(@Request() req) {
      console.log('Here', req.user)
      return req.user
   }

   @UseGuards(AuthenticatedGuard)
   @Get('info')
   async getUserInfo(@Request() req): Promise<UserInfo> {
      const userId = req.user.id
      const user = await this.userService.findById(userId)
      const wallets = await this.userService.getWallets(user)
      const walletBalances = await this.solanaService.getBalanceForMultipleAddresses(wallets.map((wallet) => wallet.walletAddress))
      
      return {
         wallets: wallets.map((wallet) => ({
            solBalance: walletBalances[wallet.walletAddress] / 10 ** 9,
            address: wallet.walletAddress,
            name: wallet.name,
         })),
      }
   }

   @Post('buy-token')
   @UseGuards(AuthenticatedGuard)
   async buyToken(@Body() buyTokenDto: BuyTokenDto, @Request() req): Promise<void> {
      const { walletAddress, tokenAddress, solAmountIn, slippageInPercentage, prioritizationFeeLamports, autoSell } = buyTokenDto
      await this.userService.buyToken(req.user, walletAddress, tokenAddress, solAmountIn, slippageInPercentage, prioritizationFeeLamports, autoSell)
   }

   @Post('sell-token')
   @UseGuards(AuthenticatedGuard)
   async sellToken(@Body() sellTokenDto: SellTokenDto, @Request() req): Promise<void> {
      const { walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports } = sellTokenDto
      await this.userService.sellToken(req.user, walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports)
   }
}
</file>

<file path="apps/backend/src/user/user.module.ts">
import { forwardRef, Module } from '@nestjs/common'
import { UserService } from './user.service'
import { UserController } from './user.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { EncryptionModule } from 'src/encryption/encryption.module'
import { SolanaModule } from 'src/blockchain/solana/solana.module'
import { SolanaSniperModule } from 'src/blockchain/solana/sniper/solanaSniper.module'

@Module({
   imports: [EncryptionModule, SolanaModule, forwardRef(() => SolanaSniperModule)],
   controllers: [UserController],
   providers: [UserService, ...drizzleProvider],
   exports: [UserService],
})
export class UserModule {}
</file>

<file path="apps/backend/src/user/user.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Inject, Injectable } from '@nestjs/common'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { eq, and } from 'drizzle-orm'
import { EncryptionService } from 'src/encryption/encryption.service'
import { SolanaService } from 'src/blockchain/solana/solana.service'
import { InsertAutoSell } from 'shared-types/src/drizzle.types'
import { SolanaAutoSellSniperService } from 'src/blockchain/solana/sniper/solanaAutoSellSniper.service'

@Injectable()
export class UserService {
   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private encryptionService: EncryptionService,
      private solanaService: SolanaService,
      private solanaAutoSellSniperService: SolanaAutoSellSniperService,
   ) {}

   async findById(id: number): Promise<schema.SelectUser | undefined> {
      const user = await this.db.select().from(schema.usersTable).where(eq(schema.usersTable.id, id)).limit(1)
      return user[0]
   }

   async findByTelegramId(telegramId: number): Promise<schema.SelectUser | undefined> {
      const subQuery = this.db
         .select()
         .from(schema.authProvidersTable)
         .where(eq(schema.authProvidersTable.providerId, telegramId.toString()))
         .limit(1)
         .as('sq')
      const user = await this.db.select().from(schema.usersTable).leftJoin(subQuery, eq(schema.usersTable.id, subQuery.userId)).limit(1)
      return user[0] === undefined ? undefined : user[0].users_table
   }

   async create(user: schema.InsertUser, authProvider: Omit<schema.InsertAuthProvider, 'userId'>): Promise<schema.SelectUser> {
      const newUser = await this.db.transaction(async (tx) => {
         const newUser = await tx.insert(schema.usersTable).values(user).returning()
         await tx.insert(schema.authProvidersTable).values({
            providerId: authProvider.providerId,
            provider: authProvider.provider,
            userId: newUser[0].id,
         })
         const newKeyPair = this.solanaService.createNewWallet()
         const encryptedPrivateKey = this.encryptionService.encrypt(
            this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
            newUser[0].createdAt.toISOString(),
         )
         await tx.insert(schema.userWalletsTable).values({
            userId: newUser[0].id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name: 'Main Wallet',
         })
         return newUser
      })
      return newUser[0]
   }

   async createWallet(user: schema.SelectUser, name: string): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.createNewWallet()
      const encryptedPrivateKey = this.encryptionService.encrypt(
         this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
         user.createdAt.toISOString(),
      )
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name,
         })
         .returning()
      return wallet[0]
   }

   async importWalletFromPk(user: schema.SelectUser, privateKey: string, name: string): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.base58ToKeypair(privateKey)
      const encryptedPrivateKey = this.encryptionService.encrypt(privateKey, user.createdAt.toISOString())
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name,
         })
         .returning()
      return wallet[0]
   }

   async getWallets(user: schema.SelectUser): Promise<schema.SelectUserWallet[]> {
      return await this.db.select().from(schema.userWalletsTable).where(eq(schema.userWalletsTable.userId, user.id))
   }

   async getWalletByAddress(user: schema.SelectUser, walletAddress: string): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, user.id), eq(schema.userWalletsTable.walletAddress, walletAddress)))
         .limit(1)
      return wallet[0]
   }

   async getWalletById(userId: number, walletId: number): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, userId), eq(schema.userWalletsTable.id, walletId)))
         .limit(1)
      return wallet[0]
   }

   async buyToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      solAmountIn: string,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto',
      autoSell?: Omit<InsertAutoSell, 'tokenAmountToSell'>,
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)

      const tokenAmountOut = await this.solanaService.makeJupiterSwapTransaction(
         this.solanaService.knownAddresses.WSOL,
         tokenAddress,
         parseFloat(solAmountIn),
         slippageInPercentage * 100,
         this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
         prioritizationFeeLamports,
      )

      if (autoSell) {
         await this.solanaAutoSellSniperService.addAutoSellEntry({
            ...autoSell,
            tokenAmountToSell: tokenAmountOut,
            userId: user.id,
            walletId: wallet.id,
         })
      }
   }

   async sellToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      tokenAmountIn: string,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto' = 'auto',
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)

      await this.solanaService.makeJupiterSwapTransaction(
         tokenAddress,
         this.solanaService.knownAddresses.WSOL,
         parseFloat(tokenAmountIn),
         slippageInPercentage * 100,
         this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
         prioritizationFeeLamports,
      )
   }
}
</file>

<file path="packages/shared-types/src/dto/BuyToken.dto.ts">
import { InsertAutoSell } from "../drizzle.types";

export interface BuyTokenDto {
   walletAddress: string;
   tokenAddress: string;
   solAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
   autoSell?: Omit<InsertAutoSell, "tokenAmountToSell">; // Use 'any' or a more specific type if available
}
</file>

<file path="packages/shared-types/src/dto/SellToken.dto.ts">
export interface SellTokenDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
}
</file>

<file path="apps/frontend/src/components/common/BottomNavigation.svelte">
<script>
	import { Wallet, CopyPlus, Crosshair, ArrowLeftRight } from 'lucide-svelte';
	import { page } from '$app/stores';
</script>

<nav class="md:hidden text-gray-400 fixed quicksand w-screen bottom-0 bg-gray-800 flex">
	<div
		class="w-full h-full flex flex-col py-4 items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/trade'}
	>
		<ArrowLeftRight size={20} />
		<a href="/dashboard/trade">Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/sniper'}
	>
		<Crosshair size={20} />
		<a href="/dashboard/sniper">Sniper</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/copy-trade'}
	>
		<CopyPlus size={20} />
		<a href="/dashboard/copy-trade">Copy Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/wallets'}
	>
		<Wallet size={20} />
		<a href="/dashboard/wallets">Wallets</a>
	</div>
</nav>
</file>

<file path="apps/frontend/src/components/common/CopyToClipboard.svelte">
<script lang="ts">
	import { Tooltip, Button } from 'flowbite-svelte';
	import { copyToClipboard } from '$utils/copyToClipboard';
	import { FileCopyOutline } from 'flowbite-svelte-icons';

	export let text: string;
	let tooltipText = 'Copy to clipboard';

	async function handleCopy() {
		await copyToClipboard(text);
		tooltipText = 'Copied!';
		setTimeout(() => {
			tooltipText = 'Copy to clipboard';
		}, 2000); // Reset after 2 seconds
	}
</script>

<button on:click={handleCopy}>
	<FileCopyOutline class="text-gray-500 w-4 h-4" />
</button>
<Tooltip>
	<p>{tooltipText}</p>
</Tooltip>
</file>

<file path="apps/frontend/src/components/common/Navbar.svelte">
<script>
	import {
		Navbar,
		NavBrand,
		NavLi,
		NavUl,
		NavHamburger,
		Avatar,
		Dropdown,
		DropdownItem,
		DropdownHeader,
		DropdownDivider
	} from 'flowbite-svelte';
	import { page } from '$app/stores';
	$: activeUrl = $page.url.pathname;
</script>

<Navbar color="none" class="quicksand px-8 py-4 md:p-4">
	<NavBrand href="/">
		<span class="self-center logo whitespace-nowrap text-xl font-semibold audiowide dark:text-white">Sniperoo</span>
	</NavBrand>
	<div class="flex items-center md:order-2">
		<Avatar
			class="md:!w-12 md:!h-12 !bg-[#36394C] p-1 border border-[#e0e0e0] hover:cursor-pointer hover:brightness-75"
			id="avatar-menu"
			src="/dashboard/userIcon.png"
		/>
		<!-- <NavHamburger class1="w-full md:flex md:w-auto md:order-1" /> -->
	</div>
	<Dropdown placement="bottom" triggeredBy="#avatar-menu">
		<DropdownHeader>
			<span class="block text-sm">@britishculottes</span>
		</DropdownHeader>
		<DropdownItem>Referral Dashboard</DropdownItem>
		<DropdownItem>Transactions</DropdownItem>
		<DropdownItem>Settings</DropdownItem>
		<DropdownDivider />
		<DropdownItem>Sign out</DropdownItem>
	</Dropdown>
	<NavUl {activeUrl} activeClass="active">
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/trade">Trade</NavLi>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/sniper"
			>Sniper</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/copy-trade"
			>Copy Trade</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/wallets"
			>Wallets</NavLi
		>
		<!-- <NavLi class="font-bold navLi text-lg !px-4 !py-2 hover:!bg-slate-700" href="/contact">Contact</NavLi> -->
	</NavUl>
</Navbar>

<style>
	.logo {
		font-family: 'Audiowide', cursive;
		text-align: center;
		color: #00ffff;
		letter-spacing: 4px;
		text-shadow:
			0 0 5px #00ffff,
			0 0 10px #00ffff;
		animation: subtle-pulse 4s ease-in-out infinite;
		text-transform: uppercase;
	}

	:global(.navLi) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	:global(.active) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	@keyframes subtle-pulse {
		0%,
		100% {
			text-shadow:
				0 0 5px #00ffff,
				0 0 10px #00ffff;
		}
		50% {
			text-shadow:
				0 0 10px #00ffff,
				0 0 20px #00ffff;
		}
	}
</style>
</file>

<file path="apps/frontend/src/components/trade/BuyTradeForm.svelte">
<script lang="ts">
	import { Label, Input, InputAddon, ButtonGroup, Toggle, TabItem, Tabs, Select } from 'flowbite-svelte';
	import { Table, TableBody, TableBodyCell, TableBodyRow, TableHead, TableHeadCell } from 'flowbite-svelte';
	import { ArrowUpDown } from 'lucide-svelte';
	import { Button } from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { tokenPricesInUSD } from '$stores/priceStore';
	import { PUBLIC_WSOL_ADDRESS } from '$env/static/public';
	import TokenInformationModal from './TokenInformationModal.svelte';
	import { InfoCircleOutline } from 'flowbite-svelte-icons';
	import VolatileMarketProjections from './VolatileMarketProjections.svelte';
	import type { VolatileMarketStrategy } from '$lib/VolatileMarketStrategy';
	import { VolatileTokenTrader } from '$lib/VolatileMarketStrategy';
	import { formatNumber } from '$utils/formatters';

	// Types
	type ProfitTarget = {
		multiplier: number;
		sellPercentage: number;
	};

	type ProjectedNetPL = {
		targetPrice: number;
		sellPercentage: number;
		projectedNetPL: number;
	};

	type StopLossType = 'static' | 'trailing' | 'breakeven';

	// State
	let autoSellChecked = false;
	let simpleSell = {
		profitPercentage: 30,
		lossPercentage: 30
	};

	let gradualSell = {
		stopLossType: 'static' as StopLossType,
		staticStopLoss: 5,
		trailingStopLoss: 10,
		breakEvenInitialStopLoss: 0,
		profitTargets: [
			{ multiplier: 1.1, sellPercentage: 20 },
			{ multiplier: 1.3, sellPercentage: 30 },
			{ multiplier: 1.5, sellPercentage: 50 }
		]
	};

	$: initialBuyPrice = inputSolana / outputSecondaryToken;

	let inputSolana = 0;
	$: oneSolPriceInUsd = $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS]; // Use the store value
	$: oneSolInSecondaryToken = $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS] / $tokenPricesInUSD[$tokenInfo.address]; // Calculated from store value
	$: oneSecondaryTokenInSol = $tokenPricesInUSD[$tokenInfo.address] / $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS]; // Calculated from store value

	$: outputSecondaryToken = inputSolana / oneSecondaryTokenInSol;

	const solInputPresets = [0.1, 0.5, 1, 10];

	// Pure function for calculating projected net P/L
	function calculateProjectedNetPL(
		initialInvestment: number,
		initialTokens: number,
		targets: ProfitTarget[],
		stopLossType: StopLossType,
		stopLossPercentage: number
	): ProjectedNetPL[] {
		if (initialInvestment === 0 || initialTokens === 0) return [];

		const initialPrice = initialInvestment / initialTokens;
		let remainingTokens = initialTokens;
		let accumulativeProceedsFromSale = 0;
		let highestPrice = initialPrice;

		return targets.map(({ multiplier, sellPercentage }) => {
			const targetPrice = initialPrice * multiplier;
			highestPrice = Math.max(highestPrice, targetPrice);

			const tokensSold = initialTokens * (sellPercentage / 100);
			const proceedsFromSale = tokensSold * targetPrice;

			accumulativeProceedsFromSale += proceedsFromSale;
			remainingTokens -= tokensSold;

			let stopLossPrice: number;
			switch (stopLossType) {
				case 'trailing':
					stopLossPrice = highestPrice * (1 - stopLossPercentage / 100);
					break;
				case 'breakeven':
					stopLossPrice = initialPrice;
					break;
				case 'static':
				default:
					stopLossPrice = initialPrice * (1 - stopLossPercentage / 100);
			}

			const proceedsFromStopLoss = remainingTokens * stopLossPrice;
			const totalProceeds = accumulativeProceedsFromSale + proceedsFromStopLoss;
			const projectedNetPL = totalProceeds - initialInvestment;

			return {
				targetPrice,
				sellPercentage,
				projectedNetPL
			};
		});
	}

	// Reactive statement to update results
	$: results = calculateProjectedNetPL(
		inputSolana,
		outputSecondaryToken,
		gradualSell.profitTargets,
		gradualSell.stopLossType,
		gradualSell.stopLossType === 'trailing' ? gradualSell.trailingStopLoss : gradualSell.staticStopLoss
	);

	function formatValue(value: number, placeholder: string): string | undefined {
		return value === 0 ? undefined : value.toString();
	}

	function addProfitTarget() {
		gradualSell.profitTargets = [...gradualSell.profitTargets, { multiplier: 0, sellPercentage: 0 }];
	}

	function removeProfitTarget(index: number) {
		gradualSell.profitTargets = gradualSell.profitTargets.filter((_, i) => i !== index);
	}

	function onInputSolanaChange(e: Event) {
		const target = e.target as HTMLInputElement;
		inputSolana = parseFloat(target.value) || 0;
	}

	let volatileStrategy: VolatileMarketStrategy = {
		initialStopLoss: 0.15,
		quickProfitTarget: 0.5,
		trailingStopLoss: 0.2,
		volumeThreshold: 1000,
		timeBasedExit: 3600000
	};
	let trader: VolatileTokenTrader;
	let currentVolume = 1000; // This should be updated with real-time data

	$: if (inputSolana > 0) {
		trader = new VolatileTokenTrader(volatileStrategy, initialBuyPrice);
	}

	$: tradeDecision = trader ? trader.updatePrice(oneSecondaryTokenInSol, currentVolume) : 'HOLD';
</script>

<div class="w-full">
	<div>
		<div class="flex justify-between items-center mb-2">
			<Label for="input-addon" class="font-bold">You're Paying</Label>
		</div>

		<ButtonGroup class="w-full">
			<InputAddon class="pr-2">
				<div class="w-6 h-6">
					<img src="/solana-logo.png" class="rounded-full object-cover" alt="Solana" />
				</div>
			</InputAddon>
			<InputAddon class="pl-0 quicksand !text-white !font-bold">SOL</InputAddon>
			<div class="bg-gray-700">
				<Input
					id="input-addon"
					type="number"
					class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
					placeholder="0.00"
					value={formatValue(inputSolana, '0.00')}
					on:input={onInputSolanaChange}
				/>
				<p class="text-gray-400 pr-2.5 -mt-2 mb-1 text-xs font-semibold text-right">
					≈ <span class="">${(inputSolana * oneSolPriceInUsd).toFixed(2)}</span>
				</p>
			</div>

			<Button class="!bg-[#35d0de] !text-black font-bold">MAX</Button>
		</ButtonGroup>
		<div class="flex justify-between mt-3">
			{#each solInputPresets as preset}
				<button
					class="!bg-gray-700 w-full mr-2 last-of-type:mr-0 py-1 rounded-lg text-base !text-white !font-bold"
					on:click={() => (inputSolana = preset)}>{preset} SOL</button
				>
			{/each}
		</div>
	</div>
	<ArrowUpDown class="w-6 h-6 mx-auto mt-4 -mb-2 text-white" />
	<div>
		<Label for="input-addon" class="mb-2 font-bold">To Receive</Label>
		<ButtonGroup class="w-full">
			<TokenInformationModal class="flex !rounded-r-none">
				<InputAddon class="pr-2">
					<div class="w-6 h-6">
						<img src={$tokenInfo.image} class="rounded-full object-cover" alt={$tokenInfo.name} />
					</div>
				</InputAddon>
				<InputAddon class="pl-0 quicksand !rounded-r-none !text-white !font-bold"
					>{$tokenInfo.symbol} <InfoCircleOutline class="ml-1 w-4 h-4 text-gray-400" />
				</InputAddon>
			</TokenInformationModal>
			<Input
				id="input-addon"
				type="number"
				class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
				placeholder=""
				value={formatValue(outputSecondaryToken, '')}
				readonly
			/>
		</ButtonGroup>
		<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
			1 SOL ≈ {formatNumber(parseFloat(oneSolInSecondaryToken.toFixed(2)))}
			{$tokenInfo.symbol}
		</p>
	</div>
	<hr class="my-4 border-gray-600" />
	<div class="flex justify-between mt-4 bg-gray-700 p-2 rounded-lg">
		<p class="text-white font-bold">Enable Auto Sell</p>
		<Toggle
			classDiv="peer-focus:ring-0 {autoSellChecked ? '!bg-[#35d0de]' : '!bg-gray-500'}"
			bind:checked={autoSellChecked}
		/>
	</div>
	{#if autoSellChecked}
		<Tabs contentClass="mt-4" defaultClass="flex" tabStyle="underline">
			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				open
				title="Simple Auto Sell"
			>
				<div class="flex">
					<div class="mr-2">
						<Label for="first_name" class="mb-2">Profit Percentage</Label>
						<Input
							type="number"
							id="slppage"
							size="sm"
							class="text-right"
							required
							bind:value={simpleSell.profitPercentage}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
							Profit: <span class="text-white"
								>{parseFloat(((inputSolana * simpleSell.profitPercentage) / 100).toFixed(4))} SOL</span
							>
						</p>
					</div>
					<div class="ml-2">
						<Label for="last_name" class="mb-2">Loss Percentage</Label>
						<Input
							type="number"
							id="slppage"
							size="sm"
							class="text-right"
							required
							bind:value={simpleSell.lossPercentage}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
							Loss: <span class="text-white"
								>{parseFloat(((inputSolana * simpleSell.lossPercentage) / 100).toFixed(4))} SOL</span
							>
						</p>
					</div>
				</div>
			</TabItem>
			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				title="Grid Auto Sell"
			>
				<div class="mb-4">
					<Label for="stop_loss_type" class="mb-2">Stop Loss Type</Label>
					<Select id="stop_loss_type" class="mt-2" bind:value={gradualSell.stopLossType}>
						<option value="static">Static Stop Loss</option>
						<option value="trailing">Trailing Stop Loss</option>
						<option value="breakeven">Breakeven Stop Loss</option>
					</Select>
				</div>

				{#if gradualSell.stopLossType === 'static'}
					<div class="mb-4">
						<Label for="static_stop_loss" class="mb-2">Static Stop Loss Percentage</Label>
						<Input
							type="number"
							id="static_stop_loss"
							size="sm"
							class="text-right"
							required
							bind:value={gradualSell.staticStopLoss}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
							Loss: <span class="text-white"
								>{parseFloat(((inputSolana * gradualSell.staticStopLoss) / 100).toFixed(4))} SOL</span
							>
						</p>
					</div>
				{:else if gradualSell.stopLossType === 'trailing'}
					<div class="mb-4">
						<Label for="trailing_stop_loss" class="mb-2">Trailing Stop Loss Percentage</Label>
						<Input
							type="number"
							id="trailing_stop_loss"
							size="sm"
							class="text-right"
							required
							bind:value={gradualSell.trailingStopLoss}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1">
							The stop loss will always trail at {gradualSell.trailingStopLoss}% below ATH (at-the-highest) price.
						</p>
					</div>
				{:else if gradualSell.stopLossType === 'breakeven'}
					<div class="mb-4">
						<Label for="breakeven_initial_stop_loss" class="mb-2">Initial Stop Loss Percentage</Label>
						<Input
							type="number"
							id="breakeven_initial_stop_loss"
							size="sm"
							class="text-right"
							required
							bind:value={gradualSell.breakEvenInitialStopLoss}
						>
							<p slot="right">%</p>
						</Input>
						<p class="text-gray-400 text-sm mt-1">
							The stop loss will be set to the initial buying price 1 SOL ≈ {formatNumber(
								parseFloat(oneSolInSecondaryToken.toFixed(2))
							)}
							{$tokenInfo.symbol} once the first target is met.
						</p>
					</div>
				{/if}

				<p class="mb-2 text-center font-bold text-white">Profit Targets</p>

				<Table>
					<TableHead>
						<TableHeadCell class="px-0 w-1/3 text-center">Multiplier</TableHeadCell>
						<TableHeadCell class="px-0 w-1/3 text-center">Sell %</TableHeadCell>
						<TableHeadCell class="px-0 w-1/3 text-center">Projected Minimum P/L</TableHeadCell>
						<TableHeadCell class="p-0 text-center"></TableHeadCell>
					</TableHead>
					<TableBody tableBodyClass="divide-y">
						{#each gradualSell.profitTargets as target, index}
							<TableBodyRow>
								<TableBodyCell class="px-2">
									<Input type="number" size="sm" class="text-right pe-5" required bind:value={target.multiplier}>
										<p slot="right">x</p>
									</Input>
								</TableBodyCell>
								<TableBodyCell class="px-2">
									<Input type="number" size="sm" class="text-right pe-7" required bind:value={target.sellPercentage}>
										<p slot="right">%</p>
									</Input>
								</TableBodyCell>

								<TableBodyCell class="px-2">
									<p class="text-white font-bold text-center">
										{results[index]?.projectedNetPL.toFixed(4) == undefined
											? '0'
											: parseFloat(results[index]?.projectedNetPL.toFixed(4))} SOL
									</p>
								</TableBodyCell>
								<TableBodyCell class="px-2">
									<Button color="red" class="px-2" size="sm" on:click={() => removeProfitTarget(index)}>
										<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
											<path
												fill-rule="evenodd"
												d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
												clip-rule="evenodd"
											></path>
										</svg>
									</Button>
								</TableBodyCell>
							</TableBodyRow>
						{/each}
					</TableBody>
				</Table>
				<div class="mt-2 flex justify-center">
					<Button class="!bg-[#008F00] text-3xl !px-3.5 !py-1" on:click={addProfitTarget}>+</Button>
				</div>
			</TabItem>
			<!-- <TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				title="Volatile"
			>
				<div class="mb-4">
					<Label for="quick_profit" class="mb-2">Quick Profit Target (%)</Label>
					<Input
						type="number"
						id="quick_profit"
						min="0"
						step="1"
						class="text-right"
						bind:value={volatileStrategy.quickProfitTarget}
					/>
				</div>
				<div class="mb-4">
					<Label for="initial_stop_loss" class="mb-2">Initial Stop Loss (%)</Label>
					<Input
						type="number"
						id="initial_stop_loss"
						min="0"
						step="1"
						class="text-right"
						bind:value={volatileStrategy.initialStopLoss}
					/>
				</div>
				<div class="mb-4">
					<Label for="trailing_stop_loss" class="mb-2">Trailing Stop Loss (%)</Label>
					<Input
						type="number"
						id="trailing_stop_loss"
						min="0"
						step="1"
						class="text-right"
						bind:value={volatileStrategy.trailingStopLoss}
					/>
				</div>
				<div class="mb-4">
					<Label for="volume_threshold" class="mb-2">Volume Threshold</Label>
					<Input
						type="number"
						id="volume_threshold"
						min="0"
						step="1"
						class="text-right"
						bind:value={volatileStrategy.volumeThreshold}
					/>
				</div>
				<div class="mb-4">
					<Label for="time_based_exit" class="mb-2">Time-Based Exit (hours)</Label>
					<Input
						type="number"
						id="time_based_exit"
						min="0"
						step="1"
						class="text-right"
						bind:value={volatileStrategy.timeBasedExit}
						on:input={(e) => (volatileStrategy.timeBasedExit = parseFloat(e.currentTarget.value) * 3600000)}
					/>
				</div>

				<p class="text-gray-400 text-sm mb-4">
					Current Stop Loss: {trader ? trader.getCurrentStopLoss().toFixed(4) : '0'} SOL
				</p>
				<p class="text-gray-400 text-sm mb-4">
					Trade Decision: {tradeDecision}
				</p>

				<VolatileMarketProjections strategy={volatileStrategy} initialInvestment={inputSolana} />
			</TabItem> -->
		</Tabs>
	{/if}
	<Button class="w-full !bg-[#35d0de] text-black text-lg mt-6 font-bold">Place Order</Button>
</div>
</file>

<file path="apps/frontend/src/components/trade/TokenInformationModal.svelte">
<script lang="ts">
	import {
		Button,
		Modal,
		Progressbar,
		Tabs,
		TabItem,
		Table,
		TableBody,
		TableBodyCell,
		TableBodyRow,
		TableHead,
		TableHeadCell,
		Card
	} from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { formatNumber, formatUSD, formatPercentage } from '$utils/formatters';
	import { ArrowUpRightFromSquareOutline, CheckOutline, CloseOutline } from 'flowbite-svelte-icons';
	import { X, Telegram, Discord } from 'svelte-simples';
	import { Globe, Crown } from 'lucide-svelte';
	import CopyToClipboard from '$components/common/CopyToClipboard.svelte';
	import { tokenPricesInUSD } from '$stores/priceStore';

	export let open = false;

	function accountAddressToKnownName(address: string) {
		const knownAccounts: Record<string, string> = {
			'5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1': 'Raydium'
		};
		return knownAccounts[address] || `${address.slice(0, 4)}...${address.slice(-4)}`;
	}

	$: transactions = $tokenInfo.transactions.sort((a, b) => {
		const order = ['5m', '1h', '6h', '24h'];
		return order.indexOf(a.time) - order.indexOf(b.time);
	});

	$: createdOnPumpFun = $tokenInfo.socialMediaLinks.find((link) => link.platform === 'PumpFun');
</script>

<button class={$$props.class} on:click={() => (open = true)}>
	<slot />
</button>

<Modal headerClass="p-0" classBody="p-0" outsideclose bind:open size="xl" class="w-full">
	<div class="p-4 !mt-0 bg-gray-900 text-white">
		<div class="flex items-center justify-between mb-4">
			<div class="flex items-center space-x-2">
				<img src={$tokenInfo.image} alt={$tokenInfo.name} class="w-8 h-8 rounded-full" />
				<h2 class="text-base font-bold">{$tokenInfo.name} ({$tokenInfo.symbol})</h2>
			</div>
		</div>
		<Tabs contentClass="p-4 bg-gray-50 rounded-lg rounded-t-none dark:bg-gray-800 !mt-0" style="pills">
			<TabItem open title="Info">
				<div class="space-y-2">
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Address:</span>
						<span class="text-right">
							<a
								href={`https://solscan.io/token/${$tokenInfo.address}`}
								target="_blank"
								rel="noopener noreferrer"
								class="text-blue-500 hover:underline ml-2 inline-flex items-center"
							>
								{$tokenInfo.address.slice(0, 8)}...{$tokenInfo.address.slice(-4)}
							</a>
						</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Supply:</span>
						<span>{formatNumber($tokenInfo.totalSupply / 10 ** $tokenInfo.decimals)}</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Supply Value:</span>
						<span
							>{formatUSD(
								($tokenInfo.totalSupply / 10 ** $tokenInfo.decimals) * $tokenPricesInUSD[$tokenInfo.address]
							)}</span
						>
					</div>
					<!-- <div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Unique Holders:</span>
						<span>{formatNumber($tokenInfo.uniqueHolders)}</span>
					</div> -->
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Liquidity:</span>
						<span>{formatUSD($tokenInfo.totalLiquidtyInUSD)}</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Mint Authority:</span>
						{#if $tokenInfo.mintAuthority}
							<span class="text-red-500 flex items-center">
								<CloseOutline class="w-4 h-4 mr-1" /> Yes
							</span>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Freeze Authority:</span>
						{#if $tokenInfo.freezeAuthority}
							<span class="text-red-500 flex items-center">
								<CloseOutline class="w-4 h-4 mr-1" /> Yes
							</span>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Update Authority:</span>
						{#if $tokenInfo.metadataChangeAuthority}
							<a
								href={`https://solscan.io/address/${$tokenInfo.metadataChangeAuthority}`}
								target="_blank"
								rel="noopener noreferrer"
								class="text-blue-500 hover:underline ml-2 inline-flex items-center"
							>
								<span>
									{$tokenInfo.metadataChangeAuthority.slice(0, 4)}...{$tokenInfo.metadataChangeAuthority.slice(-4)}
								</span>
							</a>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Created on Pump.Fun:</span>
						<span> {createdOnPumpFun ? 'Yes' : 'No'} </span>
					</div>
					<!-- <div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Trading Platforms:</span>
						<span>{$tokenInfo.dexesBeingTradedOn.join(', ')}</span>
					</div> -->
					{#if $tokenInfo.socialMediaLinks.length > 0}
						<div class="flex justify-between items-center !mt-0 py-3 border-gray-700">
							<span class="text-sm text-gray-400">URLs:</span>
							<div class="flex space-x-2">
								{#each $tokenInfo.socialMediaLinks as link}
									<a
										href={link.url}
										target="_blank"
										rel="noopener noreferrer"
										class="text-blue-400 hover:text-blue-300"
									>
										{#if link.platform === 'Twitter'}
											<X size="20" />
										{:else if link.platform === 'Telegram'}
											<Telegram size="20" />
										{:else if link.platform === 'Discord'}
											<Discord size="20" />
										{:else if link.platform != 'PumpFun'}
											<Globe size="20" />
										{/if}
									</a>
								{/each}
							</div>
						</div>
					{/if}
				</div>
			</TabItem>
			<TabItem title="Holders">
				<div class="space-y-4">
					<div>
						<h4 class="font-semibold mb-2">Top Holders Distribution</h4>
						<div class="space-y-2">
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 5 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top5)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top5} size="h-2" color="blue" />
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 10 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top10)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top10} size="h-2" color="green" />
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 20 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top20)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top20} size="h-2" color="yellow" />
						</div>
					</div>
					<div>
						<h2 class="font-semibold mb-2">Top 20 Holders</h2>
						<Table>
							<TableHead>
								<TableHeadCell class="text-center px-2">No</TableHeadCell>
								<TableHeadCell>Address</TableHeadCell>
								<TableHeadCell class="text-right pr-2">%</TableHeadCell>
							</TableHead>
							<TableBody tableBodyClass="divide-y">
								{#each $tokenInfo.topHolders as holder, index}
									<TableBodyRow>
										{#if index === 0}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#ffc619]" /></TableBodyCell>
										{:else if index === 1}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#e5e0d1]" /></TableBodyCell>
										{:else if index === 2}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#f6c2a8]" /></TableBodyCell>
										{:else}
											<TableBodyCell class="text-center px-2">{index + 1}</TableBodyCell>
										{/if}
										<TableBodyCell class="flex items-center">
											<CopyToClipboard text={holder.address} />
											<a
												href={`https://solscan.io/address/${holder.address}`}
												target="_blank"
												rel="noopener noreferrer"
												class="text-blue-500 hover:underline ml-1"
											>
												{accountAddressToKnownName(holder.address)}
											</a>
										</TableBodyCell>
										<TableBodyCell class="text-right pr-2"
											>{formatPercentage(holder.percentageOfTotalSupply)}</TableBodyCell
										>
									</TableBodyRow>
								{/each}
							</TableBody>
						</Table>
					</div>
				</div>
			</TabItem>
			<!-- <TabItem title="Transactions">
				<div class="space-y-4">
					<h4 class="font-semibold mb-2">Transaction Data</h4>

					<div class="md:hidden space-y-4">
						{#each transactions as tx}
							<Card>
								<h5 class="mb-2 text-lg font-bold">{tx.time} Data</h5>
								<div class="grid grid-cols-2 gap-2 text-sm">
									<div>Transactions: {tx.txCount}</div>
									<div>Volume: {formatNumber(tx.volume)} {$tokenInfo.symbol}</div>
									<div>Volume (USD): {formatUSD(tx.volumeInUSD)}</div>
									<div>Unique Wallets: {tx.uniqueWallets}</div>
									<div>Buys: {tx.buys}</div>
									<div>Sells: {tx.sells}</div>
									<div class="bg-gray-800 p-3 rounded">
										<div class="text-gray-400 text-xs">VOLUME</div>
										<div class="text-white text-2xl font-bold">{formatUSD(tx.volumeInUSD)}</div>
										<div class="flex justify-between text-sm">
											<span class="text-green-400">{formatUSD(tx.buyVolumeInUSD)}</span>
											<span class="text-red-400">{formatUSD(tx.sellVolumeInUSD)}</span>
										</div>
										<div class="w-full bg-gray-700 rounded-full h-1.5 mt-1">
											<div
												class="bg-green-400 h-1.5 rounded-full"
												style="width: {(tx.buyVolumeInUSD / tx.volumeInUSD) * 100}%"
											></div>
										</div>
									</div>
								</div>
							</Card>
						{/each}
					</div>

					<div class="hidden md:block">
						<Table>
							<TableHead>
								<TableHeadCell>Time</TableHeadCell>
								<TableHeadCell>Transactions</TableHeadCell>
								<TableHeadCell>Volume</TableHeadCell>
								<TableHeadCell>Volume (USD)</TableHeadCell>
								<TableHeadCell>Buys/Sells</TableHeadCell>
								<TableHeadCell>Buy/Sell Volume</TableHeadCell>
							</TableHead>
							<TableBody>
								{#each transactions as tx}
									<TableBodyRow>
										<TableBodyCell>{tx.time}</TableBodyCell>
										<TableBodyCell>{tx.txCount}</TableBodyCell>
										<TableBodyCell>{formatNumber(tx.volume)} {$tokenInfo.symbol}</TableBodyCell>
										<TableBodyCell>{formatUSD(tx.volumeInUSD)}</TableBodyCell>
										<TableBodyCell>{tx.buys}/{tx.sells}</TableBodyCell>
										<TableBodyCell>{formatUSD(tx.buyVolumeInUSD)}/{formatUSD(tx.sellVolumeInUSD)}</TableBodyCell>
									</TableBodyRow>
								{/each}
							</TableBody>
						</Table>
					</div>
				</div>
			</TabItem> -->
		</Tabs>
	</div>
</Modal>
</file>

<file path="apps/frontend/src/components/trade/TradeForm.svelte">
<script lang="ts">
	import BuyTradeForm from '$components/trade/BuyTradeForm.svelte';
	import { Tabs, TabItem } from 'flowbite-svelte';
	import { Input, Label, Button } from 'flowbite-svelte';
	import { SearchOutline, FileCopyOutline } from 'flowbite-svelte-icons';
	import { AccordionItem, Accordion, Modal, Spinner } from 'flowbite-svelte';
	import { Checkbox } from 'flowbite-svelte';
	import {
		Table,
		TableBody,
		TableBodyCell,
		TableBodyRow,
		TableHead,
		TableHeadCell,
		TableSearch
	} from 'flowbite-svelte';
	import { Toast } from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { tokenService } from '$services/tokenService';
	import { copyToClipboard } from '$utils/copyToClipboard';
	import { userInfo} from '$stores/userStore';

	const wallets = $userInfo.wallets.map((wallet) => ({
		...wallet,
		checked: false,
		modalOpen: false,
		searchTerm: '',
		tokenHoldings: []
	}));

	let slippageModal = false;
	let slippage = 5;

	$: filteredTokenHoldings = (
		/** @type {{ tokenHoldings: any[]; searchTerm: string; }} */ wallet: { tokenHoldings: any[]; searchTerm: string }
	) => {
		return wallet.tokenHoldings.filter((token: { name: string }) =>
			token.name.toLowerCase().includes(wallet.searchTerm.toLowerCase())
		);
	};

	let showToast = false;
	let toastMessage = '';

	function searchTokenInputChanged(e: Event) {
		tokenService.reset();

		const target = e.target as HTMLInputElement;
		const tokenAddress = target.value;
		console.log(tokenAddress.length);
		if (tokenAddress.length >= 40) {
			tokenService.fetchTokenInfo(tokenAddress);
		}
	}
</script>

<section class="bg-gray-800 quicksand rounded-lg p-4">
	<div class="flex justify-between items-center mb-4">
		<h2 class="text-2xl pl-5 text-white font-bold text-center">Trade</h2>
		<button class="bg-gray-600 text-white text-sm px-2 rounded-lg font-semibold" on:click={() => (slippageModal = true)}
			>Slippage: {slippage}%</button
		>
	</div>

	<Accordion>
		<AccordionItem paddingDefault="p-0" class="h-12 rounded-lg px-5">
			<span slot="header" class="text-white font-bold">Wallets</span>
			{#each wallets as wallet}
				<div class="flex p-2 justify-between w-full">
					<Checkbox name="wallets" bind:checked={wallet.checked} class="p-1 text-[#35d0de] focus:ring-0" />
					<div class="flex w-full items-center justify-between">
						<div class="flex items-center">
							<p class="text-white font-bold">
								{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}..` : wallet.name}
							</p>

							<p class="ml-1 flex items-center">
								(<button on:click={() => copyToClipboard(wallet.address)} class="">
									<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
								</button>{wallet.address.length > 4 ? `${wallet.address.substring(0, 4)}..` : wallet.address})
							</p>

							<p class="text-white font-bold text-sm ml-2">{parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
						</div>
					</div>
					<button
						class=" px-2 py-1 bg-[#35d0de] text-sm rounded-lg text-black font-bold"
						on:click={() => (wallet.modalOpen = true)}>View</button
					>
				</div>
				<Modal title="Token Holdings" bind:open={wallet.modalOpen} autoclose outsideclose={true}>
					<div class="flex items-center justify-center">
						<p>Wallet:</p>
						<p class="text-white ml-2 font-bold">
							{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}...` : wallet.name}
						</p>
						<p class="ml-1 flex items-center text-gray-400">
							(<button on:click={() => copyToClipboard(wallet.address)} class="">
								<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
							</button>{wallet.address.length > 5 ? `${wallet.address.substring(0, 5)}...` : wallet.address})
						</p>
						<p class="text-white font-bold ml-2">- {parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
					</div>
					<TableSearch
						inputClass="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 ps-10 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
						placeholder="Search by token name"
						hoverable={true}
						bind:inputValue={wallet.searchTerm}
					>
						<TableHead>
							<TableHeadCell>Token</TableHeadCell>
							<TableHeadCell>Balance</TableHeadCell>
						</TableHead>
						<TableBody tableBodyClass="divide-y">
							{#each filteredTokenHoldings(wallet) as token}
								<TableBodyRow>
									<TableBodyCell class="pr-0">
										<div class="text-white flex items-center">
											<p class="font-bold">{token.name}</p>
											<span class="flex ml-1 text-gray-400 items-center">
												(<button on:click={() => copyToClipboard(wallet.address)} class="">
													<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
												</button>{token.address.length > 5 ? `${token.address.substring(0, 5)}...` : token.address})
											</span>
										</div>
									</TableBodyCell>
									<TableBodyCell>{token.balance}</TableBodyCell>
								</TableBodyRow>
							{/each}
						</TableBody>
					</TableSearch>
				</Modal>
			{/each}
		</AccordionItem>
	</Accordion>
	<form class="mb-6 mt-4">
		<Input
			id="search"
			on:input={searchTokenInputChanged}
			class="!bg-gray-700"
			placeholder="Paste token address"
			size="lg"
		>
			<SearchOutline slot="left" class="w-6 h-6 text-gray-500  dark:text-gray-400" />
		</Input>
	</form>
	{#if $tokenInfo.name !== ''}
		<Tabs
			tabStyle="full"
			contentClass="rounded-lg mt-4 bg-gray-800"
			defaultClass="flex bg-gray-700 rounded-lg quicksand"
		>
			<TabItem
				activeClasses="bg-[#008F00]"
				inactiveClasses="bg-gray-700"
				defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
				class="w-full"
				open
			>
				<span slot="title">Buy</span>
				<BuyTradeForm />
			</TabItem>
			<TabItem
				activeClasses="bg-[#B30000]"
				inactiveClasses="bg-gray-700"
				defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
				class="w-full"
			>
				<span slot="title">Sell</span>
				<p class="text-sm text-gray-500 dark:text-gray-400">
					<b>Dashboard:</b>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna
					aliqua.
				</p>
			</TabItem>
		</Tabs>
	{:else if tokenService.loading}
		<div class="text-center"><Spinner /></div>
	{/if}
</section>

{#if showToast}
	<Toast class="!bg-white" position="top-left" on:close={() => (showToast = false)}>
		<p class="!text-black !font-bold quicksand !text-xl">{toastMessage}</p>
	</Toast>
{/if}

<Modal title="Swap Slippage Tolerance" bind:open={slippageModal} autoclose>
	<div class="flex items-center justify-between">
		<div class="w-3/4">
			<p>Custom slippage</p>
		</div>
		<div class="w-1/4">
			<Input type="number" id="slppage" size="sm" class="text-right pe-6" required bind:value={slippage}>
				<p slot="right">%</p>
			</Input>
		</div>
	</div>
	<Button class="w-full !bg-[#35d0de] text-black font-bold">Save</Button>
</Modal>
</file>

<file path="apps/frontend/src/components/trade/VolatileMarketProjections.svelte">
<script lang="ts">
	import { Table, TableBody, TableBodyCell, TableBodyRow, TableHead, TableHeadCell } from 'flowbite-svelte';
	import type { VolatileMarketStrategy, Projection } from '$lib/VolatileMarketStrategy';
	import { calculateProjections } from '$lib/VolatileMarketStrategy';

	export let strategy: VolatileMarketStrategy;
	export let initialInvestment: number;

	$: projections = calculateProjections(strategy, initialInvestment);
</script>

<div class="mt-6">
	<h3 class="text-xl font-bold mb-4">Potential Outcomes</h3>
	<Table hoverable={true}>
		<TableHead>
			<TableHeadCell>Scenario</TableHeadCell>
			<TableHeadCell>Profit/Loss (SOL)</TableHeadCell>
			<TableHeadCell>Profit/Loss (%)</TableHeadCell>
		</TableHead>
		<TableBody>
			{#each projections as projection}
				<TableBodyRow>
					<TableBodyCell>{projection.scenario}</TableBodyCell>
					<TableBodyCell class={projection.profitLoss >= 0 ? 'text-green-500' : 'text-red-500'}>
						{projection.profitLoss.toFixed(2)} SOL
					</TableBodyCell>
					<TableBodyCell class={projection.profitLossPercentage >= 0 ? 'text-green-500' : 'text-red-500'}>
						{projection.profitLossPercentage.toFixed(2)}%
					</TableBodyCell>
				</TableBodyRow>
			{/each}
		</TableBody>
	</Table>
</div>
</file>

<file path="apps/frontend/src/routes/dashboard/+layout.server.ts">
import { redirect } from '@sveltejs/kit';
import type { UserInfo } from 'shared-types/src/userInfo.interface';
import { PUBLIC_BACKEND_URL } from '$env/static/public';

import type { LayoutServerLoad } from './$types';
export const load: LayoutServerLoad = async ({ fetch, cookies }) => {
	let response;
	try {
		response = await fetch(PUBLIC_BACKEND_URL + '/user/info', {
			credentials: 'include',
			headers: {
				Cookie: 'connect.sid=' + cookies.get('connect.sid')
			}
		});
	} catch (error) {
		if (error instanceof Response) {
			// This is a redirect, so we just throw it
			throw error;
		}
		console.error('Error loading user info:', error);
		return {
			status: 500,
			error: new Error('Failed to load user info')
		};
	}

	if (!response.ok) {
		redirect(302, `/login`);
	}

	const userInfo: UserInfo = await response.json();
	return { userInfo };
};
</file>

<file path="apps/frontend/src/routes/dashboard/+layout.svelte">
<script lang="ts">
	import BottomNavigation from '$components/common/BottomNavigation.svelte';
	import Navbar from '$components/common/Navbar.svelte';
	import '../../app.css';
	import { onMount } from 'svelte';
	import { userInfo } from '$stores/userStore';
	import type { PageData } from './$types';

	export let data: PageData;

	onMount(() => {
		if (data.userInfo) {
			userInfo.set(data.userInfo);
		}
	});

	$: console.log(data);
</script>

<main class="px-4 pb-40">
	<Navbar />
	<slot />
</main>
<BottomNavigation />
</file>

<file path="apps/frontend/src/routes/dashboard/+page.svelte">
<script lang="ts">
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import axios from 'axios';
	import type { BuyTokenDto } from 'shared-types/src/dto/BuyToken.dto';
	import type { SellTokenDto } from 'shared-types/src/dto/SellToken.dto';

	async function buyTokens() {
		const buyTokenDto: BuyTokenDto = {
			solAmountIn: '20000000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump',
			autoSell: {
				userId: 6,
				walletId: 1,
				solAmountProfitTrigger: '23000000',
				solAmountLossTrigger: '17000000',
				slippage: '15',
				tokenAddressToSell: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
			}
		};
		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/buy-token', buyTokenDto, {
			withCredentials: true
		});
	}

	async function sellTokens() {
		const sellTokenDto: SellTokenDto = {
			tokenAmountIn: '3574930000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
		};

		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/sell-token', sellTokenDto, {
			withCredentials: true
		});
	}
</script>

<h1>WELCOME TO THE DASHBOARD</h1>

<button on:click={buyTokens}>Buy Tokens!!!</button>

<button on:click={sellTokens}>Sell Tokens!!!</button>
</file>

<file path="apps/frontend/src/routes/login/+page.svelte">
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
</script>

<div class="w-screen h-screen flex">
	<div class="hidden w-full h-full bg-[#005952] md:block"></div>
	<div class="h-screen w-full bg-black relative">
		<div class="h-screen w-full overflow-hidden absolute">
			<img src="login/dark_pattern.jpg" alt="dark_pattern" class="w-full h-screen object-cover" />
		</div>
		<div class="absolute w-full text-center top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
			<h1 class="text-4xl text-white font-bold manrope">Sniperoo</h1>
			<h2 class="text-2xl text-green-600 mt-4 font-bold manrope">Welcome to Sniperoo</h2>
			<p class="text-base mt-4 text-white manrope">The Automated Trading Platform</p>
			<div class="mt-12"><TelegramLoginWidget /></div>
			<div class="mt-6 flex items-center justify-center">
				<img src="login/login_with_google.png" alt="login_with_google" class="w-50" />
			</div>
			<p class="text-white text-xs mt-8 manrope">
				By proceeding, you agree to these <br />
				<a href="/terms_and_conditions" class="underline font-bold">Terms and Conditions.</a>
			</p>
		</div>
	</div>
</div>
</file>

<file path="apps/backend/src/auth/strategies/jwt.tstrategy.ts">
import { Injectable } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { Strategy, ExtractJwt } from 'passport-jwt'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
   constructor() {
      super({
         jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
         ignoreExpiration: false,
         secretOrKey: 'your_jwt_secret', // Store this in an environment variable
      })
   }

   async validate(payload: any) {
      return { userId: payload.sub, username: payload.username }
   }
}
</file>

<file path="apps/backend/src/auth/strategies/SessionSerializer.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable } from '@nestjs/common'
import { PassportSerializer } from '@nestjs/passport'
import { SelectUser } from 'src/drizzle/schema'
import { UserService } from 'src/user/user.service'

@Injectable()
export class SessionSerializer extends PassportSerializer {
   constructor(private userService: UserService) {
      super()
   }
   serializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      console.log('serializeUser', user)
      done(null, user)
   }

   async deserializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      const userDB = await this.userService.findById(user.id)
      console.log('deserializeUser', userDB)
      return userDB ? done(null, userDB) : done(null, null)
   }
}
</file>

<file path="apps/backend/src/auth/strategies/telegram.strategy.ts">
import { PassportStrategy } from '@nestjs/passport'
import { Strategy } from 'passport-custom'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import * as crypto from 'crypto'
import { AuthService } from '../auth.service'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { SelectUser } from 'src/drizzle/schema'
import { Request } from 'express'

@Injectable()
export class TelegramStrategy extends PassportStrategy(Strategy, 'telegram') {
   constructor(private authService: AuthService) {
      super()
   }

   async validate(request: Request): Promise<SelectUser> {
      const telegramAuthData: TelegramAuthData = request.body
      const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN

      if (!TELEGRAM_BOT_TOKEN) {
         throw new UnauthorizedException('Bot token is not set.')
      }

      const { hash, ...authDataWithoutHash } = telegramAuthData
      const dataCheckArray: string[] = []

      for (const [key, value] of Object.entries(authDataWithoutHash)) {
         dataCheckArray.push(`${key}=${value}`)
      }
      dataCheckArray.sort()

      const dataCheckString = dataCheckArray.join('\n')
      const secretKey = crypto.createHash('sha256').update(TELEGRAM_BOT_TOKEN).digest()

      const computedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex')

      if (computedHash !== hash) {
         throw new UnauthorizedException('Data is NOT from Telegram')
      }

      if (Date.now() / 1000 - authDataWithoutHash.auth_date > 86400) {
         throw new UnauthorizedException('Data is outdated')
      }

      return await this.authService.validateTelegramUser(telegramAuthData)
   }
}
</file>

<file path="apps/backend/src/auth/utils/authenticated.guard.ts">
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'

@Injectable()
export class AuthenticatedGuard implements CanActivate {
   canActivate(context: ExecutionContext) {
      const request = context.switchToHttp().getRequest()
      return request.isAuthenticated()
   }
}
</file>

<file path="apps/backend/src/auth/utils/telegram.guard.ts">
import { ExecutionContext, Injectable } from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'

@Injectable()
export class TelegramGuard extends AuthGuard('telegram') {
   constructor() {
      super()
   }

   async canActivate(context: ExecutionContext): Promise<boolean> {
      const result: boolean = (await super.canActivate(context)) as boolean
      await super.logIn(context.switchToHttp().getRequest())
      return result
   }
}
</file>

<file path="apps/backend/src/common/helpers/convertDexscreenerData.ts">
import { Pair } from '../interfaces/dexscreenerData.interface'
import { TokenTransactions } from 'shared-types/src/tokenInfo.interface'

export function convertPairToTokenTransactions(pair: Pair): TokenTransactions[] {
   const transactions: TokenTransactions[] = [
      {
         time: '5m',
         txCount: `${pair.txns.m5.buys + pair.txns.m5.sells}`,
         volume: pair.volume.m5,
         volumeInUSD: pair.volume.m5 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder, real calculation requires additional data
         buys: pair.txns.m5.buys,
         sells: pair.txns.m5.sells,
         buyVolumeInUSD: pair.txns.m5.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.m5.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '1h',
         txCount: `${pair.txns.h1.buys + pair.txns.h1.sells}`,
         volume: pair.volume.h1,
         volumeInUSD: pair.volume.h1 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h1.buys,
         sells: pair.txns.h1.sells,
         buyVolumeInUSD: pair.txns.h1.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h1.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '6h',
         txCount: `${pair.txns.h6.buys + pair.txns.h6.sells}`,
         volume: pair.volume.h6,
         volumeInUSD: pair.volume.h6 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h6.buys,
         sells: pair.txns.h6.sells,
         buyVolumeInUSD: pair.txns.h6.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h6.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '24h',
         txCount: `${pair.txns.h24.buys + pair.txns.h24.sells}`,
         volume: pair.volume.h24,
         volumeInUSD: pair.volume.h24 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h24.buys,
         sells: pair.txns.h24.sells,
         buyVolumeInUSD: pair.txns.h24.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h24.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
   ]

   return transactions
}

export function getPairWithMostLiquidity(pairs: Pair[]): Pair | undefined {
   if (pairs.length === 0) return undefined

   // Find the first pair with defined liquidity to start the comparison.
   let maxLiquidityPair: Pair | undefined = pairs.find((pair) => pair.liquidity !== undefined)

   // If no pair has liquidity data, return undefined or the first pair.
   if (!maxLiquidityPair) {
      return pairs[0] // Or return pairs[0] if you prefer to return the first pair by default.
   }

   // Start the loop from the pair after the initial max liquidity pair found
   const startIndex = pairs.indexOf(maxLiquidityPair) + 1

   for (let i = startIndex; i < pairs.length; i++) {
      if (pairs[i].liquidity && pairs[i].liquidity.usd > maxLiquidityPair.liquidity.usd) {
         maxLiquidityPair = pairs[i]
      }
   }

   return maxLiquidityPair
}

export function calculateTotalLiquidityInUsd(pairs: Pair[]): number {
   return pairs.reduce((total, pair) => {
      const liquidity = pair.liquidity?.usd || 0
      return total + liquidity
   }, 0)
}

export function getAllUniqueDexIds(pairs: Pair[]): string[] {
   return [...new Set(pairs.map((pair) => pair.dexId))]
}
</file>

<file path="apps/backend/src/common/helpers/getSignature.ts">
import * as bs58 from 'bs58'
import { Transaction, VersionedTransaction } from '@solana/web3.js'

export function getSignature(transaction: Transaction | VersionedTransaction): string {
   const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0]
   if (!signature) {
      throw new Error('Missing transaction signature, the transaction was not signed by the fee payer')
   }
   return bs58.encode(signature)
}
</file>

<file path="apps/backend/src/common/helpers/sleep.ts">
export async function sleep(ms: number): Promise<void> {
   return new Promise((resolve) => setTimeout(resolve, ms))
}
</file>

<file path="apps/backend/src/common/helpers/transactionSender.ts">
import { BlockhashWithExpiryBlockHeight, Connection, TransactionExpiredBlockheightExceededError, VersionedTransactionResponse } from '@solana/web3.js'
import * as promiseRetry from 'promise-retry'
import { sleep } from './sleep'

type TransactionSenderAndConfirmationWaiterArgs = {
   connection: Connection
   serializedTransaction: Buffer
   blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight
}

export async function transactionSenderAndConfirmationWaiter({
   connection,
   serializedTransaction,
   blockhashWithExpiryBlockHeight,
}: TransactionSenderAndConfirmationWaiterArgs): Promise<VersionedTransactionResponse | null> {
   const txid = await connection.sendRawTransaction(serializedTransaction, {
      skipPreflight: true,
   })

   const controller = new AbortController()
   const abortSignal = controller.signal

   const abortableResender = async () => {
      while (true) {
         await sleep(2_000)
         if (abortSignal.aborted) return
         try {
            await connection.sendRawTransaction(serializedTransaction)
         } catch (e) {
            console.warn(`Failed to resend transaction: ${e}`)
         }
      }
   }

   try {
      abortableResender()
      const lastValidBlockHeight = blockhashWithExpiryBlockHeight.lastValidBlockHeight - 150

      // this would throw TransactionExpiredBlockheightExceededError
      await Promise.race([
         connection.confirmTransaction(
            {
               ...blockhashWithExpiryBlockHeight,
               lastValidBlockHeight,
               signature: txid,
               abortSignal,
            },
            'confirmed',
         ),
         new Promise(async (resolve) => {
            // in case ws socket died
            while (!abortSignal.aborted) {
               await sleep(2_000)
               const tx = await connection.getSignatureStatus(txid, {
                  searchTransactionHistory: false,
               })
               if (tx?.value?.confirmationStatus === 'confirmed') {
                  resolve(tx)
               }
            }
         }),
      ])
   } catch (e) {
      if (e instanceof TransactionExpiredBlockheightExceededError) {
         // we consume this error and getTransaction would return null
         return null
      } else {
         // invalid state from web3.js
         throw e
      }
   } finally {
      controller.abort()
   }

   // in case rpc is not synced yet, we add some retries
   const response = promiseRetry(
      async (retry) => {
         const response = await connection.getTransaction(txid, {
            commitment: 'confirmed',
            maxSupportedTransactionVersion: 0,
         })
         if (!response) {
            retry(response)
         }
         return response
      },
      {
         retries: 5,
         minTimeout: 1e3,
      },
   )

   return response
}
</file>

<file path="apps/backend/src/common/interfaces/blockchain.interface.ts">
export interface BlockchainInterface {
   connect(): any
   getBalance(address: string): Promise<number>
   sendTransaction(transactionDetails: any): Promise<any>
}
</file>

<file path="apps/backend/src/common/interfaces/dexscreenerData.interface.ts">
export interface DexScreenerResponse {
   schemaVersion: string
   pairs: Pair[]
}

export interface Pair {
   chainId: string
   dexId: string
   url: string
   pairAddress: string
   labels?: string[]
   baseToken: Token
   quoteToken: Token
   priceNative: string
   priceUsd: string
   txns: Transactions
   volume: Volume
   priceChange: PriceChange
   liquidity: Liquidity
   fdv: number
   pairCreatedAt: number
   info?: Info
}

interface Token {
   address: string
   name: string
   symbol: string
}

interface Transactions {
   m5: TransactionDetail
   h1: TransactionDetail
   h6: TransactionDetail
   h24: TransactionDetail
}

interface TransactionDetail {
   buys: number
   sells: number
}

interface Volume {
   h24: number
   h6: number
   h1: number
   m5: number
}

interface PriceChange {
   m5: number
   h1: number
   h6: number
   h24: number
}

interface Liquidity {
   usd: number
   base: number
   quote: number
}

interface Info {
   imageUrl: string
   websites: Website[]
   socials: Social[]
}

interface Website {
   label: string
   url: string
}

interface Social {
   url: string
   type: string
}
</file>

<file path="apps/backend/src/blockchain/solana/solana.controller.ts">
import { Controller, Get, Query } from '@nestjs/common'
import { SolanaService } from './solana.service'

@Controller('solana')
export class SolanaController {
   constructor(private readonly solanaService: SolanaService) {}

   @Get('price')
   async findPrices(@Query('tokenAddresses') tokenAddresses: string, @Query('vsToken') vsToken: string) {
      const tokenArray = tokenAddresses.split(',')
      return await this.solanaService.getPriceForMultipleTokens(tokenArray, vsToken)
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/solana.module.ts">
import { Module } from '@nestjs/common'
import { SolanaService } from './solana.service'
import { SolanaTokenModule } from './token/solanaToken.module'
import { SolanaController } from './solana.controller'

@Module({
   imports: [SolanaTokenModule],
   providers: [SolanaService],
   controllers: [SolanaController],
   exports: [SolanaService],
})
export class SolanaModule {}
</file>

<file path="apps/backend/src/blockchain/solana/solana.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { BlockchainInterface } from 'src/common/interfaces/blockchain.interface'
import {
   Connection,
   PublicKey,
   Keypair,
   TransactionInstruction,
   AddressLookupTableAccount,
   TransactionMessage,
   VersionedTransaction,
   SystemProgram,
   TokenBalance,
   LAMPORTS_PER_SOL,
} from '@solana/web3.js'
import { createUmi } from '@metaplex-foundation/umi-bundle-defaults'
import { Umi } from '@metaplex-foundation/umi'
import * as bs58 from 'bs58'
import axios from 'axios'
import { transactionSenderAndConfirmationWaiter } from 'src/common/helpers/transactionSender'
import { getSignature } from 'src/common/helpers/getSignature'
import * as fs from 'fs'
import { JupiterPriceReponse } from 'shared-types/src/JupiterPriceResponse.interface'

export class SolanaService implements BlockchainInterface {
   public quickNodeConnection: Connection = new Connection(
      'https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/',
   )
   public defaultSolanaConnection: Connection = new Connection('https://api.mainnet-beta.solana.com/')
   public umi: Umi = createUmi('https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/')
   public juputerSwapURL: string = 'https://quote-api.jup.ag/v6'
   public jupiterPriceURL: string = 'https:///price.jup.ag/v6'

   public feeReceiverData = { feePercentage: process.env.FEE_PERCENTAGE, feeReceiver: new PublicKey(process.env.FEE_ACCOUNT_ADDRESS) }

   public knownAddresses = {
      WSOL: 'So11111111111111111111111111111111111111112',
   }

   connect() {
      // Implementation details
   }

   createNewWallet() {
      return Keypair.generate()
   }

   base58ToKeypair(base58PrivateKey: string): Keypair {
      try {
         const privateKeyBuffer = bs58.decode(base58PrivateKey)
         return Keypair.fromSecretKey(privateKeyBuffer)
      } catch (error) {
         throw new Error('Invalid base58 private key.')
      }
   }

   privateKeyToBase58(privateKey: Uint8Array): string {
      return bs58.encode(privateKey)
   }

   async getBalance(address: string): Promise<number> {
      const publicKey = new PublicKey(address)
      return this.quickNodeConnection.getBalance(publicKey)
   }

   async getBalanceForMultipleAddresses(addresses: string[]): Promise<{
      [key: string]: number
   }> {
      const publicKeys = addresses.map((address) => new PublicKey(address))
      const accountsInfo = await this.quickNodeConnection.getMultipleAccountsInfo(publicKeys)
      return accountsInfo.reduce((acc, accountInfo, index) => {
         const publicKey = publicKeys[index]
         if (accountInfo) {
            acc[publicKey.toBase58()] = accountInfo.lamports
         } else {
            acc[publicKey.toBase58()] = 0
         }

         return acc
      }, {})
   }

   async sendTransaction(transactionDetails: any): Promise<any> {
      // Implementation details
   }

   async makeJupiterSwapTransaction(
      inputMint: string,
      outputMint: string,
      inputAmount: number,
      slippageBps: number,
      wallet: Keypair,
      prioritizationFeeLamports: number | 'auto',
   ): Promise<any> {
      console.time('fetchJupiterData')
      const quoteResponse = await axios.get(`${this.juputerSwapURL}/quote`, {
         params: {
            inputMint,
            outputMint,
            amount: inputAmount,
            slippageBps,
         },
      })

      console.log('Quote response: ', quoteResponse.data)

      const instructions = await axios.post(
         `${this.juputerSwapURL}/swap-instructions`,
         {
            userPublicKey: wallet.publicKey.toBase58(),
            quoteResponse: quoteResponse.data,
            dynamicComputeUnitLimit: true,
            prioritizationFeeLamports: prioritizationFeeLamports,
         },
         {
            headers: {
               'Content-Type': 'application/json',
            },
         },
      )
      console.timeEnd('fetchJupiterData')

      const {
         tokenLedgerInstruction, // If you are using `useTokenLedger = true`.
         computeBudgetInstructions, // The necessary instructions to setup the compute budget.
         setupInstructions, // Setup missing ATA for the users.
         swapInstruction: swapInstructionPayload, // The actual swap instruction.
         cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.
         addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
      } = instructions.data

      const deserializeInstruction = (instruction) => {
         return new TransactionInstruction({
            programId: new PublicKey(instruction.programId),
            keys: instruction.accounts.map((key) => ({
               pubkey: new PublicKey(key.pubkey),
               isSigner: key.isSigner,
               isWritable: key.isWritable,
            })),
            data: Buffer.from(instruction.data, 'base64'),
         })
      }

      const getAddressLookupTableAccounts = async (keys: string[]): Promise<AddressLookupTableAccount[]> => {
         const addressLookupTableAccountInfos = await this.quickNodeConnection.getMultipleAccountsInfo(keys.map((key) => new PublicKey(key)))

         return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
            const addressLookupTableAddress = keys[index]
            if (accountInfo) {
               const addressLookupTableAccount = new AddressLookupTableAccount({
                  key: new PublicKey(addressLookupTableAddress),
                  state: AddressLookupTableAccount.deserialize(accountInfo.data),
               })
               acc.push(addressLookupTableAccount)
            }

            return acc
         }, new Array<AddressLookupTableAccount>())
      }

      const addressLookupTableAccounts: AddressLookupTableAccount[] = []
      addressLookupTableAccounts.push(...(await getAddressLookupTableAccounts(addressLookupTableAddresses)))

      const blockhash = await this.quickNodeConnection.getLatestBlockhash()

      const allInstructions = [
         ...computeBudgetInstructions.map(deserializeInstruction),
         ...setupInstructions.map(deserializeInstruction),
         deserializeInstruction(swapInstructionPayload),
         deserializeInstruction(cleanupInstruction),
      ]

      let feeAmountLamports

      if (inputMint === this.knownAddresses.WSOL) {
         // Calculate 0.8% of the input amount
         feeAmountLamports = Math.floor(inputAmount * 0.008)
      } else if (outputMint === this.knownAddresses.WSOL) {
         // Extract output amount from quoteResponse data (assuming it is available)
         const outputAmount = quoteResponse.data.outAmount // Adjust this based on actual data structure
         feeAmountLamports = Math.floor(outputAmount * 0.008)
      }

      const feeTransferInstruction = SystemProgram.transfer({
         fromPubkey: wallet.publicKey,
         toPubkey: this.feeReceiverData.feeReceiver,
         lamports: feeAmountLamports,
      })
      allInstructions.push(feeTransferInstruction)

      const messageV0 = new TransactionMessage({
         payerKey: wallet.publicKey,
         recentBlockhash: blockhash.blockhash,
         instructions: allInstructions,
      }).compileToV0Message(addressLookupTableAccounts)

      const transaction = new VersionedTransaction(messageV0)
      transaction.sign([wallet])

      const signature = getSignature(transaction)

      // console.time('simulateTransaction')
      // const { value: simulatedTransactionResponse } = await this.quickNodeConnection.simulateTransaction(transaction, {
      //    replaceRecentBlockhash: true,
      //    commitment: 'processed',
      // })
      // const { err, logs } = simulatedTransactionResponse

      // if (err) {
      //    // Simulation error, we can check the logs for more details
      //    // If you are getting an invalid account error, make sure that you have the input mint account to actually swap from.
      //    console.error('Simulation Error:')
      //    console.error({ err, logs })
      //    return
      // }
      // console.timeEnd('simulateTransaction')

      console.log('Current time: ', new Date().toLocaleTimeString())

      const transactionResponse = await transactionSenderAndConfirmationWaiter({
         connection: this.quickNodeConnection,
         serializedTransaction: Buffer.from(transaction.serialize()),
         blockhashWithExpiryBlockHeight: blockhash,
      })

      if (!transactionResponse) {
         console.error('Transaction not confirmed')
         return
      }

      if (transactionResponse.meta?.err) {
         console.error(transactionResponse.meta?.err)
      }

      const findTokenBalance = (balances: Array<TokenBalance>, mint: string, owner: string): number => {
         const balance = balances.find((balance) => balance.mint === mint && balance.owner === owner)
         return balance ? balance.uiTokenAmount.uiAmount : 0
      }

      const postBalance = findTokenBalance(transactionResponse.meta.postTokenBalances, outputMint, wallet.publicKey.toBase58())
      const preBalance = findTokenBalance(transactionResponse.meta.preTokenBalances, outputMint, wallet.publicKey.toBase58())
      const outputAmount = postBalance - preBalance

      console.log(`https://solscan.io/tx/${signature}`)
      console.log(`Output amount: ${outputAmount}`)

      return outputAmount
   }

   async getPriceForMultipleTokens(tokensToCheck: string[], vsToken: string = this.knownAddresses.WSOL): Promise<JupiterPriceReponse> {
      const tokenPrices = await axios.get(`${this.jupiterPriceURL}/price`, {
         params: {
            ids: tokensToCheck.join(','),
            vsToken: vsToken,
         },
      })
      return tokenPrices.data
   }
}
</file>

<file path="apps/backend/src/user/dto/BuyToken.dto.ts">
import { BuyTokenDto as BaseBuyTokenDto } from 'shared-types/src/dto/BuyToken.dto' // Adjust the path as necessary
import { InsertAutoSell } from 'shared-types/src/drizzle.types' // Adjust the path as necessary
import { IsNotEmpty, IsNumber, IsOptional, IsString, ValidateNested } from 'class-validator'

export class BuyTokenDto implements BaseBuyTokenDto {
   @IsNotEmpty()
   @IsString()
   walletAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAddress: string

   @IsNotEmpty()
   @IsString()
   solAmountIn: string

   @IsNotEmpty()
   @IsNumber()
   slippageInPercentage: number

   @IsNotEmpty()
   @IsNumber()
   prioritizationFeeLamports: number | 'auto'

   @IsOptional()
   @ValidateNested()
   autoSell?: Omit<InsertAutoSell, 'tokenAmountToSell'>
}
</file>

<file path="apps/backend/src/user/dto/SellToken.dto.ts">
import { SellTokenDto as BaseSellTokenDto } from 'shared-types/src/dto/SellToken.dto' // Adjust the path as necessary
import { IsNotEmpty, IsNumber, IsString } from 'class-validator'

export class SellTokenDto implements BaseSellTokenDto {
   @IsNotEmpty()
   @IsString()
   walletAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAddress: string

   @IsNotEmpty()
   @IsString()
   tokenAmountIn: string

   @IsNotEmpty()
   @IsNumber()
   slippageInPercentage: number

   @IsNotEmpty()
   @IsNumber()
   prioritizationFeeLamports: number | 'auto'
}
</file>

<file path="apps/frontend/src/routes/dashboard/trade/+page.svelte">
<script>
	import TradeForm from '$components/trade/TradeForm.svelte';
</script>

<TradeForm />
</file>

<file path="apps/backend/src/blockchain/solana/sniper/solanaAutoSellSniper.service.ts">
import { forwardRef, Inject, Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import { SolanaService } from '../solana.service'
import * as schema from 'src/drizzle/schema'
import { InsertAutoSell, SelectAutoSell } from 'shared-types/src/drizzle.types'
import { UserService } from 'src/user/user.service'
import { EncryptionService } from 'src/encryption/encryption.service'
import { AutoSellStrategy, GridStrategyParams, SimpleStrategyParams } from 'shared-types/src/autoSell.interface'
import BigNumber from 'bignumber.js'

@Injectable()
export class SolanaAutoSellSniperService implements OnModuleInit, OnModuleDestroy {
   private intervalId: NodeJS.Timeout
   private readonly INTERVAL = 500 // 250ms
   private cachedEntries: InsertAutoSell[] = []
   private cachedEntriesTokenAddresses: Set<string> = new Set()

   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private readonly solanaService: SolanaService,
      @Inject(forwardRef(() => UserService))
      private readonly userService: UserService,
      private readonly encryptionService: EncryptionService,
   ) {}

   async onModuleInit() {
      this.cachedEntries = await this.getAutoSellEntriesFromDb()
      this.cachedEntriesTokenAddresses = new Set(this.cachedEntries.map((entry) => entry.tokenAddressToSell))
      this.startInterval()
   }

   onModuleDestroy() {
      this.stopInterval()
   }

   private startInterval() {
      this.intervalId = setInterval(() => this.checkAutoSells(), this.INTERVAL)
   }

   private stopInterval() {
      if (this.intervalId) {
         clearInterval(this.intervalId)
      }
   }

   private async checkAutoSells() {
      if (this.cachedEntries.length === 0) return
      try {
         const tokenPrices = await this.solanaService.getPriceForMultipleTokens([...this.cachedEntriesTokenAddresses])
         for (const entry of this.cachedEntries) {
            const currentPrice = new BigNumber(tokenPrices.data[entry.tokenAddressToSell].price)

            switch (entry.strategy) {
               case AutoSellStrategy.SIMPLE:
                  await this.checkSimpleAutoSell(entry, currentPrice)
                  break
               case AutoSellStrategy.GRID:
                  // await this.checkGridAutoSell(entry, currentPrice)
                  break
            }
         }
      } catch (error) {
         console.error('Error in checkAutoSells:', error)
      }
   }

   private async checkSimpleAutoSell(entry: InsertAutoSell, currentPrice: BigNumber) {
      const { profitPercentage, lossPercentage } = entry.strategyParams as SimpleStrategyParams
      // const potentialSaleAmount = currentPrice * parseFloat(entry.tokenAmountToSell)
      const profitTrigger = new BigNumber(entry.initialPrice).times(1 + profitPercentage / 100)
      const lossTrigger = new BigNumber(entry.initialPrice).times(1 - lossPercentage / 100)

      if (currentPrice.gte(profitTrigger)) {
         await this.executeSell(entry, 'profit')
      } else if (currentPrice.lte(lossTrigger)) {
         await this.executeSell(entry, 'loss')
      }
   }

   // private async checkGridAutoSell(entry: InsertAutoSell, currentPrice: number) {
   //    const { stopLossType, stopLossPercentage, profitTargets } = entry.strategyParams as GridStrategyParams

   //    // Check stop loss
   //    let stopLossTriggered = false
   //    switch (stopLossType) {
   //       case 'static':
   //          stopLossTriggered = currentPrice <= entry.initialPrice * (1 - stopLossPercentage / 100)
   //          break
   //       case 'trailing':
   //          const highWaterMark = this.priceHighWaterMarks.get(entry.id) || entry.initialPrice
   //          if (currentPrice > highWaterMark) {
   //             this.priceHighWaterMarks.set(entry.id, currentPrice)
   //          }
   //          stopLossTriggered = currentPrice <= highWaterMark * (1 - stopLossPercentage / 100)
   //          break
   //       case 'breakeven':
   //          stopLossTriggered = currentPrice <= entry.initialPrice
   //          break
   //    }

   //    if (stopLossTriggered) {
   //       await this.executeSell(entry, 'stop loss')
   //       return
   //    }

   //    // Check profit targets
   //    for (const target of profitTargets) {
   //       if (currentPrice >= entry.initialPrice * target.multiplier) {
   //          const sellAmount = parseFloat(entry.tokenAmountToSell) * (target.sellPercentage / 100)
   //          await this.executePartialSell(entry, sellAmount, 'profit target')

   //          // Update the entry after partial sell
   //          entry.tokenAmountToSell = (parseFloat(entry.tokenAmountToSell) - sellAmount).toString()
   //          if (parseFloat(entry.tokenAmountToSell) <= 0) {
   //             await this.removeAutoSellEntry(entry)
   //          } else {
   //             await this.updateAutoSellEntry(entry)
   //          }
   //          break
   //       }
   //    }
   // }

   private async executeSell(entry: InsertAutoSell, trigger: string) {
      try {
         const wallet = await this.userService.getWalletById(entry.userId, entry.walletId)
         const user = await this.userService.findById(entry.userId)
         await this.solanaService.makeJupiterSwapTransaction(
            entry.tokenAddressToSell,
            this.solanaService.knownAddresses.WSOL,
            parseFloat(entry.tokenAmountToSell),
            parseFloat(entry.slippage) * 100, // 1% slippage
            this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
            'auto',
         )
         await this.removeAutoSellEntry(entry)
         console.log(`Auto-sell executed for user ${entry.userId} (${trigger} trigger)`)
      } catch (error) {
         console.error(`Failed to execute auto-sell for user ${entry.userId}:`, error)
      }
   }

   // private async executePartialSell(entry: SelectAutoSell, amount: number, trigger: string) {
   //    try {
   //       const wallet = await this.userService.getWalletById(entry.userId, entry.walletId)
   //       const user = await this.userService.findById(entry.userId)
   //       await this.solanaService.makeJupiterSwapTransaction(
   //          entry.tokenAddressToSell,
   //          this.solanaService.knownAddresses.WSOL,
   //          amount,
   //          1, // 1% slippage
   //          this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
   //          'auto',
   //       )
   //       console.log(`Partial auto-sell executed for user ${entry.userId} (${trigger} trigger)`)
   //    } catch (error) {
   //       console.error(`Failed to execute partial auto-sell for user ${entry.userId}:`, error)
   //    }
   // }

   // private async updateAutoSellEntry(entry: SelectAutoSell) {
   //    await this.db
   //       .update(schema.autoSellTable)
   //       .set({ tokenAmountToSell: entry.tokenAmountToSell, updatedAt: new Date() })
   //       .where(eq(schema.autoSellTable.id, entry.id))
   //       .execute()

   //    const index = this.cachedEntries.findIndex((e) => e.id === entry.id)
   //    if (index !== -1) {
   //       this.cachedEntries[index] = entry
   //    }
   // }

   private async getAutoSellEntriesFromDb(): Promise<InsertAutoSell[]> {
      const entries = await this.db.select().from(schema.autoSellTable).execute()
      return entries
   }

   public async addAutoSellEntry(entry: InsertAutoSell) {
      this.cachedEntries.push(entry)
      this.cachedEntriesTokenAddresses.add(entry.tokenAddressToSell)
      await this.db.insert(schema.autoSellTable).values(entry).execute()
   }

   public async removeAutoSellEntry(entry: InsertAutoSell) {
      const index = this.cachedEntries.findIndex((e) => e.userId === entry.userId)
      if (index !== -1) {
         this.cachedEntries.splice(index, 1)
         this.cachedEntriesTokenAddresses.delete(entry.tokenAddressToSell)
      }
      //   await this.db.delete(schema.autoSellTable).where(schema.autoSellTable.id.equals(entry.id)).execute()
   }
}

// import { forwardRef, Inject, Injectable, OnModuleDestroy, OnModuleInit } from '@nestjs/common'
// import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
// import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
// import { SolanaService } from '../solana.service'
// import * as schema from 'src/drizzle/schema'
// import { InsertAutoSell } from 'shared-types/src/drizzle.types'
// import { UserService } from 'src/user/user.service'
// import { EncryptionService } from 'src/encryption/encryption.service'

// @Injectable()
// export class SolanaAutoSellSniperService implements OnModuleInit, OnModuleDestroy {
//    private intervalId: NodeJS.Timeout
//    private readonly INTERVAL = 500 // 250ms
//    private cachedEntries: InsertAutoSell[] = []
//    private cachedEntriesTokenAddresses: Set<string> = new Set()

//    constructor(
//       @Inject(DrizzleAsyncProvider)
//       private db: PostgresJsDatabase<typeof schema>,
//       private readonly solanaService: SolanaService,
//       @Inject(forwardRef(() => UserService))
//       private readonly userService: UserService,
//       private readonly encryptionService: EncryptionService,
//    ) {}

//    async onModuleInit() {
//       this.cachedEntries = await this.getAutoSellEntriesFromDb()
//       this.cachedEntriesTokenAddresses = new Set(this.cachedEntries.map((entry) => entry.tokenAddressToSell))
//       this.startInterval()
//    }

//    onModuleDestroy() {
//       this.stopInterval()
//    }

//    private startInterval() {
//       this.intervalId = setInterval(() => this.checkAutoSells(), this.INTERVAL)
//    }

//    private stopInterval() {
//       if (this.intervalId) {
//          clearInterval(this.intervalId)
//       }
//    }

//    private async checkAutoSells() {
//       if (this.cachedEntries.length === 0) return
//       try {
//          const tokenPrices = await this.solanaService.getPriceForMultipleTokens([...this.cachedEntriesTokenAddresses])
//          for (const entry of this.cachedEntries) {
//             const currentPrice = tokenPrices.data[entry.tokenAddressToSell].price
//             const potentialSaleAmount = currentPrice * parseFloat(entry.tokenAmountToSell)
//             console.log(
//                'Potential sale amount:',
//                potentialSaleAmount,
//                'Current price:',
//                currentPrice,
//                'Solana Profit Trigger:',
//                parseFloat(entry.solAmountProfitTrigger) / 10 ** 9,
//                'Solana Loss Trigger:',
//                parseFloat(entry.solAmountLossTrigger) / 10 ** 9,
//             )
//             if (potentialSaleAmount >= parseFloat(entry.solAmountProfitTrigger) / 10 ** 9) {
//                await this.executeSell(entry, 'profit')
//             } else if (potentialSaleAmount <= parseFloat(entry.solAmountLossTrigger) / 10 ** 9) {
//                await this.executeSell(entry, 'loss')
//             }
//          }
//       } catch (error) {
//          console.error('Error in checkAutoSells:', error)
//       }
//    }

//    private async getAutoSellEntriesFromDb(): Promise<InsertAutoSell[]> {
//       const entries = await this.db.select().from(schema.autoSellTable).execute()
//       return entries
//    }

//    private async executeSell(entry: InsertAutoSell, trigger) {
//       try {
//          this.removeAutoSellEntry(entry)
//          const wallet = await this.userService.getWalletById(entry.userId, entry.walletId)
//          const user = await this.userService.findById(entry.userId)
//          await this.solanaService.makeJupiterSwapTransaction(
//             entry.tokenAddressToSell,
//             this.solanaService.knownAddresses.WSOL,
//             parseFloat(entry.tokenAmountToSell) * 10 ** 6,
//             parseFloat(entry.slippage) * 100,
//             this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
//             1039280,
//          )
//          await this.removeAutoSellEntry(entry)
//          console.log(`Auto-sell executed for user ${entry.userId} (${trigger} trigger)`)
//       } catch (error) {
//          console.error(`Failed to execute auto-sell for user ${entry.userId}:`, error)
//       }
//    }

//    public async addAutoSellEntry(entry: InsertAutoSell) {
//       this.cachedEntries.push(entry)
//       this.cachedEntriesTokenAddresses.add(entry.tokenAddressToSell)
//       await this.db.insert(schema.autoSellTable).values(entry).execute()
//    }

//    public async removeAutoSellEntry(entry: InsertAutoSell) {
//       const index = this.cachedEntries.findIndex((e) => e.userId === entry.userId)
//       if (index !== -1) {
//          this.cachedEntries.splice(index, 1)
//          this.cachedEntriesTokenAddresses.delete(entry.tokenAddressToSell)
//       }
//       //   await this.db.delete(schema.autoSellTable).where(schema.autoSellTable.id.equals(entry.id)).execute()
//    }
// }
</file>

<file path="apps/backend/src/blockchain/solana/sniper/solanaSniper.module.ts">
import { forwardRef, Module } from '@nestjs/common'
import { SolanaAutoSellSniperService } from './solanaAutoSellSniper.service'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { SolanaModule } from '../solana.module'
import { UserModule } from 'src/user/user.module'
import { EncryptionModule } from 'src/encryption/encryption.module'

@Module({
   imports: [SolanaModule, forwardRef(() => UserModule), EncryptionModule],
   providers: [SolanaAutoSellSniperService, ...drizzleProvider],
   exports: [SolanaAutoSellSniperService],
})
export class SolanaSniperModule {}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.controller.ts">
import { Controller, Get, Param } from '@nestjs/common'
import { SolanaTokenService } from './solanaToken.service'

@Controller('solanaToken')
export class SolanaTokenController {
   constructor(private readonly solanaTokenService: SolanaTokenService) {}

   @Get(':tokenAddress')
   findOne(@Param('tokenAddress') tokenAddress: string) {
      return this.solanaTokenService.getTokenInfo(tokenAddress)
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.module.ts">
// src/blockchain/solana/token/token.module.ts
import { Module } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaTokenController } from './solanaToken.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'

@Module({
   providers: [SolanaTokenService, SolanaService, ...drizzleProvider],
   controllers: [SolanaTokenController],
   exports: [SolanaTokenService],
})
export class SolanaTokenModule {}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaService } from '../solana.service'

describe('SolanaTokenService', () => {
   let service: SolanaTokenService

   beforeEach(async () => {
      const module: TestingModule = await Test.createTestingModule({
         providers: [SolanaTokenService, SolanaService],
      }).compile()

      service = module.get<SolanaTokenService>(SolanaTokenService)
   })

   it('should be defined', () => {
      expect(service).toBeDefined()
   })
})
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
// src/blockchain/solana/token/token.service.ts
import { Inject, Injectable } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { getMint, getAccount, AccountLayout } from '@solana/spl-token'
import { PublicKey as SolanaPublicKey } from '@solana/web3.js'
import { PublicKey as UmiPublicKey } from '@metaplex-foundation/umi-public-keys'
import { fetchMetadata, findMetadataPda } from '@metaplex-foundation/mpl-token-metadata'
import { TokenHolderInfo, TokenInfo, TokenTransactions, URLInfo } from 'shared-types/src/tokenInfo.interface'
import axios from 'axios'
import { DexScreenerResponse } from 'src/common/interfaces/dexscreenerData.interface'
import {
   getPairWithMostLiquidity,
   convertPairToTokenTransactions,
   calculateTotalLiquidityInUsd,
   getAllUniqueDexIds,
} from 'src/common/helpers/convertDexscreenerData'
import { sleep } from 'src/common/helpers/sleep'
import { SelectDexTransactionLogs } from 'src/drizzle/schema'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { gte, and, eq } from 'drizzle-orm'
import * as fs from 'fs'

@Injectable()
export class SolanaTokenService {
   constructor(
      private solanaService: SolanaService,
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
   ) {}

   async getTokenInfo(tokenAddress: string): Promise<TokenInfo> {
      this.fetchTransactionsFromDatabase(tokenAddress)
      const mint = await getMint(this.solanaService.quickNodeConnection, new SolanaPublicKey(tokenAddress))

      const tokenMetadata = await fetchMetadata(
         this.solanaService.umi,
         findMetadataPda(this.solanaService.umi, {
            mint: tokenAddress as UmiPublicKey,
         }),
      )

      // console.log(tokenMetadata)

      const dexScreenerData: DexScreenerResponse = await this.fetchFromDexScreener(tokenAddress)
      const pairWithMostLiquidity = getPairWithMostLiquidity(dexScreenerData.pairs)
      const topHolders = await this.fetchTopHolders(
         tokenAddress,
         Number(mint.supply) / 10 ** mint.decimals,
         parseFloat(pairWithMostLiquidity.priceUsd),
      )

      const oneTokenPriceInUSD = await this.fetchTokenPrice(tokenAddress)
      const socialMediaAndImage = await this.fetchSocialMediaLinksAndImage(tokenMetadata.uri)

      // Initialize and populate the TokenInfo object
      const tokenInfo: TokenInfo = {
         name: tokenMetadata.name, // Replace with actual fetched data
         symbol: tokenMetadata.symbol, // Replace with actual fetched data
         address: tokenAddress,
         decimals: mint.decimals,
         totalSupply: Number(mint.supply),
         totalSupplyPriceInUSD: (Number(mint.supply) / 10 ** mint.decimals) * oneTokenPriceInUSD,
         oneTokenPriceInUSD: oneTokenPriceInUSD,
         transactions: convertPairToTokenTransactions(pairWithMostLiquidity),
         mintAuthority: mint.mintAuthority ? mint.mintAuthority.toBase58() : null,
         freezeAuthority: mint.freezeAuthority ? mint.freezeAuthority.toBase58() : null,
         metadataChangeAuthority: tokenMetadata.updateAuthority,
         uniqueHolders: 0,
         totalLiquidtyInUSD: calculateTotalLiquidityInUsd(dexScreenerData.pairs),
         topHolders: topHolders,
         topHoldersTokenSupplyDistribution: this.getTopRanksExcludingOwners(topHolders),
         verifiedDexScreener: await this.checkVerifiedDexScreener(tokenAddress),
         dexesBeingTradedOn: getAllUniqueDexIds(dexScreenerData.pairs),
         verifiedBirdEye: await this.checkVerifiedBirdEye(tokenAddress),
         socialMediaLinks: socialMediaAndImage.urlInfo,
         image: socialMediaAndImage.image,
      }

      return tokenInfo
   }

   private getTopRanksExcludingOwners(elements: TokenHolderInfo[]) {
      // 5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1 = Raydium
      const excludedOwners = ['5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1']

      const filteredElements = elements.filter((element) => !excludedOwners.includes(element.address))

      return {
         top5: filteredElements.slice(0, 5).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top10: filteredElements.slice(0, 10).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top15: filteredElements.slice(0, 15).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top20: filteredElements.slice(0, 20).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
      }
   }

   private async fetchFromDexScreener(tokenAddress: string): Promise<DexScreenerResponse> {
      try {
         const response = await axios.get(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`)
         return response.data as DexScreenerResponse
      } catch (error) {
         console.error('Error fetching data from DexScreener:', error)
         throw error
      }
   }

   // private async fetchTokenPairInfo(tokenAddress: string): Promise<TokenPairsInLP[]> {}

   private async fetchTransactionsFromDatabase(tokenAddress: string) {
      const yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000)

      const transactions: SelectDexTransactionLogs[] = await this.db
         .select()
         .from(schema.dexTransactionsTable)
         .where(and(gte(schema.dexTransactionsTable.timestamp, yesterday), eq(schema.dexTransactionsTable.secondaryTokenAddress, tokenAddress)))

      fs.writeFileSync('transactions.json', JSON.stringify(transactions, null, 2))

      // function splitAndAggregateTransactions(transactions, timeFrame) {
      //    const timeFrames = {
      //       '5m': 5,
      //       '1h': 60,
      //       '6h': 360,
      //       '12h': 720,
      //       '24h': 1440,
      //    }
      //    const minutesPerFrame = timeFrames[timeFrame]

      //    // Organize transactions into buckets based on time intervals
      //    const buckets = {}

      //    transactions.forEach((tx) => {
      //       // Calculate the bucket key as the start of the interval
      //       const intervalStart = moment(tx.timestamp)
      //          .startOf('minute')
      //          .subtract(moment(tx.timestamp).minute() % minutesPerFrame, 'minutes')
      //       const key = intervalStart.format()

      //       if (!buckets[key]) {
      //          buckets[key] = []
      //       }
      //       buckets[key].push(tx)
      //    })

      //    // Process each bucket to generate aggregated results
      //    const results = []

      //    Object.keys(buckets).forEach((key) => {
      //       const aggregatedData = aggregateTransactions(buckets[key], timeFrame)
      //       results.push(aggregatedData)
      //    })

      //    return results
      // }

      // function aggregateTransactions(transactions, timeFrame) {
      //    const aggregated = {
      //       time: timeFrame,
      //       txCount: transactions.length.toString(),
      //       volume: 0,
      //       volumeInUSD: 0,
      //       uniqueWallets: new Set(),
      //       buys: 0,
      //       sells: 0,
      //       buyVolumeInUSD: 0,
      //       sellVolumeInUSD: 0,
      //       buyers: new Set(),
      //       sellers: new Set(),
      //    }

      //    transactions.forEach((tx) => {
      //       aggregated.volume += tx.primaryTokenAmount + tx.secondaryTokenAmount
      //       aggregated.volumeInUSD += tx.transactionValueInUsd
      //       aggregated.uniqueWallets.add(tx.signer)

      //       if (tx.transactionType === 'buy') {
      //          aggregated.buys++
      //          aggregated.buyVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.buyers.add(tx.signer)
      //       } else if (tx.transactionType === 'sell') {
      //          aggregated.sells++
      //          aggregated.sellVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.sellers.add(tx.signer)
      //       }
      //    })

      //    aggregated.uniqueWallets = aggregated.uniqueWallets.size
      //    aggregated.buyers = aggregated.buyers.size
      //    aggregated.sellers = aggregated.sellers.size

      //    return aggregated
      // }

      // return results
   }

   private async fetchTopHolders(tokenAddress: string, totalSupply: number, oneTokenPriceInUSD: number): Promise<TokenHolderInfo[]> {
      const tokenLargestAccounts = await this.solanaService.quickNodeConnection.getTokenLargestAccounts(new SolanaPublicKey(tokenAddress))
      const tokenAccountInfo = await this.solanaService.defaultSolanaConnection.getMultipleAccountsInfo(
         tokenLargestAccounts.value.map((account) => account.address),
      )
      const tokenHolders: TokenHolderInfo[] = []
      for (let i = 0; i < tokenLargestAccounts.value.length; i++) {
         const account = tokenLargestAccounts.value[i]
         const tokenAccountData = AccountLayout.decode(tokenAccountInfo[i].data)
         tokenHolders.push({
            address: tokenAccountData.owner.toBase58(),
            balance: account.uiAmount,
            worthInUSD: account.uiAmount * oneTokenPriceInUSD,
            percentageOfTotalSupply: (account.uiAmount / totalSupply) * 100,
         })
      }
      return tokenHolders
   }

   private async checkTokensLockedInLP(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if tokens are locked in LP
      return false
   }

   private async fetchTokenCreator(tokenAddress: string): Promise<string> {
      // Implement the logic to fetch token creator
      return ''
   }

   private async checkVerifiedDexScreener(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on Dex Screener
      return false
   }

   private async checkVerifiedBirdEye(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on BirdEye
      return false
   }

   private async fetchSocialMediaLinksAndImage(url: string): Promise<{ image: string; urlInfo: URLInfo[] }> {
      try {
         const response = await axios.get(url)
         const data = response.data
         console.log(data)

         const links: URLInfo[] = []
         const socialMediaPatterns = {
            Facebook: [/facebook\.com/, /fb\.com/],
            Twitter: [/x\.com/],
            Instagram: [/instagram\.com/, /instagr\.am/],
            LinkedIn: [/linkedin\.com/],
            YouTube: [/youtube\.com/, /youtu\.be/],
            TikTok: [/tiktok\.com/],
            Reddit: [/reddit\.com/],
            Telegram: [/t\.me/],
            PumpFun: [/pump\.fun/],
         }

         function checkValue(value: any): void {
            if (typeof value === 'string' && isValidURL(value)) {
               const urlInfo: URLInfo = { url: value }
               for (const [name, patterns] of Object.entries(socialMediaPatterns)) {
                  if (patterns.some((pattern) => pattern.test(value))) {
                     urlInfo.platform = name
                     break
                  } else {
                     urlInfo.platform = 'Website'
                  }
               }
               links.push(urlInfo)
            } else if (typeof value === 'object' && value !== null) {
               for (const key in value) {
                  checkValue(value[key])
               }
            }
         }

         function isValidURL(url: string): boolean {
            try {
               new URL(url)
               return true
            } catch (_) {
               return false
            }
         }

         checkValue(data)
         return { image: data.image, urlInfo: links.filter((link) => link.url != data.image) }
      } catch (error) {
         console.error('Error fetching data:', error)
         return { image: '', urlInfo: [] }
      }
   }

   private async fetchTokenPrice(tokenAddress: string): Promise<number> {
      const response = await axios.get(`https://api-v3.raydium.io/mint/price?mints=${tokenAddress}`)
      return response.data.data[tokenAddress]
   }
}
</file>

</repository_files>
