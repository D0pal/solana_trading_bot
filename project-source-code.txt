<summary>

<header>
Repopack Output File
This file was generated by Repopack on: 2024-08-14T02:22:41.196Z
</header>

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository structure
3. Repository files, each consisting of:
    - File path as an attribute
    - Full contents of the file
</file_format>

<usage_guidelines>
1. This file should be treated as read-only. Any changes should be made to the
    original repository files, not this packed version.
2. When processing this file, use the file path attributes to distinguish
    between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
    the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


</notes>

<additional_info>
For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</summary>

<repository_structure>
.aidigestignore
.gitignore
.npmrc
.repopackignore
apps/backend/.eslintrc.js
apps/backend/.prettierrc
apps/backend/drizzle.config.ts
apps/backend/nest-cli.json
apps/backend/package.json
apps/backend/README.md
apps/backend/src/app.controller.spec.ts
apps/backend/src/app.controller.ts
apps/backend/src/app.module.ts
apps/backend/src/app.service.ts
apps/backend/src/auth/auth.controller.ts
apps/backend/src/auth/auth.module.ts
apps/backend/src/auth/auth.service.ts
apps/backend/src/auth/strategies/jwt.tstrategy.ts
apps/backend/src/auth/strategies/SessionSerializer.ts
apps/backend/src/auth/strategies/telegram.strategy.ts
apps/backend/src/auth/utils/authenticated.guard.ts
apps/backend/src/auth/utils/telegram.guard.ts
apps/backend/src/blockchain/solana/sniper/autoSell/entryCalculation.service.ts
apps/backend/src/blockchain/solana/sniper/autoSell/transactionExecution.service.ts
apps/backend/src/blockchain/solana/sniper/pricePooling.service.ts
apps/backend/src/blockchain/solana/sniper/solanaSniper.module.ts
apps/backend/src/blockchain/solana/solana.controller.ts
apps/backend/src/blockchain/solana/solana.module.ts
apps/backend/src/blockchain/solana/solana.service.ts
apps/backend/src/blockchain/solana/token/solanaToken.controller.ts
apps/backend/src/blockchain/solana/token/solanaToken.module.ts
apps/backend/src/blockchain/solana/token/solanaToken.service.spec.ts
apps/backend/src/blockchain/solana/token/solanaToken.service.ts
apps/backend/src/common/helpers/convertDexscreenerData.ts
apps/backend/src/common/helpers/getSignature.ts
apps/backend/src/common/helpers/sleep.ts
apps/backend/src/common/helpers/transactionSender.ts
apps/backend/src/common/interfaces/blockchain.interface.ts
apps/backend/src/common/interfaces/dexscreenerData.interface.ts
apps/backend/src/common/interfaces/user.interface.ts
apps/backend/src/drizzle/drizzle.module.ts
apps/backend/src/drizzle/drizzle.provider.ts
apps/backend/src/drizzle/schema.ts
apps/backend/src/encryption/encryption.module.ts
apps/backend/src/encryption/encryption.service.ts
apps/backend/src/main.ts
apps/backend/src/user/user.controller.ts
apps/backend/src/user/user.module.ts
apps/backend/src/user/user.service.ts
apps/backend/test/app.e2e-spec.ts
apps/backend/test/jest-e2e.json
apps/backend/transactions.json
apps/backend/tsconfig.build.json
apps/backend/tsconfig.json
apps/frontend/.gitignore
apps/frontend/.prettierignore
apps/frontend/.prettierrc
apps/frontend/eslint.config.js
apps/frontend/package.json
apps/frontend/playwright.config.ts
apps/frontend/postcss.config.js
apps/frontend/README.md
apps/frontend/src/app.css
apps/frontend/src/app.d.ts
apps/frontend/src/app.html
apps/frontend/src/components/common/BottomNavigation.svelte
apps/frontend/src/components/common/CopyToClipboard.svelte
apps/frontend/src/components/common/Navbar.svelte
apps/frontend/src/components/common/NumberInput.svelte
apps/frontend/src/components/TelegramLoginWidget.svelte
apps/frontend/src/components/trade/AutoSellPresets.svelte
apps/frontend/src/components/trade/BuyTradeForm.svelte
apps/frontend/src/components/trade/SellTradeForm.svelte
apps/frontend/src/components/trade/TokenInformationModal.svelte
apps/frontend/src/components/trade/TradeForm.svelte
apps/frontend/src/components/trade/VolatileMarketProjections.svelte
apps/frontend/src/components/trade/WalletSelector.svelte
apps/frontend/src/hooks.server.ts
apps/frontend/src/index.test.ts
apps/frontend/src/lib/api.ts
apps/frontend/src/lib/autoSellPresets.ts
apps/frontend/src/lib/index.ts
apps/frontend/src/lib/presetUtils.ts
apps/frontend/src/lib/VolatileMarketStrategy.ts
apps/frontend/src/routes/+layout.svelte
apps/frontend/src/routes/+page.svelte
apps/frontend/src/routes/dashboard/+layout.server.ts
apps/frontend/src/routes/dashboard/+layout.svelte
apps/frontend/src/routes/dashboard/+page.svelte
apps/frontend/src/routes/dashboard/trade/+page.svelte
apps/frontend/src/routes/login/+page.svelte
apps/frontend/src/services/priceUpdateService.ts
apps/frontend/src/services/tokenService.ts
apps/frontend/src/services/tradingService.ts
apps/frontend/src/stores/auth.ts
apps/frontend/src/stores/formStore.ts
apps/frontend/src/stores/priceStore.ts
apps/frontend/src/stores/tokenStore.ts
apps/frontend/src/stores/userStore.ts
apps/frontend/src/types/BuyTokenForm.interface.ts
apps/frontend/src/types/global.d.ts
apps/frontend/src/utils/copyToClipboard.ts
apps/frontend/src/utils/formatters.ts
apps/frontend/svelte.config.js
apps/frontend/tailwind.config.js
apps/frontend/tests/test.ts
apps/frontend/tsconfig.json
apps/frontend/vite.config.ts
package.json
packages/shared-types/package.json
packages/shared-types/src/autoSell.interface.ts
packages/shared-types/src/drizzle.types.ts
packages/shared-types/src/dto/BuyToken.dto.ts
packages/shared-types/src/dto/SellToken.dto.ts
packages/shared-types/src/JupiterPriceResponse.interface.ts
packages/shared-types/src/TelegramAuthData.interface.ts
packages/shared-types/src/tokenInfo.interface.ts
packages/shared-types/src/userInfo.interface.ts
packages/shared-types/src/zodSchemas/BuyTokenFormSchema.ts
packages/shared-types/tsconfig.json
README.md
tsconfig.json
</repository_structure>

<repository_files>

<file path=".aidigestignore">
.svelte-kit
dist
migrations
solana_listener
example_data
static
node_modules
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Nest.JS build output
dist/

# Drizzle migrations output
migrations/
</file>

<file path=".npmrc">
engine-strict=true
</file>

<file path=".repopackignore">
.svelte-kit
dist
migrations
solana_listener
example_data
static
node_modules
</file>

<file path="package.json">
{
   "name": "solana-trading-bot-workspace",
   "private": true,
   "scripts": {
      "build:shared-types": "tsc --project packages/shared-types",
      "prestart": "npm run build:shared-types",
      "start": "npm run start --workspace=backend",
      "predev": "npm run build:shared-types",
      "dev": "concurrently \"npm run dev --workspace=backend\" \"npm run dev --workspace=frontend\""
   },
   "workspaces": [
      "apps/*",
      "packages/*"
   ],
   "packageManager": "pnpm@8.15.1+sha512.831cf4c5f8b8374af71521d4d153db49d7086de615c2af7cb5e9d7eb8ba630ddac46fea495d643e552ef2e68a3aa99a3e5e9fbee8696702967504df5c59cb273",
   "dependencies": {
      "valibot": "^0.37.0"
   }
}
</file>

<file path="README.md">
# solana_trading_bot
</file>

<file path="tsconfig.json">
{
   "compilerOptions": {
      "baseUrl": ".",
      "paths": {
         "shared-types": ["packages/shared-types/src"]
      }
   },
   "include": ["apps/**/*", "packages/**/*"]
}
</file>

<file path="apps/backend/.eslintrc.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    'prettier/prettier': ['error', { endOfLine: 'auto' }],
  },
};
</file>

<file path="apps/backend/.prettierrc">
{
  "tabWidth": 3,
  "semi": false,
  "singleQuote": true,
  "printWidth": 150
}
</file>

<file path="apps/backend/drizzle.config.ts">
import { config } from 'dotenv'
import { defineConfig } from 'drizzle-kit'

config({ path: '.env' })

export default defineConfig({
   schema: './src/drizzle/schema.ts',
   out: './src/drizzle/migrations',
   dialect: 'postgresql',
   dbCredentials: {
      url: process.env.DATABASE_URL!,
   },
})
</file>

<file path="apps/backend/nest-cli.json">
{
   "$schema": "https://json.schemastore.org/nest-cli",
   "collection": "@nestjs/schematics",
   "sourceRoot": "src",
   "compilerOptions": {
      "deleteOutDir": true
   },
   "entryFile": "apps/backend/src/main.js"
}
</file>

<file path="apps/backend/package.json">
{
   "name": "backend",
   "version": "0.0.1",
   "description": "",
   "author": "",
   "private": true,
   "license": "UNLICENSED",
   "packageManager": "npm@10.5.2",
   "scripts": {
      "build": "nest build",
      "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
      "start": "nest start",
      "start:dev": "nest start --watch",
      "start:debug": "nest start --debug --watch",
      "start:prod": "node dist/main",
      "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
      "test": "jest",
      "test:watch": "jest --watch",
      "test:cov": "jest --coverage",
      "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
      "test:e2e": "jest --config ./test/jest-e2e.json",
      "migrate": "npx drizzle-kit generate && npx drizzle-kit migrate"
   },
   "dependencies": {
      "@metaplex-foundation/mpl-token-metadata": "^3.2.1",
      "@metaplex-foundation/umi": "^0.9.2",
      "@metaplex-foundation/umi-bundle-defaults": "^0.9.2",
      "@nestjs/common": "^10.0.0",
      "@nestjs/core": "^10.0.0",
      "@nestjs/event-emitter": "^2.0.4",
      "@nestjs/jwt": "^10.2.0",
      "@nestjs/mapped-types": "*",
      "@nestjs/passport": "^10.0.3",
      "@nestjs/platform-express": "^10.3.10",
      "@nestjs/schedule": "^4.1.0",
      "@solana/spl-token": "^0.4.8",
      "@solana/web3.js": "^1.95.0",
      "@supabase/supabase-js": "^2.44.3",
      "axios": "^1.7.3",
      "bcrypt": "^5.1.1",
      "bignumber.js": "^9.1.2",
      "bs58": "^4.0.1",
      "class-transformer": "^0.5.1",
      "class-validator": "^0.14.1",
      "dotenv": "^16.4.5",
      "drizzle-orm": "^0.31.4",
      "express-session": "^1.18.0",
      "moment": "^2.30.1",
      "passport": "^0.7.0",
      "passport-custom": "^1.1.1",
      "passport-jwt": "^4.0.1",
      "passport-local": "^1.0.0",
      "postgres": "^3.4.4",
      "promise-retry": "^2.0.1",
      "reflect-metadata": "^0.2.0",
      "rxjs": "^7.8.1",
      "shared-types": "^1.0.0",
      "valibot": "^0.37.0"
   },
   "devDependencies": {
      "@nestjs/cli": "^10.0.0",
      "@nestjs/schematics": "^10.0.0",
      "@nestjs/testing": "^10.0.0",
      "@types/express": "^4.17.17",
      "@types/express-session": "^1.18.0",
      "@types/jest": "^29.5.2",
      "@types/node": "^20.3.1",
      "@types/supertest": "^6.0.0",
      "@typescript-eslint/eslint-plugin": "^7.0.0",
      "@typescript-eslint/parser": "^7.0.0",
      "drizzle-kit": "^0.23.0",
      "eslint": "^8.42.0",
      "eslint-config-prettier": "^9.0.0",
      "eslint-plugin-prettier": "^5.0.0",
      "jest": "^29.5.0",
      "prettier": "^3.0.0",
      "source-map-support": "^0.5.21",
      "supertest": "^7.0.0",
      "ts-jest": "^29.1.0",
      "ts-loader": "^9.4.3",
      "ts-node": "^10.9.1",
      "tsconfig-paths": "^4.2.0",
      "typescript": "^5.1.3"
   },
   "jest": {
      "moduleFileExtensions": [
         "js",
         "json",
         "ts"
      ],
      "rootDir": "src",
      "testRegex": ".*\\.spec\\.ts$",
      "transform": {
         "^.+\\.(t|j)s$": "ts-jest"
      },
      "collectCoverageFrom": [
         "**/*.(t|j)s"
      ],
      "coverageDirectory": "../coverage",
      "testEnvironment": "node"
   }
}
</file>

<file path="apps/backend/README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).
</file>

<file path="apps/backend/transactions.json">
[]
</file>

<file path="apps/backend/tsconfig.build.json">
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
</file>

<file path="apps/backend/tsconfig.json">
{
   // "extends": "../../tsconfig.json",
   "compilerOptions": {
      "module": "commonjs",
      "declaration": true,
      "removeComments": true,
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "allowSyntheticDefaultImports": true,
      "target": "ES2021",
      "sourceMap": true,
      "outDir": "./dist",
      "baseUrl": "./",
      "incremental": true,
      "skipLibCheck": true,
      "strictNullChecks": false,
      "noImplicitAny": false,
      "strictBindCallApply": false,
      "forceConsistentCasingInFileNames": false,
      "noFallthroughCasesInSwitch": false,
      "paths": {
         "shared-types/*": ["../../packages/shared-types/src/*"]
      }
   }
}
</file>

<file path="apps/frontend/.gitignore">
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
</file>

<file path="apps/frontend/.prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
</file>

<file path="apps/frontend/.prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 120,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}
</file>

<file path="apps/frontend/eslint.config.js">
import js from '@eslint/js';
import ts from 'typescript-eslint';
import svelte from 'eslint-plugin-svelte';
import prettier from 'eslint-config-prettier';
import globals from 'globals';

/** @type {import('eslint').Linter.Config[]} */
export default [
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
];
</file>

<file path="apps/frontend/package.json">
{
	"name": "frontend",
	"version": "0.0.1",
	"private": true,
	"scripts": {
		"dev": "cross-env HOST=custom.domain vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"test": "npm run test:integration && npm run test:unit",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"lint": "prettier --check . && eslint .",
		"format": "prettier --write .",
		"test:integration": "playwright test",
		"test:unit": "vitest"
	},
	"devDependencies": {
		"@playwright/test": "^1.28.1",
		"@sveltejs/adapter-auto": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^3.0.0",
		"@types/eslint": "^9.6.0",
		"@types/node": "^22.1.0",
		"autoprefixer": "^10.4.19",
		"cross-env": "^7.0.3",
		"eslint": "^9.0.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.36.0",
		"flowbite-svelte-icons": "^1.6.1",
		"globals": "^15.0.0",
		"postcss": "^8.4.40",
		"prettier": "^3.1.1",
		"prettier-plugin-svelte": "^3.1.2",
		"svelte": "^4.2.7",
		"svelte-check": "^3.6.0",
		"svelte-simples": "^1.0.3",
		"sveltekit-superforms": "^2.16.1",
		"tailwindcss": "^3.4.7",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.0.0",
		"vite": "^5.0.3",
		"vitest": "^2.0.0",
		"zod": "^3.23.8"
	},
	"type": "module",
	"dependencies": {
		"axios": "^1.7.2",
		"flowbite": "^2.4.1",
		"flowbite-svelte": "^0.46.15",
		"lucide-svelte": "^0.424.0",
		"shared-types": "^1.0.0",
		"svelte-french-toast": "^1.2.0"
	}
}
</file>

<file path="apps/frontend/playwright.config.ts">
import type { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},
	testDir: 'tests',
	testMatch: /(.+\.)?(test|spec)\.[jt]s/
};

export default config;
</file>

<file path="apps/frontend/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="apps/frontend/README.md">
# create-svelte

Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.
</file>

<file path="apps/frontend/svelte.config.js">
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://kit.svelte.dev/docs/integrations#preprocessors
	// for more information about preprocessors
	preprocess: vitePreprocess(),

	kit: {
		// adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://kit.svelte.dev/docs/adapters for more information about adapters.
		adapter: adapter(),
		alias: {
			$services: './src/services',
			$components: './src/components',
			$stores: './src/stores',
			$utils: './src/utils',
			$schemas: './src/schemas'
		}
	}
};

export default config;
</file>

<file path="apps/frontend/tailwind.config.js">
import flowbitePlugin from 'flowbite/plugin';

/** @type {import('tailwindcss').Config} */
export default {
	content: [
		'./src/**/*.{html,js,svelte,ts}',
		'../../node_modules/flowbite-svelte/**/*.{html,js,svelte,ts}'
	],
	darkMode: 'selector',
	theme: {
		extend: {
			colors: {
				// flowbite-svelte
				primary: {
					50: '#FFF5F2',
					100: '#FFF1EE',
					200: '#FFE4DE',
					300: '#FFD5CC',
					400: '#FFBCAD',
					500: '#FE795D',
					600: '#EF562F',
					700: '#EB4F27',
					800: '#CC4522',
					900: '#A5371B'
				}
			}
		}
	},

	plugins: [flowbitePlugin]
};
</file>

<file path="apps/frontend/tsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	// except $lib which is handled by https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}
</file>

<file path="apps/frontend/vite.config.ts">
import { sveltekit } from '@sveltejs/kit/vite';
import { defineConfig } from 'vitest/config';

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	},
	server: {
		host: 'example.com',
		port: 80
	}
});
</file>

<file path="packages/shared-types/package.json">
{
   "name": "shared-types",
   "version": "1.0.0",
   "main": "index.js",
   "scripts": {
      "build": "tsc"
   },
   "keywords": [],
   "author": "",
   "license": "ISC",
   "description": "",
   "dependencies": {
      "backend": "^0.0.1",
      "drizzle-orm": "^0.32.2",
      "postgres": "^3.4.4",
      "typescript": "^5.5.4",
      "valibot": "^0.37.0"
   }
}
</file>

<file path="packages/shared-types/tsconfig.json">
{
   "compilerOptions": {
      "declaration": true,
      "emitDeclarationOnly": true,
      "outDir": "dist",
      "rootDir": "src",
      "strict": true
   },
   "include": ["src"]
}
</file>

<file path="apps/backend/src/app.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
    });
  });
});
</file>

<file path="apps/backend/src/app.controller.ts">
import { Controller, Get } from '@nestjs/common'
import { AppService } from './app.service'

@Controller()
export class AppController {
   constructor(private readonly appService: AppService) {}

   @Get()
   getHello(): string {
      return this.appService.getHello()
   }
}
</file>

<file path="apps/backend/src/app.module.ts">
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { DrizzleModule } from './drizzle/drizzle.module'
import { UserModule } from './user/user.module'
import { SolanaModule } from './blockchain/solana/solana.module'
import { AuthModule } from './auth/auth.module'
import { PassportModule } from '@nestjs/passport'

@Module({
   imports: [
      PassportModule.register({
         session: true,
      }),
      DrizzleModule,
      UserModule,
      SolanaModule,
      AuthModule,
   ],
   controllers: [AppController],
   providers: [AppService],
})
export class AppModule {}
</file>

<file path="apps/backend/src/app.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }
}
</file>

<file path="apps/backend/src/main.ts">
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import 'dotenv/config'
import * as session from 'express-session'
import * as passport from 'passport'

async function bootstrap() {
   const app = await NestFactory.create(AppModule)
   app.use(
      session({
         secret: 'my-secret',
         resave: false,
         saveUninitialized: false,
         cookie: {
            httpOnly: true,
            maxAge: 3600000,
            secure: false, // Set to true if you are using HTTPS
            sameSite: 'lax',
         },
      }),
   )
   app.use(passport.initialize())
   app.use(passport.session())

   app.enableCors({
      origin: 'http://example.com', // Adjust the origin according to where your front-end is hosted
      methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
      allowedHeaders: 'Content-Type, Accept',
      credentials: true,
   })
   await app.listen(3000)
}
bootstrap()
</file>

<file path="apps/backend/test/app.e2e-spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });
});
</file>

<file path="apps/backend/test/jest-e2e.json">
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
</file>

<file path="apps/frontend/src/app.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
	input[type='number']::-webkit-inner-spin-button,
	input[type='number']::-webkit-outer-spin-button {
		-webkit-appearance: none;
		margin: 0;
	}
	input[type='number'] {
		appearance: textfield;
	}
}

.manrope {
	font-family: 'Manrope', sans-serif;
}

.audiowide {
	font-family: 'Audiowide', sans-serif;
}

.quicksand {
	font-family: 'Quicksand', sans-serif;
}

body {
	background-color: #121528;
	min-height: 100vh;
}

.form-padding {
	padding-left: 1rem;
	padding-right: 1rem;
}
</file>

<file path="apps/frontend/src/app.d.ts">
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		interface Locals {
			user: {
				id: number;
				createdAt: string;
			};
		}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="apps/frontend/src/app.html">
<!doctype html>
<html lang="en" class="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Audiowide&family=Manrope:wght@200..800&family=Quicksand:wght@300..700&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap"
			rel="stylesheet"
		/>

		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path="apps/frontend/src/hooks.server.ts">
// import { PUBLIC_BACKEND_URL } from '$env/static/public';
// import type { Handle } from '@sveltejs/kit';

// export const handle: Handle = async ({ event, resolve }) => {
// 	if (event.cookies.get('connect.sid')) {
// 		const res = await fetch(PUBLIC_BACKEND_URL + '/user/status', {
// 			credentials: 'include',
// 			headers: {
// 				Cookie: 'connect.sid=' + event.cookies.get('connect.sid')
// 			}
// 		});
// 		const data = await res.json();
// 		if (res.ok) {
// 			event.locals.user = data;
// 		}
// 	}
// 	const response = await resolve(event);
// 	return response;
// };
</file>

<file path="apps/frontend/src/index.test.ts">
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});
</file>

<file path="packages/shared-types/src/autoSell.interface.ts">
export enum AutoSellStrategy {
   SIMPLE = "simple",
   GRID = "grid",
}

export interface SimpleStrategyParams {
   profitPercentage: number;
   lossPercentage: number;
}

export interface ProfitTarget {
   multiplier: number;
   sellPercentage: number;
}

export interface GridStrategyParams {
   stopLossType: "static" | "trailing" | "breakeven";
   stopLossPercentage: number;
   profitTargets: ProfitTarget[];
}

export interface AutoSellDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountToSell: string;
   strategy: AutoSellStrategy;
   strategyParams: SimpleStrategyParams | GridStrategyParams;
   initialPrice: number;
}
</file>

<file path="packages/shared-types/src/drizzle.types.ts">
import {
   usersTable,
   authProvidersTable,
   userWalletsTable,
   autoSellTable,
   tokenPairInfo,
   tokenPairTransactionsTable,
   dexTransactionsTable,
   dexTransactionsErrorsTable,
} from "backend/src/drizzle/schema";

export type InsertUser = typeof usersTable.$inferInsert;
export type SelectUser = typeof usersTable.$inferSelect;

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert;
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect;

export type InsertUserWallet = typeof userWalletsTable.$inferInsert;
export type SelectUserWallet = typeof userWalletsTable.$inferSelect;

export type InsertAutoSell = typeof autoSellTable.$inferInsert;
export type SelectAutoSell = typeof autoSellTable.$inferSelect;

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert;
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect;

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert;
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect;

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert;
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect;

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert;
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect;

export enum AutoSellStrategy {
   SIMPLE = "simple",
   GRID = "grid",
}

export interface SimpleStrategyParams {
   profitPercentage: number;
   lossPercentage: number;
}

export interface ProfitTarget {
   multiplier: number;
   sellPercentage: number;
}

export interface GridStrategyParams {
   stopLossType: "static" | "trailing" | "breakeven";
   stopLossPercentage: number;
   profitTargets: ProfitTarget[];
}

export interface AutoSellDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountToSell: string;
   strategy: AutoSellStrategy;
   strategyParams: SimpleStrategyParams | GridStrategyParams;
   initialPrice: number;
}
</file>

<file path="packages/shared-types/src/JupiterPriceResponse.interface.ts">
export interface JupiterPriceReponse {
   data: {
      [tokenAddress: string]: TokenPriceInfo;
   };
   timeTaken: number;
}

export interface TokenPriceInfo {
   id: string;
   mintSymbol: string;
   vsToken: string;
   vsTokenSymbol: string;
   price: number;
}
</file>

<file path="packages/shared-types/src/TelegramAuthData.interface.ts">
export interface TelegramAuthData {
   auth_date: number;
   first_name: string;
   hash: string;
   id: number;
   last_name: string;
}
</file>

<file path="packages/shared-types/src/tokenInfo.interface.ts">
export interface TokenInfo {
   name: string;
   symbol: string;
   address: string;
   decimals: number;
   image: string;
   totalSupply: number;
   totalSupplyPriceInUSD: number;
   oneTokenPriceInUSD: number;
   transactions: TokenTransactions[];
   mintAuthority: string | null;
   freezeAuthority: string | null;
   metadataChangeAuthority: string | null;
   uniqueHolders: number;
   topHolders: TokenHolderInfo[];
   totalLiquidtyInUSD: number;
   topHoldersTokenSupplyDistribution: TopHoldersTokenSupplyDistribution;
   verifiedDexScreener: boolean;
   verifiedBirdEye: boolean;
   dexesBeingTradedOn: string[];
   socialMediaLinks: URLInfo[];
   tokenPairsInLP?: TokenPairsInLP[];
}

export interface TokenPairsInLP {
   primaryTokenName: "WSOL" | "USDC";
   primaryTokenAmountInLP: number;
   primaryTokenAmountInLPUSD: number;
   secondaryTokenAmountInLP: number;
   secondaryTokenAmountInLPUSD: number;
   initialPrimaryTokenInLP: number;
   initialSecondaryTokenInLP: number;
   percentageOfTotalSupplyLockedInLP: number;
   percentageOfTotalSupplyLockedInLPUSD: number;
   createdOnPumpFun: boolean;
   timestamp: Date;
   tokenPairCreator: string;
   areTokensLockedInLP: boolean;
   dexName: "Raydium";
}

export interface TokenHolderInfo {
   address: string;
   balance: number;
   worthInUSD: number;
   percentageOfTotalSupply: number;
}

export interface TokenTransactions {
   time: "5m" | "1h" | "6h" | "12h" | "24h";
   txCount: string;
   volume: number;
   volumeInUSD: number;
   uniqueWallets: number;
   buys: number;
   sells: number;
   buyVolumeInUSD: number;
   sellVolumeInUSD: number;
   buyers: number;
   sellers: number;
}

export interface TopTradersHoldingPercentageOfWholeSupply {
   topTradersLimit: "5" | "10" | "15" | "20";
   percentageSummed: number;
}

export interface TopHoldersTokenSupplyDistribution {
   top5: number;
   top10: number;
   top15: number;
   top20: number;
}

export type URLInfo = {
   url: string;
   platform?: string;
};
</file>

<file path="packages/shared-types/src/userInfo.interface.ts">
// This file could be placed in a shared directory accessible by both frontend and backend

import { AutoSellPreset } from "./zodSchemas/BuyTokenFormSchema";

export interface UserWalletInfo {
   solBalance: number;
   address: string;
   name: string;
}

export interface UserDto {
   wallets: UserWalletInfo[];
   autoSellPresets: AutoSellPreset[];
}
</file>

<file path="apps/frontend/tests/test.ts">
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});
</file>

<file path="apps/backend/src/auth/auth.controller.ts">
import { Controller, UseGuards, Request, Post } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthGuard } from '@nestjs/passport'
import { JwtService } from '@nestjs/jwt'
import { UserService } from 'src/user/user.service'
import { TelegramGuard } from './utils/telegram.guard'

@Controller('auth')
export class AuthController {
   constructor(
      private authService: AuthService,
      private jwtService: JwtService,
      private userService: UserService,
   ) {}

   @UseGuards(TelegramGuard)
   @Post('loginWithTelegram')
   async loginWithTelegram(@Request() req) {
      return req.user
   }

   @UseGuards(AuthGuard('local'))
   @Post('login')
   async login(@Request() req) {
      const user = req.user
      const payload = { username: user.username, sub: user.userId }
      return {
         access_token: this.jwtService.sign(payload),
      }
   }

   // @Post('store-key')
   // async storePrivateKey(@Body() body: any, @Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.authService.encryptPrivateKey(body.privateKey)
   //    await this.userService.storeEncryptedPrivateKey(userId, encryptedPrivateKey)
   //    return { message: 'Private key stored successfully' }
   // }

   // @Get('retrieve-key')
   // async retrievePrivateKey(@Request() req) {
   //    const userId = req.user.id
   //    const encryptedPrivateKey = await this.userService.getEncryptedPrivateKey(userId)
   //    if (!encryptedPrivateKey) {
   //       return { message: 'Private key not found' }
   //    }
   //    const privateKey = await this.authService.decryptPrivateKey(encryptedPrivateKey)
   //    return { privateKey }
   // }
}
</file>

<file path="apps/backend/src/auth/auth.module.ts">
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { PassportModule } from '@nestjs/passport'
import { JwtModule } from '@nestjs/jwt'
import { JwtStrategy } from './strategies/jwt.tstrategy'
import { TelegramStrategy } from './strategies/telegram.strategy'
import { UserModule } from 'src/user/user.module'
import { SessionSerializer } from './strategies/SessionSerializer'

@Module({
   imports: [
      PassportModule,
      JwtModule.register({
         secret: process.env.JWT_SECRET,
         signOptions: { expiresIn: '1d' },
      }),
      UserModule,
   ],
   providers: [AuthService, JwtStrategy, TelegramStrategy, SessionSerializer],
   controllers: [AuthController],
})
export class AuthModule {}
</file>

<file path="apps/backend/src/auth/auth.service.ts">
import { Injectable } from '@nestjs/common'
import { UserService } from 'src/user/user.service'
import * as crypto from 'crypto'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { InsertUser, SelectUser } from 'src/drizzle/schema'

@Injectable()
export class AuthService {
   constructor(private userService: UserService) {}

   async validateTelegramUser(telegramAuthData: TelegramAuthData): Promise<SelectUser> {
      let user = await this.userService.findByTelegramId(telegramAuthData.id)
      if (!user) {
         // Create a new user if it doesn't exist
         const insertUserData: InsertUser = {}
         user = await this.userService.create(insertUserData, {
            provider: 'telegram',
            providerId: telegramAuthData.id.toString(),
         })
      }
      return user
   }

   async encryptPrivateKey(privateKey: string): Promise<string> {
      const cipher = crypto.createCipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let encrypted = cipher.update(privateKey, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return encrypted
   }

   async decryptPrivateKey(encryptedPrivateKey: string): Promise<string> {
      const decipher = crypto.createDecipher('aes-256-cbc', process.env.ENCRYPTION_KEY)
      let decrypted = decipher.update(encryptedPrivateKey, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}
</file>

<file path="apps/backend/src/drizzle/drizzle.module.ts">
import { Module } from '@nestjs/common'
import { drizzleProvider } from './drizzle.provider'

@Module({
   providers: [...drizzleProvider],
})
export class DrizzleModule {}
</file>

<file path="apps/backend/src/drizzle/drizzle.provider.ts">
import { drizzle } from 'drizzle-orm/postgres-js'
import * as postgres from 'postgres'
import * as schema from './schema'

export const DrizzleAsyncProvider = 'drizzleProvider'

export const drizzleProvider = [
   {
      provide: DrizzleAsyncProvider,
      useFactory: async () => {
         const client = postgres(process.env.DATABASE_URL)
         const db = drizzle(client, { schema })
         return db
      },
      exports: [DrizzleAsyncProvider],
   },
]
</file>

<file path="apps/backend/src/drizzle/schema.ts">
import { pgTable, pgEnum } from 'drizzle-orm/pg-core'
import { serial, varchar, text, integer, numeric, boolean, timestamp, unique, jsonb } from 'drizzle-orm/pg-core'
import { AutoSellPreset, AutoSellStrategy } from 'shared-types/zodSchemas/BuyTokenFormSchema'

// Enum for TokenTransactions time
export const timeEnum = pgEnum('time', ['5m', '1h', '6h', '12h', '24h'])
export const dexTransactionTypeEnum = pgEnum('dex_transaction_type', ['buy', 'sell', 'add_liquidity', 'remove_liquidity', 'init_lp'])
export const primaryTokenNameEnum = pgEnum('primary_token_name', ['WSOL', 'USDC'])
export const dexNameEnum = pgEnum('dex_name', ['Raydium'])
export const authProviderEnum = pgEnum('auth_provider', ['telegram', 'discord', 'google', 'twitter'])
export const autoSellStrategyEnum = pgEnum('auto_sell_strategy', ['simple', 'grid'])

export const usersTable = pgTable('users_table', {
   id: serial('id').primaryKey(),
   createdAt: timestamp('created_at').notNull().defaultNow(),
   autoSellPresets: jsonb('presets').$type<AutoSellPreset[]>(),
})

export const authProvidersTable = pgTable(
   'auth_providers',
   {
      id: serial('id').primaryKey(),
      provider: authProviderEnum('provider').notNull(),
      providerId: text('provider_id').notNull(),
      userId: integer('user_id')
         .notNull()
         .references(() => usersTable.id),
   },
   (t) => ({
      unq: unique().on(t.provider, t.providerId),
   }),
)

export const userWalletsTable = pgTable('user_wallets', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletAddress: varchar('wallet_address', { length: 44 }).notNull(),
   walletPk: varchar('wallet_pk', { length: 225 }).notNull(),
   name: varchar('name', { length: 50 }).notNull(),
})

export const autoSellTable = pgTable('auto_sell', {
   id: serial('id').primaryKey(),
   userId: integer('user_id')
      .notNull()
      .references(() => usersTable.id),
   walletId: integer('wallet_id')
      .notNull()
      .references(() => userWalletsTable.id),
   tokenAddressToSell: varchar('token_address_to_sell', { length: 44 }).notNull(),
   slippage: numeric('slippage').notNull(),
   tokenAmountBought: varchar('token_amount_bought', { length: 40 }).notNull(),
   tokenAmountSold: varchar('token_amount_sold', { length: 40 }).notNull(),
   strategy: autoSellStrategyEnum('strategy').notNull(),
   strategyParams: jsonb('strategy_params').$type<AutoSellStrategy>().notNull(),
   initialPriceExpressedInSol: varchar('initial_price_expressed_in_sol', { length: 100 }).notNull(),
   highestPriceExpressedInSol: varchar('highest_price_expressed_in_sol', { length: 100 }),
   createdAt: timestamp('created_at').notNull().defaultNow(),
   updatedAt: timestamp('updated_at').notNull().defaultNow(),
})

// TokenInfo Table
export const tokenPairInfo = pgTable('token_pair_info', {
   id: serial('id').primaryKey(),
   primaryTokenName: primaryTokenNameEnum('primary_token_name').notNull(),
   initialPrimaryTokenAmountInLP: numeric('initial_primary_token_in_lp').notNull(),
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(),
   initialSecondaryTokenAmountInLP: numeric('initial_secondary_token_in_lp').notNull(),
   tokenPairCreator: varchar('token_pair_creator', { length: 44 }),
   timestamp: timestamp('timestamp').notNull(),
   creationTransaction: varchar('creation_transaction', { length: 90 }).notNull(),
   verifiedDexScreener: boolean('verified_dex_screener'),
   verifiedBirdEye: boolean('verified_bird_eye'),
   dexName: dexNameEnum('dex_name').notNull(),
})

// TokenTransactions Table
export const tokenPairTransactionsTable = pgTable('token_pair_transactions', {
   id: serial('id').primaryKey(),
   tokenPairId: integer('token_pair_id').notNull(),
   time: timeEnum('time'),
   txCount: integer('tx_count'),
   volume: numeric('volume'),
   volumeInUSD: numeric('volume_in_usd'),
   uniqueWallets: integer('unique_wallets'),
   buys: integer('buys'),
   sells: integer('sells'),
   buyVolumeInUSD: numeric('buy_volume_in_usd'),
   sellVolumeInUSD: numeric('sell_volume_in_usd'),
   buyers: integer('buyers'),
   sellers: integer('sellers'),
})

export const dexTransactionsTable = pgTable('dex_transactions', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 90 }).notNull(),
   timestamp: timestamp('timestamp').notNull(),
   blockNumber: integer('block_number').notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   primaryTokenName: primaryTokenNameEnum('primary_token_address').notNull(), // WSOL or USDC
   primaryTokenAmount: numeric('primary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of WSOL or USDC
   primaryTokenPrice: numeric('primary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of WSOL or USDC
   secondaryTokenAddress: varchar('secondary_token_address', { length: 44 }).notNull(), // Random token
   secondaryTokenAmount: numeric('secondary_token_amount', { precision: 20, scale: 8 }).notNull(), // Amount of the random token
   secondaryTokenPrice: numeric('secondary_token_price', { precision: 20, scale: 8 }).notNull(), // Price of the random token
   transactionType: dexTransactionTypeEnum('transaction_type').notNull(), // Buy, Sell, AddLiquidity, RemoveLiquidity
   transactionValueInUsd: numeric('transaction_value_in_usd', { precision: 20, scale: 8 }).notNull(), // Value of the transaction in USD
   dexName: dexNameEnum('dex_name').notNull(), // Name of the DEX
   isUsingJupiter: boolean('is_using_jupiter').notNull(), // Whether Jupiter is used
})

export const dexTransactionsErrorsTable = pgTable('dex_transactions_errors', {
   id: serial('id').primaryKey(),
   transactionId: varchar('transaction_id', { length: 87 }).notNull(),
   signer: varchar('signer', { length: 44 }).notNull(),
   error: text('error').notNull(),
   dexName: dexNameEnum('dex_name').notNull(),
})

// Relations
// export const tokenInfoRelations = relations(tokenPairInfo, ({ one, many }) => ({
//    transactions: many(tokenTransactionsTable),
// }))

// export const tokenTransactionsRelations = relations(tokenTransactionsTable, ({ one }) => ({
//    token: one(tokenPairInfo, {
//       fields: [tokenTransactionsTable.tokenAddress],
//       references: [tokenPairInfo.address],
//    }),
// }))

export type InsertUser = typeof usersTable.$inferInsert
export type SelectUser = typeof usersTable.$inferSelect

export type InsertAuthProvider = typeof authProvidersTable.$inferInsert
export type SelectAuthProvider = typeof authProvidersTable.$inferSelect

export type InsertUserWallet = typeof userWalletsTable.$inferInsert
export type SelectUserWallet = typeof userWalletsTable.$inferSelect

export type InsertTokenPairInfo = typeof tokenPairInfo.$inferInsert
export type SelectTokenPairInfo = typeof tokenPairInfo.$inferSelect

export type InsertTokenPairTransactions = typeof tokenPairTransactionsTable.$inferInsert
export type SelectTokenPairTransactions = typeof tokenPairTransactionsTable.$inferSelect

export type InsertDexTransactionLogs = typeof dexTransactionsTable.$inferInsert
export type SelectDexTransactionLogs = typeof dexTransactionsTable.$inferSelect

export type InsertDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferInsert
export type SelectDexTransactionErrors = typeof dexTransactionsErrorsTable.$inferSelect
</file>

<file path="apps/backend/src/encryption/encryption.module.ts">
import { Module } from '@nestjs/common'
import { EncryptionService } from './encryption.service'

@Module({
   providers: [EncryptionService],
   exports: [EncryptionService], // Export so it can be imported by other modules
})
export class EncryptionModule {}
</file>

<file path="apps/backend/src/encryption/encryption.service.ts">
import { Injectable } from '@nestjs/common'
import * as crypto from 'crypto'

@Injectable()
export class EncryptionService {
   private masterKey: Buffer // This should be securely loaded

   constructor() {
      const masterKeyHex = process.env.MASTER_KEY
      this.masterKey = Buffer.from(masterKeyHex, 'hex')
   }

   deriveKey(userSpecificData: string) {
      const salt = crypto.createHash('sha256').update(userSpecificData).digest()
      return crypto.pbkdf2Sync(this.masterKey, salt, 10000, 32, 'sha256')
   }

   encrypt(text: string, userSpecificData: string): string {
      const key = this.deriveKey(userSpecificData)
      const iv = crypto.randomBytes(16)
      const cipher = crypto.createCipheriv('aes-256-cbc', key, iv)
      let encrypted = cipher.update(text, 'utf8', 'hex')
      encrypted += cipher.final('hex')
      return iv.toString('hex') + ':' + encrypted
   }

   decrypt(encryptedText: string, userSpecificData: string): string {
      const textParts = encryptedText.split(':')
      const iv = Buffer.from(textParts[0], 'hex')
      const encrypted = textParts[1]
      const key = this.deriveKey(userSpecificData)
      const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)
      let decrypted = decipher.update(encrypted, 'hex', 'utf8')
      decrypted += decipher.final('utf8')
      return decrypted
   }
}
</file>

<file path="apps/backend/src/user/user.controller.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Controller, Get, Post, Body, Param, Delete, Session, UseGuards, Request } from '@nestjs/common'
import { UserService } from './user.service'
import { AuthenticatedGuard } from 'src/auth/utils/authenticated.guard'
import { BuyTokenDto } from 'shared-types/src/zodSchemas/BuyTokenFormSchema'
import { UserDto } from 'shared-types/src/userInfo.interface'
import { SolanaService } from 'src/blockchain/solana/solana.service'

@Controller('user')
export class UserController {
   constructor(
      private readonly userService: UserService,
      private readonly solanaService: SolanaService,
   ) {}

   @Get('status')
   @UseGuards(AuthenticatedGuard)
   status(@Request() req) {
      console.log('Here', req.user)
      return req.user
   }

   @UseGuards(AuthenticatedGuard)
   @Get('info')
   async getUserInfo(@Request() req): Promise<UserDto> {
      const userId = req.user.id
      const user = await this.userService.findById(userId)
      const wallets = await this.userService.getWallets(user)
      const walletBalances = await this.solanaService.getBalanceForMultipleAddresses(wallets.map((wallet) => wallet.walletAddress))

      return {
         wallets: wallets.map((wallet) => ({
            solBalance: walletBalances[wallet.walletAddress] / 10 ** 9,
            address: wallet.walletAddress,
            name: wallet.name,
         })),
         autoSellPresets: user.autoSellPresets ? user.autoSellPresets : [],
      }
   }

   @Post('buy-token')
   @UseGuards(AuthenticatedGuard)
   async buyToken(@Body() buyTokenDto: BuyTokenDto, @Request() req): Promise<void> {
      const { walletAddress, tokenAddress, inputAmount, slippage, prioritizationFeeLamports, autoSell } = buyTokenDto
      await this.userService.buyToken(req.user, walletAddress, tokenAddress, inputAmount, slippage, prioritizationFeeLamports, autoSell)
   }

   // @Post('sell-token')
   // @UseGuards(AuthenticatedGuard)
   // async sellToken(@Body() sellTokenDto: SellTokenDto, @Request() req): Promise<void> {
   //    const { walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports } = sellTokenDto
   //    await this.userService.sellToken(req.user, walletAddress, tokenAddress, tokenAmountIn, slippageInPercentage, prioritizationFeeLamports)
   // }
}
</file>

<file path="apps/backend/src/user/user.module.ts">
import { forwardRef, Module } from '@nestjs/common'
import { UserService } from './user.service'
import { UserController } from './user.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { EncryptionModule } from 'src/encryption/encryption.module'
import { SolanaModule } from 'src/blockchain/solana/solana.module'
import { SolanaSniperModule } from 'src/blockchain/solana/sniper/solanaSniper.module'

@Module({
   imports: [EncryptionModule, SolanaModule, forwardRef(() => SolanaSniperModule)],
   controllers: [UserController],
   providers: [UserService, ...drizzleProvider],
   exports: [UserService],
})
export class UserModule {}
</file>

<file path="apps/backend/src/user/user.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Inject, Injectable } from '@nestjs/common'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { eq, and } from 'drizzle-orm'
import { EncryptionService } from 'src/encryption/encryption.service'
import { SolanaService } from 'src/blockchain/solana/solana.service'
import { InsertAutoSell } from 'shared-types/src/drizzle.types'
import { BuyTokenDto } from 'shared-types/src/zodSchemas/BuyTokenFormSchema'
import BigNumber from 'bignumber.js'
import { EntryCalculationService } from 'src/blockchain/solana/sniper/autoSell/entryCalculation.service'

@Injectable()
export class UserService {
   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private encryptionService: EncryptionService,
      private solanaService: SolanaService,
      private entryCalculationService: EntryCalculationService,
   ) {}

   async findById(id: number): Promise<schema.SelectUser | undefined> {
      const user = await this.db.select().from(schema.usersTable).where(eq(schema.usersTable.id, id)).limit(1)
      return user[0]
   }

   async findByTelegramId(telegramId: number): Promise<schema.SelectUser | undefined> {
      const subQuery = this.db
         .select()
         .from(schema.authProvidersTable)
         .where(eq(schema.authProvidersTable.providerId, telegramId.toString()))
         .limit(1)
         .as('sq')
      const user = await this.db.select().from(schema.usersTable).leftJoin(subQuery, eq(schema.usersTable.id, subQuery.userId)).limit(1)
      return user[0] === undefined ? undefined : user[0].users_table
   }

   async create(user: schema.InsertUser, authProvider: Omit<schema.InsertAuthProvider, 'userId'>): Promise<schema.SelectUser> {
      const newUser = await this.db.transaction(async (tx) => {
         const newUser = await tx.insert(schema.usersTable).values(user).returning()
         await tx.insert(schema.authProvidersTable).values({
            providerId: authProvider.providerId,
            provider: authProvider.provider,
            userId: newUser[0].id,
         })
         const newKeyPair = this.solanaService.createNewWallet()
         const encryptedPrivateKey = this.encryptionService.encrypt(
            this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
            newUser[0].createdAt.toISOString(),
         )
         await tx.insert(schema.userWalletsTable).values({
            userId: newUser[0].id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name: 'Main Wallet',
         })
         return newUser
      })
      return newUser[0]
   }

   async createWallet(user: schema.SelectUser, name: string): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.createNewWallet()
      const encryptedPrivateKey = this.encryptionService.encrypt(
         this.solanaService.privateKeyToBase58(newKeyPair.secretKey),
         user.createdAt.toISOString(),
      )
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name,
         })
         .returning()
      return wallet[0]
   }

   async importWalletFromPk(user: schema.SelectUser, privateKey: string, name: string): Promise<schema.SelectUserWallet> {
      const newKeyPair = this.solanaService.base58ToKeypair(privateKey)
      const encryptedPrivateKey = this.encryptionService.encrypt(privateKey, user.createdAt.toISOString())
      const wallet = await this.db
         .insert(schema.userWalletsTable)
         .values({
            userId: user.id,
            walletAddress: newKeyPair.publicKey.toString(),
            walletPk: encryptedPrivateKey,
            name,
         })
         .returning()
      return wallet[0]
   }

   async getWallets(user: schema.SelectUser): Promise<schema.SelectUserWallet[]> {
      const wallet = await this.db.select().from(schema.userWalletsTable).where(eq(schema.userWalletsTable.userId, user.id))
      console.log('privateKey', this.encryptionService.decrypt(wallet[0].walletPk, user.createdAt.toISOString()))
      return wallet
   }

   async getWalletByAddress(user: schema.SelectUser, walletAddress: string): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, user.id), eq(schema.userWalletsTable.walletAddress, walletAddress)))
         .limit(1)
      return wallet[0]
   }

   async getWalletById(userId: number, walletId: number): Promise<schema.SelectUserWallet | undefined> {
      const wallet = await this.db
         .select()
         .from(schema.userWalletsTable)
         .where(and(eq(schema.userWalletsTable.userId, userId), eq(schema.userWalletsTable.id, walletId)))
         .limit(1)
      return wallet[0]
   }

   async buyToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      solAmountInUi: number,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto',
      autoSell: BuyTokenDto['autoSell'],
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)
      const solAmount = new BigNumber(solAmountInUi).multipliedBy(10 ** 9)
      try {
         const { outputAmount, outputAmountUi } = await this.solanaService.makeJupiterSwapTransaction(
            this.solanaService.knownAddresses.WSOL,
            tokenAddress,
            solAmount,
            slippageInPercentage * 100,
            this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
            prioritizationFeeLamports,
         )

         if (outputAmount === undefined || outputAmountUi === undefined || outputAmount.isZero() || outputAmountUi.isZero()) {
            return
         }

         console.log('outputAmount', outputAmount.toString())
         console.log('outputAmountUi', outputAmountUi.toString())
         console.log('initialPriceExpressedInSol', new BigNumber(solAmountInUi).div(outputAmountUi).toString())

         if (autoSell.enabled) {
            await this.entryCalculationService.addAutoSellEntry({
               initialPriceExpressedInSol: new BigNumber(solAmountInUi).div(outputAmountUi).toString(),
               highestPriceExpressedInSol: new BigNumber(solAmountInUi).div(outputAmountUi).toString(),
               slippage: slippageInPercentage.toString(),
               strategy: autoSell.strategy.strategyName,
               strategyParams: autoSell.strategy,
               tokenAddressToSell: tokenAddress,
               tokenAmountBought: outputAmount.toString(),
               tokenAmountSold: '0',
               userId: user.id,
               walletId: wallet.id,
            })
         }
      } catch (error) {
         console.error('Failed to buy token:', error)
      }
   }

   async sellToken(
      user: schema.SelectUser,
      walletAddress: string,
      tokenAddress: string,
      tokenAmountIn: string,
      slippageInPercentage: number,
      prioritizationFeeLamports: number | 'auto' = 'auto',
   ): Promise<void> {
      const wallet = await this.getWalletByAddress(user, walletAddress)

      // await this.solanaService.makeJupiterSwapTransaction(
      //    tokenAddress,
      //    this.solanaService.knownAddresses.WSOL,
      //    parseFloat(tokenAmountIn),
      //    slippageInPercentage * 100,
      //    this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
      //    prioritizationFeeLamports,
      // )
   }
}
</file>

<file path="apps/frontend/src/components/TelegramLoginWidget.svelte">
<script lang="ts">
	import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { goto } from '$app/navigation';

	async function onTelegramAuth(user: TelegramAuthData) {
		console.log(JSON.stringify(user));
		const res = await fetch(PUBLIC_BACKEND_URL + '/auth/loginWithTelegram', {
			method: 'POST',
			body: JSON.stringify(user),
			credentials: 'include',
			headers: {
				'Content-Type': 'application/json'
			}
		});
		if (res.ok) {
			const data = await res.json();
			goto('/dashboard');
		} else {
			console.error('Failed to login with Telegram');
		}
	}

	// Svelte action to load the Telegram widget
	function loadTelegramWidget(node: HTMLElement) {
		if (typeof window !== 'undefined') {
			window.onTelegramAuth = onTelegramAuth;

			const script = document.createElement('script');
			script.src = 'https://telegram.org/js/telegram-widget.js?7';
			script.async = true;
			script.setAttribute('data-telegram-login', 'SolanaCryptoTradingTestBot');
			script.setAttribute('data-size', 'large');
			script.setAttribute('data-radius', '10');
			script.setAttribute('data-onauth', 'onTelegramAuth(user)');
			script.setAttribute('data-userpic', 'false');
			node.appendChild(script);
		}
	}
</script>

<div class="telegram-login" use:loadTelegramWidget></div>

<style>
	div {
		width: 100%;
		display: flex;
		justify-content: center;
	}
</style>
</file>

<file path="apps/frontend/src/lib/api.ts">
import axios from 'axios';
// import { token } from '../stores/auth';
import { PUBLIC_BACKEND_URL } from '$env/static/public';

// let jwtToken = '';
// token.subscribe((value: string) => {
// 	jwtToken = value;
// });

const api = axios.create({
	baseURL: PUBLIC_BACKEND_URL
});

api.interceptors.request.use((config) => {
	// if (jwtToken) {
	// 	config.headers.Authorization = `Bearer ${jwtToken}`;
	// }
	config.withCredentials = true;
	return config;
});

export default api;
</file>

<file path="apps/frontend/src/lib/autoSellPresets.ts">
import type {
	AutoSellStrategy,
	GridBreakEvenAutoSellPreset,
	GridStaticAutoSellPreset,
	GridTrailingAutoSellPreset,
	SimpleAutoSellPreset
} from 'shared-types/src/zodSchemas/BuyTokenFormSchema';

export const defaultSimpleAutoSell: SimpleAutoSellPreset = {
	strategyName: 'simple',
	profitPercentage: 10,
	stopLossPercentage: 5
};

export const defaultGridStaticAutoSell: GridStaticAutoSellPreset = {
	strategyName: 'grid',
	stopLossType: 'static',
	stopLossPercentage: 5,
	profitTargets: [
		{ multiplier: 1.1, sellPercentage: 20 },
		{ multiplier: 1.3, sellPercentage: 30 },
		{ multiplier: 1.5, sellPercentage: 50 }
	]
};

export const defaultGridTrailingAutoSell: GridTrailingAutoSellPreset = {
	strategyName: 'grid',
	stopLossType: 'trailing',
	stopLossPercentage: 5,
	profitTargets: [
		{ multiplier: 1.1, sellPercentage: 20, trailingStopLossAfter: 10 },
		{ multiplier: 1.3, sellPercentage: 30, trailingStopLossAfter: 15 },
		{ multiplier: 1.5, sellPercentage: 50, trailingStopLossAfter: 20 }
	]
};

export const defaultGridBreakEvenAutoSell: GridBreakEvenAutoSellPreset = {
	strategyName: 'grid',
	stopLossType: 'breakeven',
	stopLossPercentage: 5,
	profitTargets: [
		{ multiplier: 1.1, sellPercentage: 20 },
		{ multiplier: 1.3, sellPercentage: 30 },
		{ multiplier: 1.5, sellPercentage: 50 }
	]
};

export function initializeAutoSell(preset?: AutoSellStrategy): AutoSellStrategy {
	if (!preset) {
		return defaultSimpleAutoSell; // Or whichever default you prefer
	}
	return preset;
}
</file>

<file path="apps/frontend/src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="apps/frontend/src/lib/VolatileMarketStrategy.ts">
// src/lib/VolatileMarketStrategy.ts

export interface VolatileMarketStrategy {
	initialStopLoss: number;
	quickProfitTarget: number;
	trailingStopLoss: number;
	volumeThreshold: number;
	timeBasedExit: number; // in milliseconds
}

export interface Projection {
	scenario: string;
	profitLoss: number;
	profitLossPercentage: number;
}

export class VolatileTokenTrader {
	private strategy: VolatileMarketStrategy;
	private entryPrice: number;
	private entryTime: number;
	private highestPrice: number;
	private currentStopLoss: number;

	constructor(strategy: VolatileMarketStrategy, entryPrice: number) {
		this.strategy = strategy;
		this.entryPrice = entryPrice;
		this.entryTime = Date.now();
		this.highestPrice = entryPrice;
		this.currentStopLoss = entryPrice * (1 - strategy.initialStopLoss);
	}

	updatePrice(currentPrice: number, currentVolume: number): string {
		this.highestPrice = Math.max(this.highestPrice, currentPrice);

		// Check for quick profit target
		if (currentPrice >= this.entryPrice * (1 + this.strategy.quickProfitTarget)) {
			return 'SELL_PARTIAL';
		}

		// Update trailing stop loss
		const newStopLoss = this.highestPrice * (1 - this.strategy.trailingStopLoss);
		this.currentStopLoss = Math.max(this.currentStopLoss, newStopLoss);

		// Check if stop loss is hit
		if (currentPrice <= this.currentStopLoss) {
			return 'SELL_ALL';
		}

		// Check volume-based exit
		if (currentVolume < this.strategy.volumeThreshold) {
			return 'VOLUME_ALERT';
		}

		// Check time-based exit
		if (Date.now() - this.entryTime > this.strategy.timeBasedExit) {
			return 'TIME_EXIT';
		}

		return 'HOLD';
	}

	getCurrentStopLoss(): number {
		return this.currentStopLoss;
	}
}

export function calculateProjections(strategy: VolatileMarketStrategy, initialInvestment: number): Projection[] {
	const projections: Projection[] = [];

	// Worst-case scenario: Initial stop loss hit
	projections.push({
		scenario: 'Worst Case (Stop Loss Hit)',
		profitLoss: -initialInvestment * strategy.initialStopLoss,
		profitLossPercentage: -strategy.initialStopLoss * 100
	});

	// Best-case scenario: Quick profit target hit, then trailing stop loss at 2x initial price
	projections.push({
		scenario: 'Best Case (Quick Profit + Continued Growth)',
		profitLoss: initialInvestment * (strategy.quickProfitTarget + 1),
		profitLossPercentage: (strategy.quickProfitTarget + 1) * 100
	});

	// Moderate case: Quick profit target hit, then immediate reversal
	projections.push({
		scenario: 'Moderate Case (Quick Profit Only)',
		profitLoss: initialInvestment * strategy.quickProfitTarget,
		profitLossPercentage: strategy.quickProfitTarget * 100
	});

	// Time-based exit scenario: Assuming 10% growth before time exit
	projections.push({
		scenario: 'Time-Based Exit (10% Growth)',
		profitLoss: initialInvestment * 0.1,
		profitLossPercentage: 10
	});

	// Volume-based exit scenario: Assuming 5% growth before volume drop
	projections.push({
		scenario: 'Volume-Based Exit (5% Growth)',
		profitLoss: initialInvestment * 0.05,
		profitLossPercentage: 5
	});

	return projections;
}
</file>

<file path="apps/frontend/src/routes/+layout.svelte">
<script lang="ts">
	import '../app.css';
	export let data;

	$: console.log(data);
</script>

<slot />
</file>

<file path="apps/frontend/src/routes/+page.svelte">
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import { Card } from 'flowbite-svelte';
	async function getStatus() {
		const res = await fetch(PUBLIC_BACKEND_URL + '/user', {
			credentials: 'include'
		});
		const data = await res.json();
		console.log(data);
	}
</script>

<h1 class="text-3xl font-bold underline">Hello world!</h1>

<TelegramLoginWidget />

<button on:click={getStatus}> GET STATUS</button>

<Card href="/cards">
	<h5 class="mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
		Noteworthy technology acquisitions 2021
	</h5>
	<p class="font-normal text-gray-700 dark:text-gray-400 leading-tight">
		Here are the biggest enterprise technology acquisitions of 2021 so far, in reverse chronological
		order.
	</p>
</Card>

<style lang="postcss">
	:global(html) {
		background-color: theme(colors.gray.100);
	}
</style>
</file>

<file path="apps/frontend/src/services/priceUpdateService.ts">
import api from '../lib/api';
import { tokenPricesInUSD } from '$stores/priceStore';
import { type JupiterPriceReponse } from 'shared-types/src/JupiterPriceResponse.interface';

export const priceUpdateService = {
	tokenAddressesToFetchPrice: ['So11111111111111111111111111111111111111112'],
	vsToken: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
	priceFetchingInterval: 10000,
	priceFetchingIntervalId: null as number | NodeJS.Timeout | null,

	async fetchPriceUpdate() {
		const response = await api.get<JupiterPriceReponse>(`/solana/price`, {
			params: {
				tokenAddresses: this.tokenAddressesToFetchPrice.join(','),
				vsToken: this.vsToken
			}
		});
		for (const tokenAddress in response.data.data) {
			tokenPricesInUSD.update((tokenPricesInUsd) => {
				tokenPricesInUsd[tokenAddress] = response.data.data[tokenAddress].price;
				return tokenPricesInUsd;
			});
		}
	},

	reset() {
		this.removeAllTokensExceptDefault();
		this.stopPriceUpdate();
	},

	removeAllTokensExceptDefault() {
		this.tokenAddressesToFetchPrice = ['So11111111111111111111111111111111111111112'];
	},

	addNewTokenAddressToFetchPrice(tokenAddress: string) {
		this.tokenAddressesToFetchPrice.push(tokenAddress);
	},

	async startPriceUpdate() {
		await this.fetchPriceUpdate();
		this.priceFetchingIntervalId = setInterval(() => {
			this.fetchPriceUpdate();
		}, this.priceFetchingInterval);
	},

	stopPriceUpdate() {
		if (this.priceFetchingIntervalId) {
			clearInterval(this.priceFetchingIntervalId as number);
		}
	}
};
</file>

<file path="apps/frontend/src/services/tokenService.ts">
import type { TokenInfo } from 'shared-types/src/tokenInfo.interface';
import api from '../lib/api';
import { defaultTokenInfo, tokenInfo } from '../stores/tokenStore';
import { priceUpdateService } from './priceUpdateService';

export const tokenService = {
	loading: false,
	async fetchTokenInfo(tokenAddress: string) {
		this.reset();
		this.loading = true;
		priceUpdateService.addNewTokenAddressToFetchPrice(tokenAddress);
		await priceUpdateService.startPriceUpdate();

		const response = await api.get(`/solanaToken/${tokenAddress}`);
		tokenInfo.update(() => response.data as TokenInfo);
		this.loading = false;
	},
	reset() {
		priceUpdateService.reset();
		tokenInfo.update(() => defaultTokenInfo);
	}
};
</file>

<file path="apps/frontend/src/services/tradingService.ts">
import api from '../lib/api';
import type { BuyTokenDto } from 'shared-types/src/zodSchemas/BuyTokenFormSchema';

export const tradingService = {
	async buyTokens(buyTokenFormData: BuyTokenDto) {
		await api.post(`/user/buy-token/`, buyTokenFormData);
	}
};
</file>

<file path="apps/frontend/src/types/global.d.ts">
// src/types/global.d.ts
import type { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface';

declare global {
	interface Window {
		onTelegramAuth: (user: TelegramAuthData) => void;
	}
}

export {};
</file>

<file path="apps/frontend/src/stores/auth.ts">
// import { writable } from 'svelte/store';

// export const token = writable(localStorage.getItem('token') || '');

// token.subscribe((value) => {
// 	if (value) {
// 		localStorage.setItem('token', value);
// 	} else {
// 		localStorage.removeItem('token');
// 	}
// });
</file>

<file path="apps/frontend/src/stores/formStore.ts">
import { writable } from 'svelte/store';

export function createForm(initialData: unknown) {
	const { subscribe, set, update } = writable(initialData);

	return {
		subscribe,
		updateFormData: (key: string, value: unknown) => {
			update(formData => {
				const keys = key.split('.');
				let current = formData;
				for (let i = 0; i < keys.length - 1; i++) {
					current = current[keys[i]];
				}
				current[keys[keys.length - 1]] = value;
				return formData;
			});
		},
		reset: () => set(initialData),
		formData: { subscribe }
	};
}
</file>

<file path="apps/frontend/src/stores/priceStore.ts">
import { writable, type Writable } from 'svelte/store';

interface TokenPricesInUsd {
	[tokenAddress: string]: number;
}

export const tokenPricesInUSD: Writable<TokenPricesInUsd> = writable({});
</file>

<file path="apps/frontend/src/stores/tokenStore.ts">
import { writable, type Writable } from 'svelte/store';
import { type TokenInfo } from 'shared-types/src/tokenInfo.interface';

export const defaultTokenInfo: TokenInfo = {
	name: '',
	symbol: '',
	address: '',
	decimals: 0,
	image: '',
	totalSupply: 0,
	totalSupplyPriceInUSD: 0,
	oneTokenPriceInUSD: 0,
	transactions: [],
	mintAuthority: null,
	freezeAuthority: null,
	metadataChangeAuthority: null,
	uniqueHolders: 0,
	topHolders: [],
	totalLiquidtyInUSD: 0,
	topHoldersTokenSupplyDistribution: {
		top5: 0,
		top10: 0,
		top15: 0,
		top20: 0
	},
	verifiedDexScreener: false,
	verifiedBirdEye: false,
	dexesBeingTradedOn: [],
	socialMediaLinks: [],
	tokenPairsInLP: []
};

export const tokenInfo: Writable<TokenInfo> = writable(defaultTokenInfo);
</file>

<file path="apps/frontend/src/stores/userStore.ts">
import { writable, type Writable } from 'svelte/store';
import { type UserDto } from 'shared-types/src/userInfo.interface';

export const defaultUserInfo: UserDto = {
	wallets: [],
	autoSellPresets: []
};

export const userInfo: Writable<UserDto> = writable(defaultUserInfo);
</file>

<file path="apps/frontend/src/utils/copyToClipboard.ts">
export async function copyToClipboard(text: string) {
	if (navigator.clipboard) {
		try {
			await navigator.clipboard.writeText(text);
			console.log('Text copied to clipboard using Clipboard API');
		} catch (err) {
			console.error('Failed to copy text using Clipboard API: ', err);
		}
	} else {
		// Fallback for older browsers
		fallbackCopyTextToClipboard(text);
	}
}

function fallbackCopyTextToClipboard(text: string) {
	const textArea = document.createElement('textarea');
	textArea.value = text;
	document.body.appendChild(textArea);
	textArea.focus();
	textArea.select();
	try {
		document.execCommand('copy');
		console.log('Text copied to clipboard using execCommand');
	} catch (err) {
		console.error('Failed to copy text using execCommand: ', err);
	}
	document.body.removeChild(textArea);
}
</file>

<file path="apps/frontend/src/utils/formatters.ts">
// utils/formatters.ts

export function formatNumber(num: number): string {
	return new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(num);
}

export function formatUSD(num: number): string {
	return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(num);
}

export function formatPercentage(num: number): string {
	return new Intl.NumberFormat('en-US', { style: 'percent', maximumFractionDigits: 2 }).format(num / 100);
}
</file>

<file path="packages/shared-types/src/dto/BuyToken.dto.ts">
import { InsertAutoSell } from "../drizzle.types";

export interface BuyTokenDto {
   walletAddress: string;
   tokenAddress: string;
   solAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
   autoSell?: Omit<InsertAutoSell, "tokenAmountToSell">; // Use 'any' or a more specific type if available
}
</file>

<file path="packages/shared-types/src/dto/SellToken.dto.ts">
export interface SellTokenDto {
   walletAddress: string;
   tokenAddress: string;
   tokenAmountIn: string;
   slippageInPercentage: number;
   prioritizationFeeLamports?: number | "auto";
}
</file>

<file path="packages/shared-types/src/zodSchemas/BuyTokenFormSchema.ts">
import {
   object,
   string,
   number,
   boolean,
   array,
   minLength,
   union,
   literal,
   minValue,
   maxValue,
   pipe,
   reduceItems,
   variant,
   InferInput,
   InferOutput,
   optional,
   transform,
   regex,
   maxLength,
   check,
} from "valibot";

const addressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;

const baseProfitTargetSchema = object({
   multiplier: pipe(number(), minValue(1)),
   sellPercentage: pipe(number(), minValue(0), maxValue(100)),
   done: optional(boolean()),
});

const trailingProfitTargetSchema = object({
   ...baseProfitTargetSchema.entries,
   trailingStopLossAfter: pipe(number(), minValue(0)),
});

const simpleAutoSellStrategy = object({
   strategyName: literal("simple"),
   profitPercentage: pipe(number(), minValue(0)),
   stopLossPercentage: pipe(number(), minValue(0)),
});

const baseGridAutoSellStrategy = object({
   strategyName: literal("grid"),
   stopLossPercentage: pipe(number(), minValue(0), maxValue(100)),
   profitTargets: pipe(
      array(baseProfitTargetSchema),
      check((array) => {
         const totalSellPercentage = array.reduce((sum, target) => sum + target.sellPercentage, 0);
         return totalSellPercentage <= 100;
      }, "Total sell percentage must be less than or equal to 100")
   ),
});

const staticStopLossGrid = object({
   ...baseGridAutoSellStrategy.entries,
   stopLossType: literal("static"),
});

const trailingStopLossGrid = object({
   ...baseGridAutoSellStrategy.entries,
   stopLossType: literal("trailing"),
   profitTargets: array(trailingProfitTargetSchema),
});

const breakEvenStopLossGrid = object({
   ...baseGridAutoSellStrategy.entries,
   stopLossType: literal("breakeven"),
});

const gridAutoSellStrategy = variant("stopLossType", [staticStopLossGrid, trailingStopLossGrid, breakEvenStopLossGrid]);

const autoSellStrategies = variant("strategyName", [simpleAutoSellStrategy, gridAutoSellStrategy]);

const autoSellSchema = object({
   enabled: boolean(),
   strategy: autoSellStrategies,
});

export const buyTokenFormSchema = object({
   walletAddress: pipe(string(), regex(addressRegex, "Invalid address"), minLength(32), maxLength(44)),
   tokenAddress: pipe(string(), regex(addressRegex, "Invalid address"), minLength(32), maxLength(44)),
   inputAmount: pipe(number(), minValue(0.0000001)),
   slippage: pipe(number(), minValue(0), maxValue(100)),
   prioritizationFeeLamports: pipe(number(), minValue(0)),
   autoSell: autoSellSchema,
});

const autoSellPresetSchema = object({
   name: string(),
   strategy: autoSellStrategies,
});

export type BuyTokenFormSchema = typeof buyTokenFormSchema;
export type BuyTokenDto = InferOutput<typeof buyTokenFormSchema>;

export type BaseProfitTarget = InferInput<typeof baseProfitTargetSchema>;
export type TrailingProfitTarget = InferInput<typeof trailingProfitTargetSchema>;

export type SimpleAutoSellPreset = InferInput<typeof simpleAutoSellStrategy>;
export type GridStaticAutoSellPreset = InferInput<typeof staticStopLossGrid>;
export type GridTrailingAutoSellPreset = InferInput<typeof trailingStopLossGrid>;
export type GridBreakEvenAutoSellPreset = InferInput<typeof breakEvenStopLossGrid>;
export type AutoSellStrategy = SimpleAutoSellPreset | GridStaticAutoSellPreset | GridTrailingAutoSellPreset | GridBreakEvenAutoSellPreset;

export type AutoSellPreset = InferInput<typeof autoSellPresetSchema>;
export type GridStrategy = GridStaticAutoSellPreset | GridTrailingAutoSellPreset | GridBreakEvenAutoSellPreset;

export function isSimpleAutoSell(autoSell: AutoSellStrategy): autoSell is SimpleAutoSellPreset {
   return autoSell.strategyName === "simple";
}

export function isGridStrategy(autoSell: AutoSellStrategy): autoSell is GridStrategy {
   return autoSell.strategyName === "grid";
}

export function isGridTrailingStopLoss(autoSell: GridStrategy): autoSell is GridTrailingAutoSellPreset {
   return autoSell.stopLossType === "trailing";
}
</file>

<file path="apps/backend/src/auth/strategies/jwt.tstrategy.ts">
import { Injectable } from '@nestjs/common'
import { PassportStrategy } from '@nestjs/passport'
import { Strategy, ExtractJwt } from 'passport-jwt'

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
   constructor() {
      super({
         jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
         ignoreExpiration: false,
         secretOrKey: 'your_jwt_secret', // Store this in an environment variable
      })
   }

   async validate(payload: any) {
      return { userId: payload.sub, username: payload.username }
   }
}
</file>

<file path="apps/backend/src/auth/strategies/SessionSerializer.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable } from '@nestjs/common'
import { PassportSerializer } from '@nestjs/passport'
import { SelectUser } from 'src/drizzle/schema'
import { UserService } from 'src/user/user.service'

@Injectable()
export class SessionSerializer extends PassportSerializer {
   constructor(private userService: UserService) {
      super()
   }
   serializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      console.log('serializeUser', user)
      done(null, user)
   }

   async deserializeUser(user: SelectUser, done: (err, user: SelectUser) => void) {
      const userDB = await this.userService.findById(user.id)
      // console.log('deserializeUser', userDB)
      return userDB ? done(null, userDB) : done(null, null)
   }
}
</file>

<file path="apps/backend/src/auth/strategies/telegram.strategy.ts">
import { PassportStrategy } from '@nestjs/passport'
import { Strategy } from 'passport-custom'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import * as crypto from 'crypto'
import { AuthService } from '../auth.service'
import { TelegramAuthData } from 'shared-types/src/TelegramAuthData.interface'
import { SelectUser } from 'src/drizzle/schema'
import { Request } from 'express'

@Injectable()
export class TelegramStrategy extends PassportStrategy(Strategy, 'telegram') {
   constructor(private authService: AuthService) {
      super()
   }

   async validate(request: Request): Promise<SelectUser> {
      const telegramAuthData: TelegramAuthData = request.body
      const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN

      if (!TELEGRAM_BOT_TOKEN) {
         throw new UnauthorizedException('Bot token is not set.')
      }

      const { hash, ...authDataWithoutHash } = telegramAuthData
      const dataCheckArray: string[] = []

      for (const [key, value] of Object.entries(authDataWithoutHash)) {
         dataCheckArray.push(`${key}=${value}`)
      }
      dataCheckArray.sort()

      const dataCheckString = dataCheckArray.join('\n')
      const secretKey = crypto.createHash('sha256').update(TELEGRAM_BOT_TOKEN).digest()

      const computedHash = crypto.createHmac('sha256', secretKey).update(dataCheckString).digest('hex')

      if (computedHash !== hash) {
         throw new UnauthorizedException('Data is NOT from Telegram')
      }

      if (Date.now() / 1000 - authDataWithoutHash.auth_date > 86400) {
         throw new UnauthorizedException('Data is outdated')
      }

      return await this.authService.validateTelegramUser(telegramAuthData)
   }
}
</file>

<file path="apps/backend/src/auth/utils/authenticated.guard.ts">
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'

@Injectable()
export class AuthenticatedGuard implements CanActivate {
   canActivate(context: ExecutionContext) {
      const request = context.switchToHttp().getRequest()
      return request.isAuthenticated()
   }
}
</file>

<file path="apps/backend/src/auth/utils/telegram.guard.ts">
import { ExecutionContext, Injectable } from '@nestjs/common'
import { AuthGuard } from '@nestjs/passport'

@Injectable()
export class TelegramGuard extends AuthGuard('telegram') {
   constructor() {
      super()
   }

   async canActivate(context: ExecutionContext): Promise<boolean> {
      const result: boolean = (await super.canActivate(context)) as boolean
      await super.logIn(context.switchToHttp().getRequest())
      return result
   }
}
</file>

<file path="apps/backend/src/common/interfaces/blockchain.interface.ts">
export interface BlockchainInterface {
   connect(): any
   getBalance(address: string): Promise<number>
   sendTransaction(transactionDetails: any): Promise<any>
}
</file>

<file path="apps/backend/src/common/interfaces/dexscreenerData.interface.ts">
export interface DexScreenerResponse {
   schemaVersion: string
   pairs: Pair[]
}

export interface Pair {
   chainId: string
   dexId: string
   url: string
   pairAddress: string
   labels?: string[]
   baseToken: Token
   quoteToken: Token
   priceNative: string
   priceUsd: string
   txns: Transactions
   volume: Volume
   priceChange: PriceChange
   liquidity: Liquidity
   fdv: number
   pairCreatedAt: number
   info?: Info
}

interface Token {
   address: string
   name: string
   symbol: string
}

interface Transactions {
   m5: TransactionDetail
   h1: TransactionDetail
   h6: TransactionDetail
   h24: TransactionDetail
}

interface TransactionDetail {
   buys: number
   sells: number
}

interface Volume {
   h24: number
   h6: number
   h1: number
   m5: number
}

interface PriceChange {
   m5: number
   h1: number
   h6: number
   h24: number
}

interface Liquidity {
   usd: number
   base: number
   quote: number
}

interface Info {
   imageUrl: string
   websites: Website[]
   socials: Social[]
}

interface Website {
   label: string
   url: string
}

interface Social {
   url: string
   type: string
}
</file>

<file path="apps/backend/src/common/helpers/convertDexscreenerData.ts">
import { Pair } from '../interfaces/dexscreenerData.interface'
import { TokenTransactions } from 'shared-types/src/tokenInfo.interface'

export function convertPairToTokenTransactions(pair: Pair): TokenTransactions[] {
   const transactions: TokenTransactions[] = [
      {
         time: '5m',
         txCount: `${pair.txns.m5.buys + pair.txns.m5.sells}`,
         volume: pair.volume.m5,
         volumeInUSD: pair.volume.m5 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder, real calculation requires additional data
         buys: pair.txns.m5.buys,
         sells: pair.txns.m5.sells,
         buyVolumeInUSD: pair.txns.m5.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.m5.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '1h',
         txCount: `${pair.txns.h1.buys + pair.txns.h1.sells}`,
         volume: pair.volume.h1,
         volumeInUSD: pair.volume.h1 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h1.buys,
         sells: pair.txns.h1.sells,
         buyVolumeInUSD: pair.txns.h1.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h1.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '6h',
         txCount: `${pair.txns.h6.buys + pair.txns.h6.sells}`,
         volume: pair.volume.h6,
         volumeInUSD: pair.volume.h6 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h6.buys,
         sells: pair.txns.h6.sells,
         buyVolumeInUSD: pair.txns.h6.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h6.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
      {
         time: '24h',
         txCount: `${pair.txns.h24.buys + pair.txns.h24.sells}`,
         volume: pair.volume.h24,
         volumeInUSD: pair.volume.h24 * parseFloat(pair.priceUsd),
         uniqueWallets: 0, // Placeholder
         buys: pair.txns.h24.buys,
         sells: pair.txns.h24.sells,
         buyVolumeInUSD: pair.txns.h24.buys * parseFloat(pair.priceUsd),
         sellVolumeInUSD: pair.txns.h24.sells * parseFloat(pair.priceUsd),
         buyers: 0, // Placeholder
         sellers: 0, // Placeholder
      },
   ]

   return transactions
}

export function getPairWithMostLiquidity(pairs: Pair[]): Pair | undefined {
   if (pairs.length === 0) return undefined

   // Find the first pair with defined liquidity to start the comparison.
   let maxLiquidityPair: Pair | undefined = pairs.find((pair) => pair.liquidity !== undefined)

   // If no pair has liquidity data, return undefined or the first pair.
   if (!maxLiquidityPair) {
      return pairs[0] // Or return pairs[0] if you prefer to return the first pair by default.
   }

   // Start the loop from the pair after the initial max liquidity pair found
   const startIndex = pairs.indexOf(maxLiquidityPair) + 1

   for (let i = startIndex; i < pairs.length; i++) {
      if (pairs[i].liquidity && pairs[i].liquidity.usd > maxLiquidityPair.liquidity.usd) {
         maxLiquidityPair = pairs[i]
      }
   }

   return maxLiquidityPair
}

export function calculateTotalLiquidityInUsd(pairs: Pair[]): number {
   return pairs.reduce((total, pair) => {
      const liquidity = pair.liquidity?.usd || 0
      return total + liquidity
   }, 0)
}

export function getAllUniqueDexIds(pairs: Pair[]): string[] {
   return [...new Set(pairs.map((pair) => pair.dexId))]
}
</file>

<file path="apps/backend/src/common/helpers/getSignature.ts">
import * as bs58 from 'bs58'
import { Transaction, VersionedTransaction } from '@solana/web3.js'

export function getSignature(transaction: Transaction | VersionedTransaction): string {
   const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0]
   if (!signature) {
      throw new Error('Missing transaction signature, the transaction was not signed by the fee payer')
   }
   return bs58.encode(signature)
}
</file>

<file path="apps/backend/src/common/helpers/sleep.ts">
export async function sleep(ms: number): Promise<void> {
   return new Promise((resolve) => setTimeout(resolve, ms))
}
</file>

<file path="apps/backend/src/common/helpers/transactionSender.ts">
import { BlockhashWithExpiryBlockHeight, Connection, TransactionExpiredBlockheightExceededError, VersionedTransactionResponse } from '@solana/web3.js'
import * as promiseRetry from 'promise-retry'
import { sleep } from './sleep'

type TransactionSenderAndConfirmationWaiterArgs = {
   connection: Connection
   serializedTransaction: Buffer
   blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight
}

export async function transactionSenderAndConfirmationWaiter({
   connection,
   serializedTransaction,
   blockhashWithExpiryBlockHeight,
}: TransactionSenderAndConfirmationWaiterArgs): Promise<VersionedTransactionResponse | null> {
   const txid = await connection.sendRawTransaction(serializedTransaction, {
      skipPreflight: true,
   })

   const controller = new AbortController()
   const abortSignal = controller.signal

   const abortableResender = async () => {
      while (true) {
         await sleep(2_000)
         if (abortSignal.aborted) return
         try {
            await connection.sendRawTransaction(serializedTransaction)
         } catch (e) {
            console.warn(`Failed to resend transaction: ${e}`)
         }
      }
   }

   try {
      abortableResender()
      const lastValidBlockHeight = blockhashWithExpiryBlockHeight.lastValidBlockHeight - 150

      // this would throw TransactionExpiredBlockheightExceededError
      await Promise.race([
         connection.confirmTransaction(
            {
               ...blockhashWithExpiryBlockHeight,
               lastValidBlockHeight,
               signature: txid,
               abortSignal,
            },
            'confirmed',
         ),
         new Promise(async (resolve) => {
            // in case ws socket died
            while (!abortSignal.aborted) {
               await sleep(2_000)
               const tx = await connection.getSignatureStatus(txid, {
                  searchTransactionHistory: false,
               })
               if (tx?.value?.confirmationStatus === 'confirmed') {
                  resolve(tx)
               }
            }
         }),
      ])
   } catch (e) {
      if (e instanceof TransactionExpiredBlockheightExceededError) {
         // we consume this error and getTransaction would return null
         return null
      } else {
         // invalid state from web3.js
         throw e
      }
   } finally {
      controller.abort()
   }

   // in case rpc is not synced yet, we add some retries
   const response = promiseRetry(
      async (retry) => {
         const response = await connection.getTransaction(txid, {
            commitment: 'confirmed',
            maxSupportedTransactionVersion: 0,
         })
         if (!response) {
            retry(response)
         }
         return response
      },
      {
         retries: 5,
         minTimeout: 1e3,
      },
   )

   return response
}
</file>

<file path="apps/backend/src/blockchain/solana/solana.controller.ts">
import { Controller, Get, Query } from '@nestjs/common'
import { SolanaService } from './solana.service'

@Controller('solana')
export class SolanaController {
   constructor(private readonly solanaService: SolanaService) {}

   @Get('price')
   async findPrices(@Query('tokenAddresses') tokenAddresses: string, @Query('vsToken') vsToken: string) {
      const tokenArray = tokenAddresses.split(',')
      return await this.solanaService.getPriceForMultipleTokens(tokenArray, vsToken)
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/solana.module.ts">
import { Module } from '@nestjs/common'
import { SolanaService } from './solana.service'
import { SolanaTokenModule } from './token/solanaToken.module'
import { SolanaController } from './solana.controller'

@Module({
   imports: [SolanaTokenModule],
   providers: [SolanaService],
   controllers: [SolanaController],
   exports: [SolanaService],
})
export class SolanaModule {}
</file>

<file path="apps/backend/src/blockchain/solana/solana.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { BlockchainInterface } from 'src/common/interfaces/blockchain.interface'
import {
   Connection,
   PublicKey,
   Keypair,
   TransactionInstruction,
   AddressLookupTableAccount,
   TransactionMessage,
   VersionedTransaction,
   SystemProgram,
   TokenBalance,
   LAMPORTS_PER_SOL,
} from '@solana/web3.js'
import { createUmi } from '@metaplex-foundation/umi-bundle-defaults'
import { Umi } from '@metaplex-foundation/umi'
import * as bs58 from 'bs58'
import axios from 'axios'
import { transactionSenderAndConfirmationWaiter } from 'src/common/helpers/transactionSender'
import { getSignature } from 'src/common/helpers/getSignature'
import * as fs from 'fs'
import { JupiterPriceReponse } from 'shared-types/src/JupiterPriceResponse.interface'
import BigNumber from 'bignumber.js'

export class SolanaService implements BlockchainInterface {
   public quickNodeConnection: Connection = new Connection(
      'https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/',
   )
   public defaultSolanaConnection: Connection = new Connection('https://api.mainnet-beta.solana.com/')
   public umi: Umi = createUmi('https://frosty-neat-film.solana-mainnet.quiknode.pro/bc93aa68cf48e78a3afd0267b839ff4482f0958f/')
   public juputerSwapURL: string = 'https://quote-api.jup.ag/v6'
   public jupiterPriceURL: string = 'https:///price.jup.ag/v6'

   public feeReceiverData = { feePercentage: process.env.FEE_PERCENTAGE, feeReceiver: new PublicKey(process.env.FEE_ACCOUNT_ADDRESS) }

   public knownAddresses = {
      WSOL: 'So11111111111111111111111111111111111111112',
   }

   connect() {
      // Implementation details
   }

   createNewWallet() {
      return Keypair.generate()
   }

   base58ToKeypair(base58PrivateKey: string): Keypair {
      try {
         const privateKeyBuffer = bs58.decode(base58PrivateKey)
         return Keypair.fromSecretKey(privateKeyBuffer)
      } catch (error) {
         throw new Error('Invalid base58 private key.')
      }
   }

   privateKeyToBase58(privateKey: Uint8Array): string {
      return bs58.encode(privateKey)
   }

   async getBalance(address: string): Promise<number> {
      const publicKey = new PublicKey(address)
      return this.quickNodeConnection.getBalance(publicKey)
   }

   async getBalanceForMultipleAddresses(addresses: string[]): Promise<{
      [key: string]: number
   }> {
      const publicKeys = addresses.map((address) => new PublicKey(address))
      const accountsInfo = await this.quickNodeConnection.getMultipleAccountsInfo(publicKeys)
      return accountsInfo.reduce((acc, accountInfo, index) => {
         const publicKey = publicKeys[index]
         if (accountInfo) {
            acc[publicKey.toBase58()] = accountInfo.lamports
         } else {
            acc[publicKey.toBase58()] = 0
         }

         return acc
      }, {})
   }

   async sendTransaction(transactionDetails: any): Promise<any> {
      // Implementation details
   }

   async makeJupiterSwapTransaction(
      inputMint: string,
      outputMint: string,
      inputAmount: BigNumber,
      slippageBps: number,
      wallet: Keypair,
      prioritizationFeeLamports: number | 'auto',
   ): Promise<{
      outputAmountUi: BigNumber
      outputAmount: BigNumber
   }> {
      const quoteResponse = await axios.get(`${this.juputerSwapURL}/quote`, {
         params: {
            inputMint,
            outputMint,
            amount: inputAmount.integerValue(BigNumber.ROUND_DOWN),
            slippageBps,
         },
      })

      console.log('Quote response: ', quoteResponse.data)

      const instructions = await axios.post(
         `${this.juputerSwapURL}/swap-instructions`,
         {
            userPublicKey: wallet.publicKey.toBase58(),
            quoteResponse: quoteResponse.data,
            dynamicComputeUnitLimit: true,
            prioritizationFeeLamports: prioritizationFeeLamports,
         },
         {
            headers: {
               'Content-Type': 'application/json',
            },
         },
      )

      const {
         tokenLedgerInstruction, // If you are using `useTokenLedger = true`.
         computeBudgetInstructions, // The necessary instructions to setup the compute budget.
         setupInstructions, // Setup missing ATA for the users.
         swapInstruction: swapInstructionPayload, // The actual swap instruction.
         cleanupInstruction, // Unwrap the SOL if `wrapAndUnwrapSol = true`.
         addressLookupTableAddresses, // The lookup table addresses that you can use if you are using versioned transaction.
      } = instructions.data

      const deserializeInstruction = (instruction) => {
         return new TransactionInstruction({
            programId: new PublicKey(instruction.programId),
            keys: instruction.accounts.map((key) => ({
               pubkey: new PublicKey(key.pubkey),
               isSigner: key.isSigner,
               isWritable: key.isWritable,
            })),
            data: Buffer.from(instruction.data, 'base64'),
         })
      }

      const getAddressLookupTableAccounts = async (keys: string[]): Promise<AddressLookupTableAccount[]> => {
         const addressLookupTableAccountInfos = await this.quickNodeConnection.getMultipleAccountsInfo(keys.map((key) => new PublicKey(key)))

         return addressLookupTableAccountInfos.reduce((acc, accountInfo, index) => {
            const addressLookupTableAddress = keys[index]
            if (accountInfo) {
               const addressLookupTableAccount = new AddressLookupTableAccount({
                  key: new PublicKey(addressLookupTableAddress),
                  state: AddressLookupTableAccount.deserialize(accountInfo.data),
               })
               acc.push(addressLookupTableAccount)
            }

            return acc
         }, new Array<AddressLookupTableAccount>())
      }

      const addressLookupTableAccounts: AddressLookupTableAccount[] = []
      addressLookupTableAccounts.push(...(await getAddressLookupTableAccounts(addressLookupTableAddresses)))

      const blockhash = await this.quickNodeConnection.getLatestBlockhash()

      const allInstructions = [
         ...computeBudgetInstructions.map(deserializeInstruction),
         ...setupInstructions.map(deserializeInstruction),
         deserializeInstruction(swapInstructionPayload),
         deserializeInstruction(cleanupInstruction),
      ]

      let feeAmountLamports: BigNumber

      if (inputMint === this.knownAddresses.WSOL) {
         // Calculate 0.8% of the input amount
         feeAmountLamports = inputAmount.multipliedBy(0.008)
      } else if (outputMint === this.knownAddresses.WSOL) {
         // Extract output amount from quoteResponse data (assuming it is available)
         const outputAmount = quoteResponse.data.outAmount // Adjust this based on actual data structure
         feeAmountLamports = new BigNumber(outputAmount).multipliedBy(0.008)
      }

      const feeTransferInstruction = SystemProgram.transfer({
         fromPubkey: wallet.publicKey,
         toPubkey: this.feeReceiverData.feeReceiver,
         lamports: feeAmountLamports.integerValue(BigNumber.ROUND_DOWN).toNumber(),
      })
      allInstructions.push(feeTransferInstruction)

      const messageV0 = new TransactionMessage({
         payerKey: wallet.publicKey,
         recentBlockhash: blockhash.blockhash,
         instructions: allInstructions,
      }).compileToV0Message(addressLookupTableAccounts)

      const transaction = new VersionedTransaction(messageV0)
      transaction.sign([wallet])

      const signature = getSignature(transaction)

      // console.time('simulateTransaction')
      // const { value: simulatedTransactionResponse } = await this.quickNodeConnection.simulateTransaction(transaction, {
      //    replaceRecentBlockhash: true,
      //    commitment: 'processed',
      // })
      // const { err, logs } = simulatedTransactionResponse

      // if (err) {
      //    // Simulation error, we can check the logs for more details
      //    // If you are getting an invalid account error, make sure that you have the input mint account to actually swap from.
      //    console.error('Simulation Error:')
      //    console.error({ err, logs })
      //    return
      // }
      // console.timeEnd('simulateTransaction')

      console.log('Current time: ', new Date().toLocaleTimeString())

      const transactionResponse = await transactionSenderAndConfirmationWaiter({
         connection: this.quickNodeConnection,
         serializedTransaction: Buffer.from(transaction.serialize()),
         blockhashWithExpiryBlockHeight: blockhash,
      })

      if (!transactionResponse) {
         throw new Error('Transaction not confirmed')
      }

      if (transactionResponse.meta?.err) {
         console.error(transactionResponse.meta?.err)
      }

      const findTokenBalance = (balances: Array<TokenBalance>, mint: string, owner: string): BigNumber => {
         const balance = balances.find((balance) => balance.mint === mint && balance.owner === owner)
         const balanceAmount = balance ? new BigNumber(balance.uiTokenAmount.uiAmount) : new BigNumber(0)
         return balanceAmount.isNaN() ? new BigNumber(0) : balanceAmount
      }

      const findTokenDecimals = (balances: Array<TokenBalance>, mint: string): number => {
         const balance = balances.find((balance) => balance.mint === mint)
         return balance ? balance.uiTokenAmount.decimals : 0
      }

      const postBalanceUi = findTokenBalance(transactionResponse.meta.postTokenBalances, outputMint, wallet.publicKey.toBase58())
      const preBalanceUi = findTokenBalance(transactionResponse.meta.preTokenBalances, outputMint, wallet.publicKey.toBase58())
      console.log('Post balance: ', postBalanceUi.toString())
      console.log('Pre balance: ', preBalanceUi.toString())
      const outputAmountUi = postBalanceUi.minus(preBalanceUi)

      const tokenDecimals = findTokenDecimals(transactionResponse.meta.postTokenBalances, outputMint)
      console.log(`https://solscan.io/tx/${signature}`)

      console.log(`Output amount: ${outputAmountUi.toString()}`)

      return {
         outputAmountUi,
         outputAmount: outputAmountUi.multipliedBy(10 ** tokenDecimals),
      }
   }

   async getPriceForMultipleTokens(tokensToCheck: string[], vsToken: string = this.knownAddresses.WSOL): Promise<JupiterPriceReponse> {
      const tokenPrices = await axios.get(`${this.jupiterPriceURL}/price`, {
         params: {
            ids: tokensToCheck.join(','),
            vsToken: vsToken,
         },
      })
      return tokenPrices.data
   }
}
</file>

<file path="apps/frontend/src/components/trade/AutoSellPresets.svelte">
<script lang="ts">
	import { AccordionItem, Accordion, Modal } from 'flowbite-svelte';
	import { userInfo } from '$stores/userStore';
	import type { AutoSellStrategy } from 'shared-types/src/zodSchemas/BuyTokenFormSchema';
	import { initializeAutoSell } from '$lib/autoSellPresets';

	export let selectPreset: (strategy: AutoSellStrategy) => void;
</script>

<Accordion>
	<AccordionItem paddingDefault="p-0" class="h-12 rounded-lg px-5">
		<span slot="header" class="text-white font-bold">Presets</span>
		{#each $userInfo.autoSellPresets as preset}
			<div class="flex p-2 justify-between w-full">
				<div class="flex w-full items-center justify-between">
					<h2 class="text-white font-bold text-lg">{preset.name}</h2>
				</div>
				<button
					class=" px-2 py-1 bg-[#35d0de] text-sm rounded-lg text-black font-bold"
					type="button"
					on:click={() => selectPreset(preset.strategy)}>Select</button
				>
			</div>
		{/each}
	</AccordionItem>
</Accordion>
</file>

<file path="apps/frontend/src/components/trade/BuyTradeForm.svelte">
<script lang="ts">
	import { Label, Input, InputAddon, ButtonGroup, Toggle, TabItem, Tabs, Select, Progressbar } from 'flowbite-svelte';
	import { Table, TableBody, TableBodyCell, TableBodyRow, TableHead, TableHeadCell } from 'flowbite-svelte';
	import { ArrowUpDown } from 'lucide-svelte';
	import { Button } from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { tokenPricesInUSD } from '$stores/priceStore';
	import { PUBLIC_WSOL_ADDRESS } from '$env/static/public';
	import TokenInformationModal from './TokenInformationModal.svelte';
	import { InfoCircleOutline } from 'flowbite-svelte-icons';
	import { formatNumber } from '$utils/formatters';
	import type { SuperForm, Infer } from 'sveltekit-superforms';
	import {
		type BuyTokenFormSchema,
		type GridStrategy,
		type TrailingProfitTarget,
		isSimpleAutoSell,
		isGridStrategy
	} from 'shared-types/src/zodSchemas/BuyTokenFormSchema';
	import {
		initializeAutoSell,
		defaultGridBreakEvenAutoSell,
		defaultGridStaticAutoSell,
		defaultGridTrailingAutoSell,
		defaultSimpleAutoSell
	} from '$lib/autoSellPresets';

	import NumberInput from '$components/common/NumberInput.svelte';
	import AutoSellPresets from './AutoSellPresets.svelte';

	export let form: Infer<BuyTokenFormSchema>;

	type ProjectedNetPL = {
		targetPrice: number;
		sellPercentage: number;
		projectedNetPL: number;
	};

	$: initialBuyPrice = form.inputAmount / outputSecondaryToken;

	$: oneSolPriceInUsd = $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS]; // Use the store value
	$: oneSolInSecondaryToken = $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS] / $tokenPricesInUSD[$tokenInfo.address]; // Calculated from store value
	$: oneSecondaryTokenInSol = $tokenPricesInUSD[$tokenInfo.address] / $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS]; // Calculated from store value

	$: outputSecondaryToken = form.inputAmount / oneSecondaryTokenInSol;

	const solInputPresets = [0.1, 0.5, 1, 10];

	function calculateWorstCaseScenario(initialInvestment: number, strategy: GridStrategy): number {
		switch (strategy.stopLossType) {
			case 'trailing':
			case 'static':
				const lossAmount = initialInvestment * (strategy.stopLossPercentage / 100);
				return -lossAmount;
			case 'breakeven':
				return -initialInvestment * (strategy.stopLossPercentage / 100);
		}
	}

	// Pure function for calculating projected net P/L
	function calculateProjectedNetPL(
		initialInvestment: number,
		initialTokens: number,
		strategy: GridStrategy
	): ProjectedNetPL[] {
		if (initialInvestment === 0 || initialTokens === 0) return [];

		const initialPrice = initialInvestment / initialTokens;
		let remainingTokens = initialTokens;
		let accumulativeProceedsFromSale = 0;
		let highestPrice = initialPrice;
		let currentStopLossPercentage = strategy.stopLossPercentage;

		return strategy.profitTargets.map((target, index) => {
			const { multiplier, sellPercentage } = target;
			const targetPrice = initialPrice * multiplier;
			highestPrice = Math.max(highestPrice, targetPrice);

			const tokensSold = initialTokens * (sellPercentage / 100);
			const proceedsFromSale = tokensSold * targetPrice;

			accumulativeProceedsFromSale += proceedsFromSale;
			remainingTokens -= tokensSold;

			// Update the stop loss percentage if specified
			if (strategy.stopLossType === 'trailing') {
				currentStopLossPercentage = (target as TrailingProfitTarget).trailingStopLossAfter;
			}

			let stopLossPrice: number;
			switch (strategy.stopLossType) {
				case 'trailing':
					stopLossPrice = highestPrice * (1 - currentStopLossPercentage / 100);
					break;
				case 'breakeven':
					stopLossPrice = initialPrice;
					break;
				case 'static':
				default:
					stopLossPrice = initialPrice * (1 - currentStopLossPercentage / 100);
			}

			const proceedsFromStopLoss = remainingTokens * stopLossPrice;
			const totalProceeds = accumulativeProceedsFromSale + proceedsFromStopLoss;
			const projectedNetPL = totalProceeds - initialInvestment;

			return {
				targetPrice,
				sellPercentage,
				projectedNetPL
			};
		});
	}

	// Reactive statement to update results
	$: results = isGridStrategy(form.autoSell.strategy)
		? calculateProjectedNetPL(form.inputAmount, outputSecondaryToken, form.autoSell.strategy)
		: [];

	$: worstCaseScenario = isGridStrategy(form.autoSell.strategy)
		? calculateWorstCaseScenario(form.inputAmount, form.autoSell.strategy)
		: 0;

	function formatValue(value: number, placeholder: string): string | undefined {
		return value === 0 ? undefined : value.toString();
	}

	function addProfitTarget() {
		if (isGridStrategy(form.autoSell.strategy)) {
			const baseTarget = { multiplier: 0, sellPercentage: 0 };

			if (form.autoSell.strategy.stopLossType === 'trailing') {
				form.autoSell.strategy.profitTargets = [
					...form.autoSell.strategy.profitTargets,
					{ ...baseTarget, trailingStopLossAfter: 0 }
				];
			} else {
				form.autoSell.strategy.profitTargets = [...form.autoSell.strategy.profitTargets, baseTarget];
			}
		}
	}

	function removeProfitTarget(index: number) {
		if (isGridStrategy(form.autoSell.strategy)) {
			form.autoSell.strategy.profitTargets = form.autoSell.strategy.profitTargets.filter((_, i) => i !== index);
		}
	}

	$: totalSellPercentage = isGridStrategy(form.autoSell.strategy)
		? form.autoSell.strategy.profitTargets.reduce(
				(acc, target) => acc + (target.sellPercentage == 0 ? 0 : parseFloat(target.sellPercentage.toString())),
				0
			)
		: 0;

	let selectGridType: string;
</script>

<div class="w-full">
	<div>
		<div class="flex justify-between items-center mb-2">
			<Label for="input-addon" class="font-bold">You're Paying</Label>
		</div>

		<ButtonGroup class="w-full">
			<InputAddon class="pr-2">
				<div class="w-6 h-6">
					<img src="/solana-logo.png" class="rounded-full object-cover" alt="Solana" />
				</div>
			</InputAddon>
			<InputAddon class="pl-0 quicksand !text-white !font-bold">SOL</InputAddon>
			<div class="bg-gray-700">
				<NumberInput
					id="input-addon"
					class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0 z-0"
					placeholder="0.00"
					min={0.0000001}
					step={0.0000001}
					bind:value={form.inputAmount}
				/>
				<div class="z-10 relative">
					<p class="text-gray-400 pr-2.5 -mt-2 mb-1 text-xs font-semibold text-right z-10">
						≈ <span class="">${(form.inputAmount * oneSolPriceInUsd).toFixed(2)}</span>
					</p>
				</div>
			</div>

			<Button class="!bg-[#35d0de] !text-black font-bold">MAX</Button>
		</ButtonGroup>
		<div class="flex justify-between mt-3">
			{#each solInputPresets as preset}
				<button
					class="!bg-gray-700 w-full mr-2 last-of-type:mr-0 py-1 rounded-lg text-base !text-white !font-bold"
					on:click={() => (form.inputAmount = preset)}>{preset} SOL</button
				>
			{/each}
		</div>
	</div>
	<ArrowUpDown class="w-6 h-6 mx-auto mt-4 -mb-2 text-white" />
	<div>
		<Label for="input-addon" class="mb-2 font-bold">To Receive</Label>
		<ButtonGroup class="w-full">
			<TokenInformationModal class="flex !rounded-r-none">
				<InputAddon class="pr-2">
					<div class="w-6 h-6">
						<img src={$tokenInfo.image} class="rounded-full object-cover" alt={$tokenInfo.name} />
					</div>
				</InputAddon>
				<InputAddon class="pl-0 quicksand !rounded-r-none !text-white !font-bold"
					>{$tokenInfo.symbol} <InfoCircleOutline class="ml-1 w-4 h-4 text-gray-400" />
				</InputAddon>
			</TokenInformationModal>
			<Input
				id="input-addon"
				type="number"
				class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
				placeholder=""
				min="0.00000001"
				step="0.00000001"
				value={formatValue(outputSecondaryToken, '')}
				readonly
			/>
		</ButtonGroup>
		<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
			1 SOL ≈ {formatNumber(parseFloat(oneSolInSecondaryToken.toFixed(2)))}
			{$tokenInfo.symbol}
		</p>
	</div>
	<hr class="my-4 border-gray-600" />
	<div class="flex justify-between mt-4 bg-gray-700 p-2 rounded-lg">
		<p class="text-white font-bold">Enable Auto Sell</p>
		<Toggle
			classDiv="peer-focus:ring-0 {form.autoSell.enabled ? '!bg-[#35d0de]' : '!bg-gray-500'}"
			bind:checked={form.autoSell.enabled}
			on:change={() => {
				if (form.autoSell.enabled) {
					form.autoSell.strategy = initializeAutoSell(defaultSimpleAutoSell);
				}
			}}
		/>
	</div>
	{#if form.autoSell.enabled}
		<Tabs contentClass="mt-4" defaultClass="flex" tabStyle="underline">
			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				open
				title="Simple Auto Sell"
				on:click={() => {
					form.autoSell.strategy = initializeAutoSell(defaultSimpleAutoSell);
				}}
			>
				{#if isSimpleAutoSell(form.autoSell.strategy)}
					<div class="flex">
						<div class="mr-2">
							<Label for="first_name" class="mb-2">Profit Percentage</Label>
							<NumberInput
								id="slppage"
								size="sm"
								class="text-right pe-6"
								required
								bind:value={form.autoSell.strategy.profitPercentage}
							>
								<p slot="right">%</p>
							</NumberInput>
							<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
								Profit: <span class="text-white"
									>{parseFloat(((form.inputAmount * form.autoSell.strategy.profitPercentage) / 100).toFixed(4))} SOL</span
								>
							</p>
						</div>
						<div class="ml-2">
							<Label for="last_name" class="mb-2">Loss Percentage</Label>

							<NumberInput
								id="slppage"
								size="sm"
								class="text-right pe-6"
								required
								bind:value={form.autoSell.strategy.stopLossPercentage}
							>
								<p slot="right">%</p>
							</NumberInput>
							<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
								Loss: <span class="text-white"
									>{parseFloat(((form.inputAmount * form.autoSell.strategy.stopLossPercentage) / 100).toFixed(4))} SOL</span
								>
							</p>
						</div>
					</div>
				{/if}
			</TabItem>

			<TabItem
				class="w-full"
				activeClasses="py-4 border-b-2 border-primary-600"
				inactiveClasses="py-4 text-gray-400"
				defaultClass="w-full"
				title="Grid Auto Sell"
				on:click={() => {
					form.autoSell.strategy = initializeAutoSell(defaultGridStaticAutoSell);
					selectGridType = 'static';
				}}
			>
				<AutoSellPresets
					selectPreset={(strategy) => {
						form.autoSell.strategy = initializeAutoSell(strategy);
						if (isGridStrategy(strategy)) selectGridType = strategy.stopLossType;
					}}
				/>
				{#if isGridStrategy(form.autoSell.strategy)}
					<div class="mb-4">
						<Label for="stop_loss_type" class="mb-2">Stop Loss Type</Label>
						<Select
							id="stop_loss_type"
							class="mt-2"
							bind:value={selectGridType}
							on:change={() => {
								if (selectGridType === 'trailing') {
									form.autoSell.strategy = initializeAutoSell(defaultGridTrailingAutoSell);
								} else if (selectGridType === 'breakeven') {
									form.autoSell.strategy = initializeAutoSell(defaultGridBreakEvenAutoSell);
								} else {
									form.autoSell.strategy = initializeAutoSell(defaultGridStaticAutoSell);
								}
							}}
						>
							<option value="static">Static Stop Loss</option>
							<option value="trailing">Trailing Stop Loss</option>
							<option value="breakeven">Breakeven Stop Loss</option>
						</Select>
					</div>

					<div>
						<Label for="trailing_stop_loss" class="mb-2 capitalize"
							>{form.autoSell.strategy.stopLossType} Stop Loss Percentage</Label
						>
						<div class="bg-gray-700 rounded-lg border-gray-600 border">
							<NumberInput
								id="trailing_stop_loss"
								size="sm"
								class="text-right border-0 focus:!ring-0 pe-6"
								required
								bind:value={form.autoSell.strategy.stopLossPercentage}
							>
								<p slot="right">%</p>
							</NumberInput>
							<p class="text-gray-400 text-right text-xs pr-2.5 mb-1">
								Projected Minimum P/L: <span class="font-bold text-[#ff6b6b] ml-2">{worstCaseScenario} SOL</span>
							</p>
						</div>
					</div>

					<p class="mb-2 mt-4 text-center font-bold text-white">Profit Targets</p>

					<Table class="table-fixed" divClass="-mx-4">
						<TableHead>
							<TableHeadCell class="px-2 !w-[22.5%] text-center">Increase</TableHeadCell>
							<TableHeadCell class="px-2 !w-[22.5%] text-center">Sell %</TableHeadCell>
							{#if form.autoSell.strategy.stopLossType === 'trailing'}
								<TableHeadCell class="px-2 !w-[22.5%] text-center">Trailing Stop Loss %</TableHeadCell>
							{/if}
							<TableHeadCell class="px-2 !w-[22.5%] text-center">Projected Minimum P/L</TableHeadCell>
							<TableHeadCell class="px-2 !w-[10%] text-center"></TableHeadCell>
						</TableHead>
						<TableBody tableBodyClass="divide-y">
							{#each form.autoSell.strategy.profitTargets as target, index}
								<TableBodyRow>
									<TableBodyCell class="px-2">
										<NumberInput
											size="sm"
											class="text-right pe-5 ps-0"
											min={0}
											step={0.01}
											required
											bind:value={target.multiplier}
										>
											<p slot="right">x</p>
										</NumberInput>
									</TableBodyCell>
									<TableBodyCell class="px-2">
										<NumberInput size="sm" class="text-right pe-6 ps-0" required bind:value={target.sellPercentage}>
											<p slot="right">%</p>
										</NumberInput>
									</TableBodyCell>
									{#if form.autoSell.strategy.stopLossType === 'trailing' && 'trailingStopLossAfter' in target}
										<TableBodyCell class="px-2">
											<NumberInput
												size="sm"
												class="text-right pe-6 ps-0"
												required
												bind:value={target.trailingStopLossAfter}
											>
												<p slot="right">%</p>
											</NumberInput>
										</TableBodyCell>
									{/if}
									<TableBodyCell class="px-1">
										<p class="text-white font-bold text-center">
											{results[index]?.projectedNetPL.toFixed(4) == undefined
												? '0'
												: parseFloat(results[index]?.projectedNetPL.toFixed(3))}
											<span class="text-[0.6rem] font-normal">SOL</span>
										</p>
									</TableBodyCell>
									{#if index !== 0}
										<TableBodyCell class="px-2 pl-0">
											<Button class="px-1 py-1 !bg-[#A0A5B1]" size="sm" on:click={() => removeProfitTarget(index)}>
												<svg class="w-4 h-4" fill="#fff" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
													<path
														fill-rule="evenodd"
														d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
														clip-rule="evenodd"
													></path>
												</svg>
											</Button>
										</TableBodyCell>
									{/if}
								</TableBodyRow>
							{/each}
							<TableBodyRow class="!w-full">
								<TableBodyCell class="px-2" colspan={form.autoSell.strategy.stopLossType === 'trailing' ? 5 : 4}>
									<div class="w-full flex justify-center">
										<Button
											class="!bg-[#3A3D4A] text-base !px-3.5 !py-1 focus:outline-none focus:ring-0"
											on:click={addProfitTarget}>+ Add Profit Target</Button
										>
									</div>
								</TableBodyCell>
							</TableBodyRow>
						</TableBody>
					</Table>
					<div class="w-[80%] mx-auto">
						<Progressbar
							progress={totalSellPercentage}
							size="h-3"
							class="my-4 max-w-full"
							divClass="totalSellPercentageProgress bg-gray-600 rounded-full {totalSellPercentage > 100
								? 'totalSellPercentageProgressRed'
								: 'totalSellPercentageProgressGreen'}"
							labelOutside="Total Sell %"
							classLabelOutside={totalSellPercentage > 100 ? 'totalSellPercentageLabelRedText' : ''}
						/>
					</div>
				{/if}
			</TabItem>
		</Tabs>
	{/if}
	<button class="w-full rounded-lg py-2 !bg-[#35d0de] text-black text-lg mt-6 font-bold">Place Order</button>
</div>

<!-- <iframe
	id="dextools-widget"
	title="DEXTools Trading Chart"
	width="500"
	height="400"
	src="https://www.dextools.io/widget-chart/en/solana/pe-light/25tXTutLkjtcUX3kqoeRvc7AuBYM7fckBWoVqnQnyDGQ?theme=light&chartType=2&chartResolution=30&drawingToolbars=true"
></iframe> -->

<style>
	:global(.totalSellPercentageProgress > div) {
		max-width: 100%;
	}

	:global(.totalSellPercentageProgressRed > div) {
		background-color: #ff6b6b !important;
	}

	:global(.totalSellPercentageProgressGreen > div) {
		background-color: #4caf50 !important;
	}

	:global(.totalSellPercentageLabelRedText > span:nth-child(2)) {
		color: #ff6b6b !important;
		font-weight: 700;
	}
</style>
</file>

<file path="apps/frontend/src/components/trade/SellTradeForm.svelte">
<script lang="ts">
	import { Label, Input, InputAddon, ButtonGroup } from 'flowbite-svelte';
	import { ArrowUpDown } from 'lucide-svelte';
	import { Button } from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { tokenPricesInUSD } from '$stores/priceStore';
	import { PUBLIC_WSOL_ADDRESS } from '$env/static/public';
	import TokenInformationModal from './TokenInformationModal.svelte';
	import { InfoCircleOutline } from 'flowbite-svelte-icons';
	import { formatNumber } from '$utils/formatters';

	export let formData;
	export let updateFormData: (key: string, value: unknown) => void;

	$: inputTokenAmount = formData.inputAmount;
	$: oneSolPriceInUsd = $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS];
	$: oneSecondaryTokenInSol = $tokenPricesInUSD[$tokenInfo.address] / $tokenPricesInUSD[PUBLIC_WSOL_ADDRESS];
	$: outputSolana = inputTokenAmount * oneSecondaryTokenInSol;

	function onInputTokenChange(e: Event) {
		const target = e.target as HTMLInputElement;
		const value = parseFloat(target.value) || 0;
		updateFormData('inputAmount', value);
	}
</script>

<div class="w-full">
	<div>
		<Label for="input-addon" class="font-bold">You're Selling</Label>
		<ButtonGroup class="w-full">
			<TokenInformationModal class="flex !rounded-r-none">
				<InputAddon class="pr-2">
					<div class="w-6 h-6">
						<img src={$tokenInfo.image} class="rounded-full object-cover" alt={$tokenInfo.name} />
					</div>
				</InputAddon>
				<InputAddon class="pl-0 quicksand !rounded-r-none !text-white !font-bold"
					>{$tokenInfo.symbol} <InfoCircleOutline class="ml-1 w-4 h-4 text-gray-400" />
				</InputAddon>
			</TokenInformationModal>
			<div class="bg-gray-700">
				<Input
					id="input-addon"
					type="number"
					class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
					placeholder="0.00"
					value={inputTokenAmount}
					on:input={onInputTokenChange}
				/>
				<p class="text-gray-400 pr-2.5 -mt-2 mb-1 text-xs font-semibold text-right">
					≈ <span class="">${(inputTokenAmount * $tokenPricesInUSD[$tokenInfo.address]).toFixed(2)}</span>
				</p>
			</div>
			<Button class="!bg-[#35d0de] !text-black font-bold">MAX</Button>
		</ButtonGroup>
	</div>

	<ArrowUpDown class="w-6 h-6 mx-auto mt-4 -mb-2 text-white" />

	<div>
		<Label for="output-addon" class="mb-2 font-bold">To Receive</Label>
		<ButtonGroup class="w-full">
			<InputAddon class="pr-2">
				<div class="w-6 h-6">
					<img src="/solana-logo.png" class="rounded-full object-cover" alt="Solana" />
				</div>
			</InputAddon>
			<InputAddon class="pl-0 quicksand !text-white !font-bold">SOL</InputAddon>
			<Input
				id="output-addon"
				type="number"
				class="focus:!ring-0 !text-white !font-bold text-right text-lg !border-0"
				placeholder=""
				value={outputSolana}
				readonly
			/>
		</ButtonGroup>
		<p class="text-gray-400 text-sm mt-1 font-semibold text-right">
			1 {$tokenInfo.symbol} ≈ {formatNumber(parseFloat(oneSecondaryTokenInSol.toFixed(8)))} SOL
		</p>
	</div>
</div>
</file>

<file path="apps/frontend/src/components/trade/TokenInformationModal.svelte">
<script lang="ts">
	import {
		Button,
		Modal,
		Progressbar,
		Tabs,
		TabItem,
		Table,
		TableBody,
		TableBodyCell,
		TableBodyRow,
		TableHead,
		TableHeadCell,
		Card
	} from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { formatNumber, formatUSD, formatPercentage } from '$utils/formatters';
	import { ArrowUpRightFromSquareOutline, CheckOutline, CloseOutline } from 'flowbite-svelte-icons';
	import { X, Telegram, Discord } from 'svelte-simples';
	import { Globe, Crown } from 'lucide-svelte';
	import CopyToClipboard from '$components/common/CopyToClipboard.svelte';
	import { tokenPricesInUSD } from '$stores/priceStore';

	export let open = false;

	function accountAddressToKnownName(address: string) {
		const knownAccounts: Record<string, string> = {
			'5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1': 'Raydium'
		};
		return knownAccounts[address] || `${address.slice(0, 4)}...${address.slice(-4)}`;
	}

	$: transactions = $tokenInfo.transactions.sort((a, b) => {
		const order = ['5m', '1h', '6h', '24h'];
		return order.indexOf(a.time) - order.indexOf(b.time);
	});

	$: createdOnPumpFun = $tokenInfo.socialMediaLinks.find((link) => link.platform === 'PumpFun');
</script>

<button type="button" class={$$props.class} on:click={() => (open = true)}>
	<slot />
</button>

<Modal headerClass="p-0" classBody="p-0" outsideclose bind:open size="xl" class="w-full">
	<div class="p-4 !mt-0 bg-gray-900 text-white">
		<div class="flex items-center justify-between mb-4">
			<div class="flex items-center space-x-2">
				<img src={$tokenInfo.image} alt={$tokenInfo.name} class="w-8 h-8 rounded-full" />
				<h2 class="text-base font-bold">{$tokenInfo.name} ({$tokenInfo.symbol})</h2>
			</div>
		</div>
		<Tabs contentClass="p-4 bg-gray-50 rounded-lg rounded-t-none dark:bg-gray-800 !mt-0" style="pills">
			<TabItem open title="Info">
				<div class="space-y-2">
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Address:</span>
						<span class="text-right">
							<a
								href={`https://solscan.io/token/${$tokenInfo.address}`}
								target="_blank"
								rel="noopener noreferrer"
								class="text-blue-500 hover:underline ml-2 inline-flex items-center"
							>
								{$tokenInfo.address.slice(0, 8)}...{$tokenInfo.address.slice(-4)}
							</a>
						</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Supply:</span>
						<span>{formatNumber($tokenInfo.totalSupply / 10 ** $tokenInfo.decimals)}</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Supply Value:</span>
						<span
							>{formatUSD(
								($tokenInfo.totalSupply / 10 ** $tokenInfo.decimals) * $tokenPricesInUSD[$tokenInfo.address]
							)}</span
						>
					</div>
					<!-- <div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Unique Holders:</span>
						<span>{formatNumber($tokenInfo.uniqueHolders)}</span>
					</div> -->
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Total Liquidity:</span>
						<span>{formatUSD($tokenInfo.totalLiquidtyInUSD)}</span>
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Mint Authority:</span>
						{#if $tokenInfo.mintAuthority}
							<span class="text-red-500 flex items-center">
								<CloseOutline class="w-4 h-4 mr-1" /> Yes
							</span>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Freeze Authority:</span>
						{#if $tokenInfo.freezeAuthority}
							<span class="text-red-500 flex items-center">
								<CloseOutline class="w-4 h-4 mr-1" /> Yes
							</span>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Update Authority:</span>
						{#if $tokenInfo.metadataChangeAuthority}
							<a
								href={`https://solscan.io/address/${$tokenInfo.metadataChangeAuthority}`}
								target="_blank"
								rel="noopener noreferrer"
								class="text-blue-500 hover:underline ml-2 inline-flex items-center"
							>
								<span>
									{$tokenInfo.metadataChangeAuthority.slice(0, 4)}...{$tokenInfo.metadataChangeAuthority.slice(-4)}
								</span>
							</a>
						{:else}
							<span class="text-green-500 flex items-center">
								<CheckOutline class="w-4 h-4 mr-1" /> None
							</span>
						{/if}
					</div>
					<div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Created on Pump.Fun:</span>
						<span> {createdOnPumpFun ? 'Yes' : 'No'} </span>
					</div>
					<!-- <div class="flex justify-between items-center !mt-0 py-3 border-b border-gray-700">
						<span class="text-sm text-gray-400">Trading Platforms:</span>
						<span>{$tokenInfo.dexesBeingTradedOn.join(', ')}</span>
					</div> -->
					{#if $tokenInfo.socialMediaLinks.length > 0}
						<div class="flex justify-between items-center !mt-0 py-3 border-gray-700">
							<span class="text-sm text-gray-400">URLs:</span>
							<div class="flex space-x-2">
								{#each $tokenInfo.socialMediaLinks as link}
									<a
										href={link.url}
										target="_blank"
										rel="noopener noreferrer"
										class="text-blue-400 hover:text-blue-300"
									>
										{#if link.platform === 'Twitter'}
											<X size="20" />
										{:else if link.platform === 'Telegram'}
											<Telegram size="20" />
										{:else if link.platform === 'Discord'}
											<Discord size="20" />
										{:else if link.platform != 'PumpFun'}
											<Globe size="20" />
										{/if}
									</a>
								{/each}
							</div>
						</div>
					{/if}
				</div>
			</TabItem>
			<TabItem title="Holders">
				<div class="space-y-4">
					<div>
						<h4 class="font-semibold mb-2">Top Holders Distribution</h4>
						<div class="space-y-2">
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 5 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top5)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top5} size="h-2" color="blue" />
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 10 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top10)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top10} size="h-2" color="green" />
							<div class="flex text-sm text-gray-400 justify-between">
								<span>Top 20 Holders</span>
								<span>{formatPercentage($tokenInfo.topHoldersTokenSupplyDistribution.top20)}</span>
							</div>
							<Progressbar progress={$tokenInfo.topHoldersTokenSupplyDistribution.top20} size="h-2" color="yellow" />
						</div>
					</div>
					<div>
						<h2 class="font-semibold mb-2">Top 20 Holders</h2>
						<Table>
							<TableHead>
								<TableHeadCell class="text-center px-2">No</TableHeadCell>
								<TableHeadCell>Address</TableHeadCell>
								<TableHeadCell class="text-right pr-2">%</TableHeadCell>
							</TableHead>
							<TableBody tableBodyClass="divide-y">
								{#each $tokenInfo.topHolders as holder, index}
									<TableBodyRow>
										{#if index === 0}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#ffc619]" /></TableBodyCell>
										{:else if index === 1}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#e5e0d1]" /></TableBodyCell>
										{:else if index === 2}
											<TableBodyCell class="text-center px-2"><Crown class="w-4 h-4 text-[#f6c2a8]" /></TableBodyCell>
										{:else}
											<TableBodyCell class="text-center px-2">{index + 1}</TableBodyCell>
										{/if}
										<TableBodyCell class="flex items-center">
											<CopyToClipboard text={holder.address} />
											<a
												href={`https://solscan.io/address/${holder.address}`}
												target="_blank"
												rel="noopener noreferrer"
												class="text-blue-500 hover:underline ml-1"
											>
												{accountAddressToKnownName(holder.address)}
											</a>
										</TableBodyCell>
										<TableBodyCell class="text-right pr-2"
											>{formatPercentage(holder.percentageOfTotalSupply)}</TableBodyCell
										>
									</TableBodyRow>
								{/each}
							</TableBody>
						</Table>
					</div>
				</div>
			</TabItem>
			<!-- <TabItem title="Transactions">
				<div class="space-y-4">
					<h4 class="font-semibold mb-2">Transaction Data</h4>

					<div class="md:hidden space-y-4">
						{#each transactions as tx}
							<Card>
								<h5 class="mb-2 text-lg font-bold">{tx.time} Data</h5>
								<div class="grid grid-cols-2 gap-2 text-sm">
									<div>Transactions: {tx.txCount}</div>
									<div>Volume: {formatNumber(tx.volume)} {$tokenInfo.symbol}</div>
									<div>Volume (USD): {formatUSD(tx.volumeInUSD)}</div>
									<div>Unique Wallets: {tx.uniqueWallets}</div>
									<div>Buys: {tx.buys}</div>
									<div>Sells: {tx.sells}</div>
									<div class="bg-gray-800 p-3 rounded">
										<div class="text-gray-400 text-xs">VOLUME</div>
										<div class="text-white text-2xl font-bold">{formatUSD(tx.volumeInUSD)}</div>
										<div class="flex justify-between text-sm">
											<span class="text-green-400">{formatUSD(tx.buyVolumeInUSD)}</span>
											<span class="text-red-400">{formatUSD(tx.sellVolumeInUSD)}</span>
										</div>
										<div class="w-full bg-gray-700 rounded-full h-1.5 mt-1">
											<div
												class="bg-green-400 h-1.5 rounded-full"
												style="width: {(tx.buyVolumeInUSD / tx.volumeInUSD) * 100}%"
											></div>
										</div>
									</div>
								</div>
							</Card>
						{/each}
					</div>

					<div class="hidden md:block">
						<Table>
							<TableHead>
								<TableHeadCell>Time</TableHeadCell>
								<TableHeadCell>Transactions</TableHeadCell>
								<TableHeadCell>Volume</TableHeadCell>
								<TableHeadCell>Volume (USD)</TableHeadCell>
								<TableHeadCell>Buys/Sells</TableHeadCell>
								<TableHeadCell>Buy/Sell Volume</TableHeadCell>
							</TableHead>
							<TableBody>
								{#each transactions as tx}
									<TableBodyRow>
										<TableBodyCell>{tx.time}</TableBodyCell>
										<TableBodyCell>{tx.txCount}</TableBodyCell>
										<TableBodyCell>{formatNumber(tx.volume)} {$tokenInfo.symbol}</TableBodyCell>
										<TableBodyCell>{formatUSD(tx.volumeInUSD)}</TableBodyCell>
										<TableBodyCell>{tx.buys}/{tx.sells}</TableBodyCell>
										<TableBodyCell>{formatUSD(tx.buyVolumeInUSD)}/{formatUSD(tx.sellVolumeInUSD)}</TableBodyCell>
									</TableBodyRow>
								{/each}
							</TableBody>
						</Table>
					</div>
				</div>
			</TabItem> -->
		</Tabs>
	</div>
</Modal>
</file>

<file path="apps/frontend/src/components/trade/TradeForm.svelte">
<script lang="ts">
	import WalletSelector from './WalletSelector.svelte';

	import { buyTokenFormSchema, type BuyTokenDto } from 'shared-types/src/zodSchemas/BuyTokenFormSchema';
	import BuyTradeForm from '$components/trade/BuyTradeForm.svelte';
	import { Tabs, TabItem } from 'flowbite-svelte';
	import { Input, Label, Button } from 'flowbite-svelte';
	import { SearchOutline, FileCopyOutline } from 'flowbite-svelte-icons';
	import { AccordionItem, Accordion, Modal, Spinner } from 'flowbite-svelte';
	import { tokenInfo } from '$stores/tokenStore';
	import { tokenService } from '$services/tokenService';
	import { superForm, defaults } from 'sveltekit-superforms';
	import { valibot } from 'sveltekit-superforms/adapters';
	import { tradingService } from '$services/tradingService';

	const buyTokenForm = defaults(valibot(buyTokenFormSchema));

	const { form, errors, enhance } = superForm(buyTokenForm, {
		SPA: true,
		dataType: 'json',
		validators: valibot(buyTokenFormSchema),
		onUpdate({ form }) {
			console.log(form.data);
			console.log(form.valid);
			console.log(form.errors);
			if (form.valid) {
				tradingService.buyTokens({
					tokenAddress: form.data.tokenAddress,
					walletAddress: form.data.walletAddress,
					slippage: form.data.slippage,
					prioritizationFeeLamports: 103928,
					autoSell: form.data.autoSell,
					inputAmount: form.data.inputAmount
				});
			}
		}
	});

	let slippageModal = false;

	function searchTokenInputChanged(e: Event) {
		tokenService.reset();

		const target = e.target as HTMLInputElement;
		const tokenAddress = target.value;
		console.log(tokenAddress.length);
		if (tokenAddress.length >= 40) {
			tokenService.fetchTokenInfo(tokenAddress);
		}
	}
</script>

<form method="POST" use:enhance class="bg-gray-800 quicksand rounded-lg p-4 md:w-96 md:mx-auto">
	<div class="flex justify-between items-center mb-4 form-padding">
		<h2 class="text-2xl pl-5 text-white font-bold text-center">Trade</h2>
		<button
			type="button"
			class="bg-gray-600 text-white text-sm px-2 rounded-lg font-semibold"
			on:click={() => (slippageModal = true)}>Slippage: {$form.slippage}%</button
		>
	</div>

	<WalletSelector bind:walletAddress={$form.walletAddress}></WalletSelector>
	<Input
		id="search"
		on:input={searchTokenInputChanged}
		bind:value={$form.tokenAddress}
		class="!bg-gray-700 my-6 "
		placeholder="Paste token address"
		size="lg"
	>
		<SearchOutline slot="left" class="w-6 h-6 text-gray-500  dark:text-gray-400" />
	</Input>
	{#if $tokenInfo.name !== ''}
		<Tabs
			tabStyle="full"
			contentClass="rounded-lg mt-4 bg-gray-800"
			defaultClass="flex bg-gray-700 rounded-lg quicksand"
		>
			<TabItem
				activeClasses="bg-[#008F00]"
				inactiveClasses="bg-gray-700"
				defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
				class="w-full"
				open
			>
				<span slot="title">Buy</span>
				<BuyTradeForm bind:form={$form} />
			</TabItem>
			<TabItem
				activeClasses="bg-[#B30000]"
				inactiveClasses="bg-gray-700"
				defaultClass="text-xl w-full h-full text-white font-bold rounded-lg h-10"
				class="w-full"
			>
				<span slot="title">Sell</span>
				<p class="text-sm text-gray-500 dark:text-gray-400">
					<b>Dashboard:</b>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna
					aliqua.
				</p>
			</TabItem>
		</Tabs>
	{:else if tokenService.loading}
		<div class="text-center"><Spinner /></div>
	{/if}
</form>

<Modal title="Swap Slippage Tolerance" bind:open={slippageModal} autoclose>
	<div class="flex items-center justify-between">
		<div class="w-3/4">
			<p>Custom slippage</p>
		</div>
		<div class="w-1/4">
			<Input type="number" id="slppage" size="sm" class="text-right pe-6" required bind:value={$form.slippage}>
				<p slot="right">%</p>
			</Input>
		</div>
	</div>
	<Button class="w-full !bg-[#35d0de] text-black font-bold">Save</Button>
</Modal>
</file>

<file path="apps/frontend/src/components/trade/VolatileMarketProjections.svelte">
<script lang="ts">
	import { Table, TableBody, TableBodyCell, TableBodyRow, TableHead, TableHeadCell } from 'flowbite-svelte';
	import type { VolatileMarketStrategy, Projection } from '$lib/VolatileMarketStrategy';
	import { calculateProjections } from '$lib/VolatileMarketStrategy';

	export let strategy: VolatileMarketStrategy;
	export let initialInvestment: number;

	$: projections = calculateProjections(strategy, initialInvestment);
</script>

<div class="mt-6">
	<h3 class="text-xl font-bold mb-4">Potential Outcomes</h3>
	<Table hoverable={true}>
		<TableHead>
			<TableHeadCell>Scenario</TableHeadCell>
			<TableHeadCell>Profit/Loss (SOL)</TableHeadCell>
			<TableHeadCell>Profit/Loss (%)</TableHeadCell>
		</TableHead>
		<TableBody>
			{#each projections as projection}
				<TableBodyRow>
					<TableBodyCell>{projection.scenario}</TableBodyCell>
					<TableBodyCell class={projection.profitLoss >= 0 ? 'text-green-500' : 'text-red-500'}>
						{projection.profitLoss.toFixed(2)} SOL
					</TableBodyCell>
					<TableBodyCell class={projection.profitLossPercentage >= 0 ? 'text-green-500' : 'text-red-500'}>
						{projection.profitLossPercentage.toFixed(2)}%
					</TableBodyCell>
				</TableBodyRow>
			{/each}
		</TableBody>
	</Table>
</div>
</file>

<file path="apps/frontend/src/components/trade/WalletSelector.svelte">
<script lang="ts">
	import { FileCopyOutline } from 'flowbite-svelte-icons';
	import { AccordionItem, Accordion, Modal } from 'flowbite-svelte';
	import { TableBody, TableBodyCell, TableBodyRow, TableHead, TableHeadCell, TableSearch } from 'flowbite-svelte';
	import { copyToClipboard } from '$utils/copyToClipboard';
	import { userInfo } from '$stores/userStore';
	import { Radio } from 'flowbite-svelte';

	export let walletAddress: string;

	$: wallets = $userInfo.wallets.map((wallet) => ({
		...wallet,
		checked: false,
		modalOpen: false,
		searchTerm: '',
		tokenHoldings: []
	}));

	$: filteredTokenHoldings = (
		/** @type {{ tokenHoldings: any[]; searchTerm: string; }} */ wallet: { tokenHoldings: any[]; searchTerm: string }
	) => {
		return wallet.tokenHoldings.filter((token: { name: string }) =>
			token.name.toLowerCase().includes(wallet.searchTerm.toLowerCase())
		);
	};
</script>

<Accordion>
	<AccordionItem paddingDefault="p-0" class="h-12 rounded-lg px-5">
		<span slot="header" class="text-white font-bold">Wallets</span>
		{#each wallets as wallet}
			<div class="flex p-2 justify-between w-full">
				<Radio
					name="wallets"
					value={wallet.address}
					bind:group={walletAddress}
					class="p-1 text-[#35d0de] focus:ring-0"
				/>
				<div class="flex w-full items-center justify-between">
					<div class="flex items-center">
						<p class="text-white font-bold">
							{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}..` : wallet.name}
						</p>

						<p class="ml-1 flex items-center">
							(<button on:click={() => copyToClipboard(wallet.address)} class="">
								<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
							</button>{wallet.address.length > 4 ? `${wallet.address.substring(0, 4)}..` : wallet.address})
						</p>

						<p class="text-white font-bold text-sm ml-2">{parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
					</div>
				</div>
				<button
					class=" px-2 py-1 bg-[#35d0de] text-sm rounded-lg text-black font-bold"
					type="button"
					on:click={() => (wallet.modalOpen = true)}>View</button
				>
			</div>
			<Modal title="Token Holdings" bind:open={wallet.modalOpen} autoclose outsideclose={true}>
				<div class="flex items-center justify-center">
					<p>Wallet:</p>
					<p class="text-white ml-2 font-bold">
						{wallet.name.length > 5 ? `${wallet.name.substring(0, 5)}...` : wallet.name}
					</p>
					<p class="ml-1 flex items-center text-gray-400">
						(<button on:click={() => copyToClipboard(wallet.address)} class="">
							<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
						</button>{wallet.address.length > 5 ? `${wallet.address.substring(0, 5)}...` : wallet.address})
					</p>
					<p class="text-white font-bold ml-2">- {parseFloat(wallet.solBalance.toFixed(4))} SOL</p>
				</div>
				<TableSearch
					inputClass="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 ps-10 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
					placeholder="Search by token name"
					hoverable={true}
					bind:inputValue={wallet.searchTerm}
				>
					<TableHead>
						<TableHeadCell>Token</TableHeadCell>
						<TableHeadCell>Balance</TableHeadCell>
					</TableHead>
					<TableBody tableBodyClass="divide-y">
						{#each filteredTokenHoldings(wallet) as token}
							<TableBodyRow>
								<TableBodyCell class="pr-0">
									<div class="text-white flex items-center">
										<p class="font-bold">{token.name}</p>
										<span class="flex ml-1 text-gray-400 items-center">
											(<button on:click={() => copyToClipboard(wallet.address)} class="">
												<FileCopyOutline class="w-4 h-4 text-gray-500 hover:!text-white" />
											</button>{token.address.length > 5 ? `${token.address.substring(0, 5)}...` : token.address})
										</span>
									</div>
								</TableBodyCell>
								<TableBodyCell>{token.balance}</TableBodyCell>
							</TableBodyRow>
						{/each}
					</TableBody>
				</TableSearch>
			</Modal>
		{/each}
	</AccordionItem>
</Accordion>
</file>

<file path="apps/frontend/src/routes/dashboard/+layout.server.ts">
import { redirect } from '@sveltejs/kit';
import type { UserDto } from 'shared-types/src/userInfo.interface';
import { PUBLIC_BACKEND_URL } from '$env/static/public';

import type { LayoutServerLoad } from './$types';
export const load: LayoutServerLoad = async ({ fetch, cookies }) => {
	let response;
	try {
		response = await fetch(PUBLIC_BACKEND_URL + '/user/info', {
			credentials: 'include',
			headers: {
				Cookie: 'connect.sid=' + cookies.get('connect.sid')
			}
		});
	} catch (error) {
		if (error instanceof Response) {
			// This is a redirect, so we just throw it
			throw error;
		}
		console.error('Error loading user info:', error);
		return {
			status: 500,
			error: new Error('Failed to load user info')
		};
	}

	if (!response.ok) {
		redirect(302, `/login`);
	}

	const userInfo: UserDto = await response.json();
	return { userInfo };
};
</file>

<file path="apps/frontend/src/routes/dashboard/+layout.svelte">
<script lang="ts">
	import BottomNavigation from '$components/common/BottomNavigation.svelte';
	import Navbar from '$components/common/Navbar.svelte';
	import '../../app.css';
	import { onMount } from 'svelte';
	import { userInfo } from '$stores/userStore';
	import type { PageData } from './$types';

	export let data: PageData;

	onMount(() => {
		if (data.userInfo) {
			data.userInfo.autoSellPresets = [
				{
					name: 'My first preset',
					strategy: {
						strategyName: 'grid',
						stopLossType: 'trailing',
						stopLossPercentage: 5,
						profitTargets: [
							{ multiplier: 1.25, sellPercentage: 20, trailingStopLossAfter: 10 },
							{ multiplier: 1.5, sellPercentage: 40, trailingStopLossAfter: 15 },
							{ multiplier: 2, sellPercentage: 30, trailingStopLossAfter: 20 },
							{ multiplier: 3, sellPercentage: 10, trailingStopLossAfter: 20 }
						]
					}
				}
			];
			userInfo.set(data.userInfo);
		}
	});

	$: console.log(data);
</script>

<main class=" pb-40 px-2">
	<Navbar />
	<slot />
</main>
<BottomNavigation />
</file>

<file path="apps/frontend/src/routes/dashboard/+page.svelte">
<script lang="ts">
	import { PUBLIC_BACKEND_URL } from '$env/static/public';
	import axios from 'axios';
	import type { BuyTokenDto } from 'shared-types/src/dto/BuyToken.dto';
	import type { SellTokenDto } from 'shared-types/src/dto/SellToken.dto';

	async function buyTokens() {
		const buyTokenDto: BuyTokenDto = {
			solAmountIn: '20000000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump',
			autoSell: {
				userId: 6,
				walletId: 1,
				solAmountProfitTrigger: '23000000',
				solAmountLossTrigger: '17000000',
				slippage: '15',
				tokenAddressToSell: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
			}
		};
		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/buy-token', buyTokenDto, {
			withCredentials: true
		});
	}

	async function sellTokens() {
		const sellTokenDto: SellTokenDto = {
			tokenAmountIn: '3574930000',
			walletAddress: '9ZSsGKz3eigKk2yZAzLJRV5jxQfNChkNwWpfattWjU3E',
			slippageInPercentage: 15,
			tokenAddress: '93CRzwgrZsHmXjS7T9GadUzZkyCoXerF9AgAcMZ3pump'
		};

		const { data } = await axios.post(PUBLIC_BACKEND_URL + '/user/sell-token', sellTokenDto, {
			withCredentials: true
		});
	}
</script>

<h1>WELCOME TO THE DASHBOARD</h1>

<button on:click={buyTokens}>Buy Tokens!!!</button>

<button on:click={sellTokens}>Sell Tokens!!!</button>
</file>

<file path="apps/frontend/src/components/common/BottomNavigation.svelte">
<script>
	import { Wallet, CopyPlus, Crosshair, ArrowLeftRight } from 'lucide-svelte';
	import { page } from '$app/stores';
</script>

<nav class="md:hidden text-gray-400 fixed quicksand w-screen bottom-0 bg-gray-800 flex">
	<div
		class="w-full h-full flex flex-col py-4 items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/trade'}
	>
		<ArrowLeftRight size={20} />
		<a href="/dashboard/trade">Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/sniper'}
	>
		<Crosshair size={20} />
		<a href="/dashboard/sniper">Sniper</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/copy-trade'}
	>
		<CopyPlus size={20} />
		<a href="/dashboard/copy-trade">Copy Trade</a>
	</div>
	<div
		class="w-full h-full flex py-4 flex-col items-center justify-center"
		class:navLi={$page.url.pathname === '/dashboard/wallets'}
	>
		<Wallet size={20} />
		<a href="/dashboard/wallets">Wallets</a>
	</div>
</nav>
</file>

<file path="apps/frontend/src/components/common/CopyToClipboard.svelte">
<script lang="ts">
	import { Tooltip, Button } from 'flowbite-svelte';
	import { copyToClipboard } from '$utils/copyToClipboard';
	import { FileCopyOutline } from 'flowbite-svelte-icons';

	export let text: string;
	let tooltipText = 'Copy to clipboard';

	async function handleCopy() {
		await copyToClipboard(text);
		tooltipText = 'Copied!';
		setTimeout(() => {
			tooltipText = 'Copy to clipboard';
		}, 2000); // Reset after 2 seconds
	}
</script>

<button on:click={handleCopy}>
	<FileCopyOutline class="text-gray-500 w-4 h-4" />
</button>
<Tooltip>
	<p>{tooltipText}</p>
</Tooltip>
</file>

<file path="apps/frontend/src/components/common/Navbar.svelte">
<script>
	import {
		Navbar,
		NavBrand,
		NavLi,
		NavUl,
		NavHamburger,
		Avatar,
		Dropdown,
		DropdownItem,
		DropdownHeader,
		DropdownDivider
	} from 'flowbite-svelte';
	import { page } from '$app/stores';
	$: activeUrl = $page.url.pathname;
</script>

<Navbar color="none" class="quicksand px-8 py-4 md:p-4">
	<NavBrand href="/">
		<span class="self-center logo whitespace-nowrap text-xl font-semibold audiowide dark:text-white">Sniperoo</span>
	</NavBrand>
	<div class="flex items-center md:order-2">
		<Avatar
			class="md:!w-12 md:!h-12 !bg-[#36394C] p-1 border border-[#e0e0e0] hover:cursor-pointer hover:brightness-75"
			id="avatar-menu"
			src="/dashboard/userIcon.png"
		/>
		<!-- <NavHamburger class1="w-full md:flex md:w-auto md:order-1" /> -->
	</div>
	<Dropdown placement="bottom" triggeredBy="#avatar-menu">
		<DropdownHeader>
			<span class="block text-sm">@britishculottes</span>
		</DropdownHeader>
		<DropdownItem>Referral Dashboard</DropdownItem>
		<DropdownItem>Transactions</DropdownItem>
		<DropdownItem>Settings</DropdownItem>
		<DropdownDivider />
		<DropdownItem>Sign out</DropdownItem>
	</Dropdown>
	<NavUl {activeUrl} activeClass="active">
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/trade">Trade</NavLi>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/sniper"
			>Sniper</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/copy-trade"
			>Copy Trade</NavLi
		>
		<NavLi class="font-bold text-lg text-gray-400 !px-4 !py-2 hover:!bg-slate-700" href="/dashboard/wallets"
			>Wallets</NavLi
		>
		<!-- <NavLi class="font-bold navLi text-lg !px-4 !py-2 hover:!bg-slate-700" href="/contact">Contact</NavLi> -->
	</NavUl>
</Navbar>

<style>
	.logo {
		font-family: 'Audiowide', cursive;
		text-align: center;
		color: #00ffff;
		letter-spacing: 4px;
		text-shadow:
			0 0 5px #00ffff,
			0 0 10px #00ffff;
		animation: subtle-pulse 4s ease-in-out infinite;
		text-transform: uppercase;
	}

	:global(.navLi) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	:global(.active) {
		text-shadow: 0 0 3px #e0e0e0;
		color: #e0e0e0 !important;
	}

	@keyframes subtle-pulse {
		0%,
		100% {
			text-shadow:
				0 0 5px #00ffff,
				0 0 10px #00ffff;
		}
		50% {
			text-shadow:
				0 0 10px #00ffff,
				0 0 20px #00ffff;
		}
	}
</style>
</file>

<file path="apps/frontend/src/components/common/NumberInput.svelte">
<script lang="ts">
	import { Input, type FormSizeType } from 'flowbite-svelte';
	export let id: string = '';
	export let value: number;
	export let placeholder: string = '';
	export let min: number = 0;
	export let step: number = 1;
	export let size: FormSizeType = 'md';
	export let required: boolean = false;

	function onChange(e: Event) {
		const target = e.target as HTMLInputElement;
		value = parseFloat(target.value);
	}
</script>

<Input
	type="number"
	{placeholder}
	{min}
	{step}
	{id}
	{size}
	{required}
	class={$$props.class}
	value={value?.toString() ?? ''}
	on:input={onChange}
>
	<svelte:fragment slot="left">
		<slot name="left" />
	</svelte:fragment>

	<svelte:fragment slot="default"></svelte:fragment>

	<svelte:fragment slot="right">
		<slot name="right" />
	</svelte:fragment>
</Input>
</file>

<file path="apps/frontend/src/routes/login/+page.svelte">
<script>
	import TelegramLoginWidget from '$components/TelegramLoginWidget.svelte';
</script>

<div class="w-screen h-screen flex">
	<div class="hidden w-full h-full bg-[#005952] md:block"></div>
	<div class="h-screen w-full bg-black relative">
		<div class="h-screen w-full overflow-hidden absolute">
			<img src="login/dark_pattern.jpg" alt="dark_pattern" class="w-full h-screen object-cover" />
		</div>
		<div class="absolute w-full text-center top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
			<h1 class="text-4xl text-white font-bold manrope">Sniperoo</h1>
			<h2 class="text-2xl text-green-600 mt-4 font-bold manrope">Welcome to Sniperoo</h2>
			<p class="text-base mt-4 text-white manrope">The Automated Trading Platform</p>
			<div class="mt-12"><TelegramLoginWidget /></div>
			<div class="mt-6 flex items-center justify-center">
				<img src="login/login_with_google.png" alt="login_with_google" class="w-50" />
			</div>
			<p class="text-white text-xs mt-8 manrope">
				By proceeding, you agree to these <br />
				<a href="/terms_and_conditions" class="underline font-bold">Terms and Conditions.</a>
			</p>
		</div>
	</div>
</div>
</file>

<file path="apps/backend/src/blockchain/solana/sniper/pricePooling.service.ts">
import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common'
import { EventEmitter2 } from '@nestjs/event-emitter'
import { SolanaService } from '../solana.service'

@Injectable()
export class PricePollingService implements OnModuleInit, OnModuleDestroy {
   private intervalId: NodeJS.Timeout
   private readonly INTERVAL = 500 // 500ms

   constructor(
      private eventEmitter: EventEmitter2,
      private readonly solanaService: SolanaService,
   ) {}

   onModuleInit() {
      this.startInterval()
   }

   onModuleDestroy() {
      this.stopInterval()
   }

   private startInterval() {
      this.intervalId = setInterval(() => this.pollPrices(), this.INTERVAL)
   }

   private stopInterval() {
      if (this.intervalId) {
         clearInterval(this.intervalId)
      }
   }

   private async pollPrices() {
      try {
         const tokenAddresses = await this.eventEmitter.emitAsync('get.token.addresses')
         if (tokenAddresses[0] == null) return
         const tokenPrices = await this.solanaService.getPriceForMultipleTokens(tokenAddresses)
         this.eventEmitter.emit('prices.updated', tokenPrices.data)
      } catch (error) {
         console.error('Error in pollPrices:', error)
      }
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/sniper/solanaSniper.module.ts">
import { forwardRef, Module } from '@nestjs/common'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'
import { SolanaModule } from '../solana.module'
import { UserModule } from 'src/user/user.module'
import { EncryptionModule } from 'src/encryption/encryption.module'
import { PricePollingService } from './pricePooling.service'
import { TransactionExecutionService } from './autoSell/transactionExecution.service'
import { EntryCalculationService } from './autoSell/entryCalculation.service'
import { EventEmitterModule } from '@nestjs/event-emitter'

@Module({
   imports: [EventEmitterModule.forRoot(), SolanaModule, forwardRef(() => UserModule), EncryptionModule],
   providers: [...drizzleProvider, EntryCalculationService, PricePollingService, TransactionExecutionService],
   exports: [EntryCalculationService],
})
export class SolanaSniperModule {}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.controller.ts">
import { Controller, Get, Param } from '@nestjs/common'
import { SolanaTokenService } from './solanaToken.service'

@Controller('solanaToken')
export class SolanaTokenController {
   constructor(private readonly solanaTokenService: SolanaTokenService) {}

   @Get(':tokenAddress')
   findOne(@Param('tokenAddress') tokenAddress: string) {
      return this.solanaTokenService.getTokenInfo(tokenAddress)
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.module.ts">
// src/blockchain/solana/token/token.module.ts
import { Module } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaTokenController } from './solanaToken.controller'
import { drizzleProvider } from 'src/drizzle/drizzle.provider'

@Module({
   providers: [SolanaTokenService, SolanaService, ...drizzleProvider],
   controllers: [SolanaTokenController],
   exports: [SolanaTokenService],
})
export class SolanaTokenModule {}
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing'
import { SolanaTokenService } from './solanaToken.service'
import { SolanaService } from '../solana.service'

describe('SolanaTokenService', () => {
   let service: SolanaTokenService

   beforeEach(async () => {
      const module: TestingModule = await Test.createTestingModule({
         providers: [SolanaTokenService, SolanaService],
      }).compile()

      service = module.get<SolanaTokenService>(SolanaTokenService)
   })

   it('should be defined', () => {
      expect(service).toBeDefined()
   })
})
</file>

<file path="apps/backend/src/blockchain/solana/token/solanaToken.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
// src/blockchain/solana/token/token.service.ts
import { Inject, Injectable } from '@nestjs/common'
import { SolanaService } from '../solana.service'
import { getMint, getAccount, AccountLayout } from '@solana/spl-token'
import { PublicKey as SolanaPublicKey } from '@solana/web3.js'
import { PublicKey as UmiPublicKey } from '@metaplex-foundation/umi-public-keys'
import { fetchMetadata, findMetadataPda } from '@metaplex-foundation/mpl-token-metadata'
import { TokenHolderInfo, TokenInfo, TokenTransactions, URLInfo } from 'shared-types/src/tokenInfo.interface'
import axios from 'axios'
import { DexScreenerResponse } from 'src/common/interfaces/dexscreenerData.interface'
import {
   getPairWithMostLiquidity,
   convertPairToTokenTransactions,
   calculateTotalLiquidityInUsd,
   getAllUniqueDexIds,
} from 'src/common/helpers/convertDexscreenerData'
import { sleep } from 'src/common/helpers/sleep'
import { SelectDexTransactionLogs } from 'src/drizzle/schema'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import * as schema from 'src/drizzle/schema'
import { gte, and, eq } from 'drizzle-orm'
import * as fs from 'fs'

@Injectable()
export class SolanaTokenService {
   constructor(
      private solanaService: SolanaService,
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
   ) {}

   async getTokenInfo(tokenAddress: string): Promise<TokenInfo> {
      this.fetchTransactionsFromDatabase(tokenAddress)
      const mint = await getMint(this.solanaService.quickNodeConnection, new SolanaPublicKey(tokenAddress))

      const tokenMetadata = await fetchMetadata(
         this.solanaService.umi,
         findMetadataPda(this.solanaService.umi, {
            mint: tokenAddress as UmiPublicKey,
         }),
      )

      // console.log(tokenMetadata)

      const dexScreenerData: DexScreenerResponse = await this.fetchFromDexScreener(tokenAddress)
      const pairWithMostLiquidity = getPairWithMostLiquidity(dexScreenerData.pairs)
      const topHolders = await this.fetchTopHolders(
         tokenAddress,
         Number(mint.supply) / 10 ** mint.decimals,
         parseFloat(pairWithMostLiquidity.priceUsd),
      )

      const oneTokenPriceInUSD = await this.fetchTokenPrice(tokenAddress)
      const socialMediaAndImage = await this.fetchSocialMediaLinksAndImage(tokenMetadata.uri)

      // Initialize and populate the TokenInfo object
      const tokenInfo: TokenInfo = {
         name: tokenMetadata.name, // Replace with actual fetched data
         symbol: tokenMetadata.symbol, // Replace with actual fetched data
         address: tokenAddress,
         decimals: mint.decimals,
         totalSupply: Number(mint.supply),
         totalSupplyPriceInUSD: (Number(mint.supply) / 10 ** mint.decimals) * oneTokenPriceInUSD,
         oneTokenPriceInUSD: oneTokenPriceInUSD,
         transactions: convertPairToTokenTransactions(pairWithMostLiquidity),
         mintAuthority: mint.mintAuthority ? mint.mintAuthority.toBase58() : null,
         freezeAuthority: mint.freezeAuthority ? mint.freezeAuthority.toBase58() : null,
         metadataChangeAuthority: tokenMetadata.updateAuthority,
         uniqueHolders: 0,
         totalLiquidtyInUSD: calculateTotalLiquidityInUsd(dexScreenerData.pairs),
         topHolders: topHolders,
         topHoldersTokenSupplyDistribution: this.getTopRanksExcludingOwners(topHolders),
         verifiedDexScreener: await this.checkVerifiedDexScreener(tokenAddress),
         dexesBeingTradedOn: getAllUniqueDexIds(dexScreenerData.pairs),
         verifiedBirdEye: await this.checkVerifiedBirdEye(tokenAddress),
         socialMediaLinks: socialMediaAndImage.urlInfo,
         image: socialMediaAndImage.image,
      }

      return tokenInfo
   }

   private getTopRanksExcludingOwners(elements: TokenHolderInfo[]) {
      // 5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1 = Raydium
      const excludedOwners = ['5Q544fKrFoe6tsEbD7S8EmxGTJYAKtTVhAW5Q5pge4j1']

      const filteredElements = elements.filter((element) => !excludedOwners.includes(element.address))

      return {
         top5: filteredElements.slice(0, 5).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top10: filteredElements.slice(0, 10).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top15: filteredElements.slice(0, 15).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
         top20: filteredElements.slice(0, 20).reduce((acc, curr) => acc + curr.percentageOfTotalSupply, 0),
      }
   }

   private async fetchFromDexScreener(tokenAddress: string): Promise<DexScreenerResponse> {
      try {
         const response = await axios.get(`https://api.dexscreener.com/latest/dex/tokens/${tokenAddress}`)
         return response.data as DexScreenerResponse
      } catch (error) {
         console.error('Error fetching data from DexScreener:', error)
         throw error
      }
   }

   // private async fetchTokenPairInfo(tokenAddress: string): Promise<TokenPairsInLP[]> {}

   private async fetchTransactionsFromDatabase(tokenAddress: string) {
      const yesterday = new Date(new Date().getTime() - 24 * 60 * 60 * 1000)

      const transactions: SelectDexTransactionLogs[] = await this.db
         .select()
         .from(schema.dexTransactionsTable)
         .where(and(gte(schema.dexTransactionsTable.timestamp, yesterday), eq(schema.dexTransactionsTable.secondaryTokenAddress, tokenAddress)))

      fs.writeFileSync('transactions.json', JSON.stringify(transactions, null, 2))

      // function splitAndAggregateTransactions(transactions, timeFrame) {
      //    const timeFrames = {
      //       '5m': 5,
      //       '1h': 60,
      //       '6h': 360,
      //       '12h': 720,
      //       '24h': 1440,
      //    }
      //    const minutesPerFrame = timeFrames[timeFrame]

      //    // Organize transactions into buckets based on time intervals
      //    const buckets = {}

      //    transactions.forEach((tx) => {
      //       // Calculate the bucket key as the start of the interval
      //       const intervalStart = moment(tx.timestamp)
      //          .startOf('minute')
      //          .subtract(moment(tx.timestamp).minute() % minutesPerFrame, 'minutes')
      //       const key = intervalStart.format()

      //       if (!buckets[key]) {
      //          buckets[key] = []
      //       }
      //       buckets[key].push(tx)
      //    })

      //    // Process each bucket to generate aggregated results
      //    const results = []

      //    Object.keys(buckets).forEach((key) => {
      //       const aggregatedData = aggregateTransactions(buckets[key], timeFrame)
      //       results.push(aggregatedData)
      //    })

      //    return results
      // }

      // function aggregateTransactions(transactions, timeFrame) {
      //    const aggregated = {
      //       time: timeFrame,
      //       txCount: transactions.length.toString(),
      //       volume: 0,
      //       volumeInUSD: 0,
      //       uniqueWallets: new Set(),
      //       buys: 0,
      //       sells: 0,
      //       buyVolumeInUSD: 0,
      //       sellVolumeInUSD: 0,
      //       buyers: new Set(),
      //       sellers: new Set(),
      //    }

      //    transactions.forEach((tx) => {
      //       aggregated.volume += tx.primaryTokenAmount + tx.secondaryTokenAmount
      //       aggregated.volumeInUSD += tx.transactionValueInUsd
      //       aggregated.uniqueWallets.add(tx.signer)

      //       if (tx.transactionType === 'buy') {
      //          aggregated.buys++
      //          aggregated.buyVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.buyers.add(tx.signer)
      //       } else if (tx.transactionType === 'sell') {
      //          aggregated.sells++
      //          aggregated.sellVolumeInUSD += tx.transactionValueInUsd
      //          aggregated.sellers.add(tx.signer)
      //       }
      //    })

      //    aggregated.uniqueWallets = aggregated.uniqueWallets.size
      //    aggregated.buyers = aggregated.buyers.size
      //    aggregated.sellers = aggregated.sellers.size

      //    return aggregated
      // }

      // return results
   }

   private async fetchTopHolders(tokenAddress: string, totalSupply: number, oneTokenPriceInUSD: number): Promise<TokenHolderInfo[]> {
      const tokenLargestAccounts = await this.solanaService.quickNodeConnection.getTokenLargestAccounts(new SolanaPublicKey(tokenAddress))
      const tokenAccountInfo = await this.solanaService.defaultSolanaConnection.getMultipleAccountsInfo(
         tokenLargestAccounts.value.map((account) => account.address),
      )
      const tokenHolders: TokenHolderInfo[] = []
      for (let i = 0; i < tokenLargestAccounts.value.length; i++) {
         const account = tokenLargestAccounts.value[i]
         const tokenAccountData = AccountLayout.decode(tokenAccountInfo[i].data)
         tokenHolders.push({
            address: tokenAccountData.owner.toBase58(),
            balance: account.uiAmount,
            worthInUSD: account.uiAmount * oneTokenPriceInUSD,
            percentageOfTotalSupply: (account.uiAmount / totalSupply) * 100,
         })
      }
      return tokenHolders
   }

   private async checkTokensLockedInLP(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if tokens are locked in LP
      return false
   }

   private async fetchTokenCreator(tokenAddress: string): Promise<string> {
      // Implement the logic to fetch token creator
      return ''
   }

   private async checkVerifiedDexScreener(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on Dex Screener
      return false
   }

   private async checkVerifiedBirdEye(tokenAddress: string): Promise<boolean> {
      // Implement the logic to check if verified on BirdEye
      return false
   }

   private async fetchSocialMediaLinksAndImage(url: string): Promise<{ image: string; urlInfo: URLInfo[] }> {
      try {
         const response = await axios.get(url)
         const data = response.data
         console.log(data)

         const links: URLInfo[] = []
         const socialMediaPatterns = {
            Facebook: [/facebook\.com/, /fb\.com/],
            Twitter: [/x\.com/],
            Instagram: [/instagram\.com/, /instagr\.am/],
            LinkedIn: [/linkedin\.com/],
            YouTube: [/youtube\.com/, /youtu\.be/],
            TikTok: [/tiktok\.com/],
            Reddit: [/reddit\.com/],
            Telegram: [/t\.me/],
            PumpFun: [/pump\.fun/],
         }

         function checkValue(value: any): void {
            if (typeof value === 'string' && isValidURL(value)) {
               const urlInfo: URLInfo = { url: value }
               for (const [name, patterns] of Object.entries(socialMediaPatterns)) {
                  if (patterns.some((pattern) => pattern.test(value))) {
                     urlInfo.platform = name
                     break
                  } else {
                     urlInfo.platform = 'Website'
                  }
               }
               links.push(urlInfo)
            } else if (typeof value === 'object' && value !== null) {
               for (const key in value) {
                  checkValue(value[key])
               }
            }
         }

         function isValidURL(url: string): boolean {
            try {
               new URL(url)
               return true
            } catch (_) {
               return false
            }
         }

         checkValue(data)
         return { image: data.image, urlInfo: links.filter((link) => link.url != data.image) }
      } catch (error) {
         console.error('Error fetching data:', error)
         return { image: '', urlInfo: [] }
      }
   }

   private async fetchTokenPrice(tokenAddress: string): Promise<number> {
      const response = await axios.get(`https://api-v3.raydium.io/mint/price?mints=${tokenAddress}`)
      return response.data.data[tokenAddress]
   }
}
</file>

<file path="apps/frontend/src/routes/dashboard/trade/+page.svelte">
<script>
	import TradeForm from '$components/trade/TradeForm.svelte';
</script>

<TradeForm />
</file>

<file path="apps/backend/src/blockchain/solana/sniper/autoSell/entryCalculation.service.ts">
/* eslint-disable @typescript-eslint/no-unused-vars */
import { Injectable, OnModuleInit } from '@nestjs/common'
import { EventEmitter2 } from '@nestjs/event-emitter'
import { OnEvent } from '@nestjs/event-emitter'
import { Inject } from '@nestjs/common'
import { DrizzleAsyncProvider } from 'src/drizzle/drizzle.provider'
import { PostgresJsDatabase } from 'drizzle-orm/postgres-js'
import * as schema from 'src/drizzle/schema'
import { InsertAutoSell, SelectAutoSell } from 'shared-types/src/drizzle.types'
import BigNumber from 'bignumber.js'
import {
   BuyTokenDto,
   GridStrategy,
   GridTrailingAutoSellPreset,
   SimpleAutoSellPreset,
   TrailingProfitTarget,
} from 'shared-types/src/zodSchemas/BuyTokenFormSchema'
import { eq } from 'drizzle-orm'

function isGridTrailingStopLoss(autoSell: GridStrategy): autoSell is GridTrailingAutoSellPreset {
   return autoSell.stopLossType === 'trailing'
}

@Injectable()
export class EntryCalculationService implements OnModuleInit {
   private cachedEntries: SelectAutoSell[] = []
   private cachedEntriesTokenAddresses: Set<string> = new Set()
   private executingEntries: Map<number, Set<string>> = new Map()

   constructor(
      @Inject(DrizzleAsyncProvider)
      private db: PostgresJsDatabase<typeof schema>,
      private eventEmitter: EventEmitter2,
   ) {}

   async onModuleInit() {
      this.cachedEntries = await this.getAutoSellEntriesFromDb()
      this.cachedEntriesTokenAddresses = new Set(this.cachedEntries.map((entry) => entry.tokenAddressToSell))
   }

   private async getAutoSellEntriesFromDb(): Promise<SelectAutoSell[]> {
      return await this.db.select().from(schema.autoSellTable).execute()
   }

   async addAutoSellEntry(entry: InsertAutoSell) {
      const newEntry = await this.db.insert(schema.autoSellTable).values(entry).returning()
      this.cachedEntries.push(newEntry[0])
      this.cachedEntriesTokenAddresses.add(newEntry[0].tokenAddressToSell)
   }

   async removeAutoSellEntry(entry: SelectAutoSell) {
      const index = this.cachedEntries.findIndex((e) => e.id === entry.id)
      if (index !== -1) {
         this.cachedEntries.splice(index, 1)
         this.cachedEntriesTokenAddresses.delete(entry.tokenAddressToSell)
      }
      await this.db.delete(schema.autoSellTable).where(eq(schema.autoSellTable.id, entry.id)).execute()
   }

   async updateAutoSellEntry(entry: SelectAutoSell) {
      const index = this.cachedEntries.findIndex((e) => e.id === entry.id)
      this.cachedEntries[index] = entry
      await this.db
         .update(schema.autoSellTable)
         .set({
            strategyParams: entry.strategyParams,
            tokenAmountSold: entry.tokenAmountSold,
            highestPriceExpressedInSol: entry.highestPriceExpressedInSol,
         })
         .where(eq(schema.autoSellTable.id, entry.id))
         .returning()
   }

   private isEntryExecuting(entryId: number, subType?: string): boolean {
      const executingSet = this.executingEntries.get(entryId)
      return executingSet ? (subType ? executingSet.has(subType) : executingSet.size > 0) : false
   }

   private addExecutingEntry(entryId: number, subType: string) {
      if (!this.executingEntries.has(entryId)) {
         this.executingEntries.set(entryId, new Set())
      }
      this.executingEntries.get(entryId)!.add(subType)
   }

   private removeExecutingEntry(entryId: number, trigger: string) {
      const executingSet = this.executingEntries.get(entryId)
      if (executingSet) {
         if (trigger.startsWith('profit target')) {
            const targetIndex = trigger.split(' ')[2]
            executingSet.delete(`target_${targetIndex}`)
         } else {
            executingSet.delete(trigger)
         }
         if (executingSet.size === 0) {
            this.executingEntries.delete(entryId)
         }
      }
   }

   @OnEvent('get.token.addresses')
   handleGetTokenAddresses() {
      return this.cachedEntriesTokenAddresses.size > 0 ? Array.from(this.cachedEntriesTokenAddresses) : null
   }

   @OnEvent('prices.updated')
   handlePriceUpdate(prices: Record<string, { price: string }>) {
      for (const entry of this.cachedEntries) {
         const currentPrice = new BigNumber(prices[entry.tokenAddressToSell].price)
         switch (entry.strategy) {
            case 'simple':
               this.checkSimpleAutoSell(entry, currentPrice)
               break
            case 'grid':
               this.checkGridAutoSell(entry, currentPrice)
               break
         }
      }
      console.log()
   }

   @OnEvent('transaction.executed')
   async handleExecutedTransaction({ entry, trigger, amount }: { entry: SelectAutoSell; trigger: string; amount: BigNumber }) {
      if (entry.strategy === 'simple') {
         await this.removeAutoSellEntry(entry)
      } else if (entry.strategy === 'grid') {
         const strategyParams = entry.strategyParams as GridStrategy
         const newTokenAmountSold = new BigNumber(entry.tokenAmountSold).plus(amount).toString()
         const profitTargets = strategyParams.profitTargets
         const targetIndex = profitTargets.findIndex((t) => !t.done)
         if (targetIndex !== -1) {
            profitTargets[targetIndex].done = true
         }
         let newStrategyParams: GridStrategy
         if (isGridTrailingStopLoss(strategyParams) && 'trailingStopLossAfter' in profitTargets[targetIndex]) {
            newStrategyParams = {
               ...strategyParams,
               profitTargets: profitTargets as TrailingProfitTarget[],
               stopLossPercentage: profitTargets[targetIndex]?.trailingStopLossAfter ?? strategyParams.stopLossPercentage,
            }
         } else if (!isGridTrailingStopLoss(strategyParams)) {
            newStrategyParams = { ...strategyParams, profitTargets }
         }
         await this.updateAutoSellEntry({ ...entry, strategyParams: newStrategyParams, tokenAmountSold: newTokenAmountSold })

         if (profitTargets.every((target) => target.done) || trigger === 'stop_loss') {
            await this.removeAutoSellEntry(entry)
         }
      }
      this.removeExecutingEntry(entry.id, trigger)
   }

   @OnEvent('transaction.failed')
   async handleFailedTransaction({ entry, trigger, amount, error }: { entry: SelectAutoSell; trigger: string; amount: BigNumber; error: any }) {
      this.removeExecutingEntry(entry.id, trigger)
      console.log(`Failed to execute auto-sell for user ${entry.userId}:`, error)
   }

   private checkSimpleAutoSell(entry: SelectAutoSell, currentPrice: BigNumber) {
      if (this.isEntryExecuting(entry.id)) return
      const { profitPercentage, stopLossPercentage } = entry.strategyParams as SimpleAutoSellPreset
      const profitTrigger = new BigNumber(entry.initialPriceExpressedInSol).times(1 + profitPercentage / 100)
      const lossTrigger = new BigNumber(entry.initialPriceExpressedInSol).times(1 - stopLossPercentage / 100)

      if (currentPrice.gte(profitTrigger) || currentPrice.lte(lossTrigger)) {
         this.addExecutingEntry(entry.id, 'simple')
         this.eventEmitter.emit('entry.triggered', {
            entry,
            trigger: currentPrice.gte(profitTrigger) ? 'profit' : 'loss',
            amount: new BigNumber(entry.tokenAmountBought),
         })
      }
   }

   private checkGridAutoSell(entry: SelectAutoSell, currentPrice: BigNumber) {
      const { stopLossType, profitTargets, stopLossPercentage } = entry.strategyParams as GridStrategy
      if (new BigNumber(entry.highestPriceExpressedInSol).lt(currentPrice)) {
         entry.highestPriceExpressedInSol = currentPrice.toString()
         this.updateAutoSellEntry(entry)
      }

      if (this.isEntryExecuting(entry.id, 'stop_loss')) return

      process.stdout.write('currentPrice: ' + currentPrice.toString())
      let stopLossTriggered = false

      switch (stopLossType) {
         case 'static':
            const staticLossTrigger = new BigNumber(entry.initialPriceExpressedInSol).times(1 - stopLossPercentage / 100)
            stopLossTriggered = currentPrice.lte(staticLossTrigger)
            process.stdout.write(', staticLossTrigger ' + staticLossTrigger.toString())
            break
         case 'trailing':
            const highWaterMark = new BigNumber(entry.highestPriceExpressedInSol)
            const trailingStopLossTrigger = highWaterMark.times(1 - stopLossPercentage / 100)
            stopLossTriggered = currentPrice.lte(trailingStopLossTrigger)
            process.stdout.write(', trailingStopLossTrigger: ' + trailingStopLossTrigger.toString() + ', trailingStopLoss: ' + stopLossPercentage)
            break
      }

      if (stopLossTriggered) {
         this.addExecutingEntry(entry.id, 'stop_loss')
         this.eventEmitter.emit('entry.triggered', {
            entry,
            trigger: 'stop_loss',
            amount: new BigNumber(entry.tokenAmountBought).minus(entry.tokenAmountSold),
         })
         return
      }

      // Check profit targets
      for (let i = 0; i < profitTargets.length; i++) {
         const target = profitTargets[i]
         const trigger = `profit target ${target.multiplier}`

         if (target.done || this.isEntryExecuting(entry.id, trigger)) continue

         const targetPrice = new BigNumber(entry.initialPriceExpressedInSol).times(target.multiplier)
         process.stdout.write(', target ' + i + ': ' + targetPrice.toString())
         if (currentPrice.gte(targetPrice)) {
            const sellAmount = new BigNumber(entry.tokenAmountBought).times(target.sellPercentage / 100)
            if (sellAmount.isZero()) {
               console.log(entry.tokenAmountBought, target.sellPercentage)
               continue
            }
            this.addExecutingEntry(entry.id, trigger)
            this.eventEmitter.emit('entry.triggered', { entry, trigger: trigger, amount: sellAmount })
         }
      }
      console.log()
   }
}
</file>

<file path="apps/backend/src/blockchain/solana/sniper/autoSell/transactionExecution.service.ts">
import { Injectable } from '@nestjs/common'
import { OnEvent } from '@nestjs/event-emitter'
import { SolanaService } from '../../solana.service'
import { UserService } from 'src/user/user.service'
import { EncryptionService } from 'src/encryption/encryption.service'
import { EventEmitter2 } from '@nestjs/event-emitter'
import BigNumber from 'bignumber.js'

@Injectable()
export class TransactionExecutionService {
   constructor(
      private readonly solanaService: SolanaService,
      private readonly userService: UserService,
      private readonly encryptionService: EncryptionService,
      private eventEmitter: EventEmitter2,
   ) {}

   @OnEvent('entry.triggered')
   async handleTriggeredEntry({ entry, trigger, amount }: { entry: any; trigger: string; amount: BigNumber }) {
      console.log(`Executing auto-sell for user ${entry.userId} (${trigger} trigger)`)
      try {
         const wallet = await this.userService.getWalletById(entry.userId, entry.walletId)
         const user = await this.userService.findById(entry.userId)
         await this.solanaService.makeJupiterSwapTransaction(
            entry.tokenAddressToSell,
            this.solanaService.knownAddresses.WSOL,
            amount,
            parseFloat(entry.slippage) * 100,
            this.solanaService.base58ToKeypair(this.encryptionService.decrypt(wallet.walletPk, user.createdAt.toISOString())),
            'auto',
         )
         console.log(`Auto-sell executed for user ${entry.userId} (${trigger} trigger)`)

         // Emit event for successful transaction
         this.eventEmitter.emit('transaction.executed', { entry, trigger, amount })
      } catch (error) {
         console.error(`Failed to execute auto-sell for user ${entry.userId}:`, error)
         // Optionally emit an event for failed transactions
         this.eventEmitter.emit('transaction.failed', { entry, trigger, amount, error })
      }
   }
}
</file>

</repository_files>
